{"/home/travis/build/npmtest/node-npmtest-eris/test.js":"/* istanbul instrument in package npmtest_eris */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eris/lib.npmtest_eris.js":"/* istanbul instrument in package npmtest_eris */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eris = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eris = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eris/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eris && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eris */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eris\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eris.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_eris.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eris.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_eris.__dirname + '/lib.npmtest_eris.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/index.js":"\"use strict\";\n\nconst Client = require(\"./lib/Client\");\n\nfunction Eris(token, options) {\n    return new Client(token, options);\n}\n\nEris.Bucket = require(\"./lib/util/Bucket\");\nEris.Call = require(\"./lib/structures/Call\");\nEris.Channel = require(\"./lib/structures/Channel\");\nEris.Client = Client;\nEris.Collection = require(\"./lib/util/Collection\");\nEris.Command = require(\"./lib/command/Command\");\nEris.CommandClient = require(\"./lib/command/CommandClient\");\nEris.Constants = require(\"./lib/Constants\");\nEris.ExtendedUser = require(\"./lib/structures/ExtendedUser\");\nEris.GroupChannel = require(\"./lib/structures/GroupChannel\");\nEris.Guild = require(\"./lib/structures/Guild\");\nEris.GuildChannel = require(\"./lib/structures/GuildChannel\");\nEris.GuildIntegration = require(\"./lib/structures/GuildIntegration\");\nEris.Invite = require(\"./lib/structures/Invite\");\nEris.Member = require(\"./lib/structures/Member\");\nEris.Message = require(\"./lib/structures/Message\");\nEris.Permission = require(\"./lib/structures/Permission\");\nEris.PermissionOverwrite = require(\"./lib/structures/PermissionOverwrite\");\nEris.PrivateChannel = require(\"./lib/structures/PrivateChannel\");\nEris.Relationship = require(\"./lib/structures/Relationship\");\nEris.Role = require(\"./lib/structures/Role\");\nEris.Shard = require(\"./lib/gateway/Shard\");\nEris.SharedStream = require(\"./lib/voice/SharedStream\");\nEris.User = require(\"./lib/structures/User\");\nEris.VoiceConnection = require(\"./lib/voice/VoiceConnection\");\nEris.VoiceConnectionManager = require(\"./lib/voice/VoiceConnectionManager\");\nEris.VoiceState = require(\"./lib/structures/VoiceState\");\n\nmodule.exports = Eris;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/Client.js":"\"use strict\";\n\nconst GuildChannel = require(\"./structures/GuildChannel\");\nconst Collection = require(\"./util/Collection\");\nconst Constants = require(\"./Constants\");\nconst Endpoints = require(\"./rest/Endpoints\");\nconst ExtendedUser = require(\"./structures/ExtendedUser\");\nconst GroupChannel = require(\"./structures/GroupChannel\");\nconst Guild = require(\"./structures/Guild\");\nconst GuildIntegration = require(\"./structures/GuildIntegration\");\nconst Invite = require(\"./structures/Invite\");\nconst Member = require(\"./structures/Member\");\nconst Message = require(\"./structures/Message\");\nconst PrivateChannel = require(\"./structures/PrivateChannel\");\nconst Relationship = require(\"./structures/Relationship\");\nconst RequestHandler = require(\"./rest/RequestHandler\");\nconst Role = require(\"./structures/Role\");\nconst ShardManager = require(\"./gateway/ShardManager\");\nconst UnavailableGuild = require(\"./structures/UnavailableGuild\");\nconst User = require(\"./structures/User\");\nconst VoiceConnectionManager = require(\"./voice/VoiceConnectionManager\");\n\nvar EventEmitter;\ntry {\n    EventEmitter = require(\"eventemitter3\");\n} catch(err) {\n    EventEmitter = require(\"events\").EventEmitter;\n}\nvar Erlpack;\ntry {\n    Erlpack = require(\"erlpack\");\n} catch(err) { // eslint-disable no-empty\n}\n\n/**\n* Represents the main Eris client\n* @extends EventEmitter\n* @prop {String} token The bot user token\n* @prop {Boolean?} bot Whether the bot user belongs to an OAuth2 application\n* @prop {Object} options Eris options\n* @prop {Object} channelGuildMap Object mapping channel IDs to guild IDs\n* @prop {Collection<Shard>} shards Collection of shards Eris is using\n* @prop {Collection<Guild>} guilds Collection of guilds the bot is in\n* @prop {Object} privateChannelMap Object mapping user IDs to private channel IDs\n* @prop {Collection<PrivateChannel>} privateChannels Collection of private channels the bot is in\n* @prop {Collection<GroupChannel>} groupChannels Collection of group channels the bot is in (user accounts only)\n* @prop {VoiceConnectionManager} voiceConnections Extended collection of VoiceConnections the bot has\n* @prop {Object} retryAfters Object mapping endpoints to ratelimit expiry timestamps\n* @prop {Object} guildShardMap Object mapping guild IDs to shard IDs\n* @prop {Number} startTime Timestamp of bot ready event\n* @prop {Collection<UnavailableGuild>} unavailableGuilds Collection of unavailable guilds the bot is in\n* @prop {Number} uptime How long in milliseconds the bot has been up for\n* @prop {ExtendedUser} user The bot user\n* @prop {Collection<User>} users Collection of users the bot sees\n* @prop {Collection<Relationship>} relationships Collection of relationships the bot user has (user accounts only)\n* @prop {Array<Object>} userGuildSettings Array containing the individual guild settings of the bot user (user accounts only)\n* @prop {Object} userSettings Object containing the user account settings (user accounts only)\n* @prop {Object} notes Object mapping user IDs to user notes (user accounts only)\n*/\nclass Client extends EventEmitter {\n    /**\n    * Create a Client\n    * @arg {String} token bot token\n    * @arg {Object} [options] Eris options (all options are optional)\n    * @arg {Boolean} [options.autoreconnect=true] Have Eris autoreconnect when connection is lost\n    * @arg {Boolean} [options.compress=true] Whether to request WebSocket data to be compressed or not\n    * @arg {Number} [options.connectionTimeout=30000] How long in milliseconds to wait for the connection to handshake with the server\n    * @arg {Object} [options.disableEvents] If disableEvents[eventName] is true, the WS event will not be processed. This can cause significant performance increase on large bots. [A full list of the WS event names can be found on the docs reference page](/Eris/docs/reference#ws-event-names)\n    * @arg {Boolean} [options.disableEveryone=true] When true, filter out @everyone/@here by default in createMessage/editMessage\n    * @arg {Number} [options.firstShardID=0] The ID of the first shard to run for this client\n    * @arg {Boolean} [options.getAllUsers=false] Get all the users in every guild. Ready time will be severely delayed\n    * @arg {Number} [options.guildCreateTimeout=2000] How long in milliseconds to wait for a GUILD_CREATE before \"ready\" is fired. Increase this value if you notice missing guilds\n    * @arg {Number} [options.largeThreshold=250] The maximum number of offline users per guild during initial guild data transmission\n    * @arg {Number} [options.lastShardID=options.maxShards - 1] The ID of the last shard to run for this client\n    * @arg {Number} [options.maxShards=1] The total number of shards you want to run\n    * @arg {Number} [options.messageLimit=100] The maximum size of a channel message cache\n    * @arg {Boolean} [options.opusOnly=false] Whether to suppress the node-opus not found error or not\n    * @arg {Boolean} [options.restMode=false] Whether to enable getting objects over REST. This should only be enabled if you are not connecting to the gateway. Bot tokens must be prefixed manually in REST mode\n    * @arg {Boolean} [options.seedVoiceConnections=false] Whether to populate bot.voiceConnections with existing connections the bot account has during startup. Note that this will disconnect connections from other bot sessions\n    * @arg {Number} [options.sequencerWait=200] How long to wait between sending potentially ratelimited requests. This number should be at least 3/4 your ping (in milliseconds)\n    * @arg {Number} [options.state=true] Whether to enable state tracking. If state is false, no objects will be cached\n    * @arg {String} [options.defaultImageFormat=\"jpg\"] The default format to provide user avatars, guild icons, and group icons in. Can be \"jpg\", \"png\", \"gif\", or \"webp\"\n    * @arg {Number} [options.defaultImageSize=128] The default size to return user avatars, guild icons, and group icons as. Can be 128, 256, 512, 1024, or 2048.\n    */\n    constructor(token, options) {\n        super();\n\n        this.options = {\n            autoreconnect: true,\n            compress: true,\n            connectionTimeout: 30000,\n            disableEvents: {},\n            disableEveryone: true,\n            firstShardID: 0,\n            getAllUsers: false,\n            guildCreateTimeout: 2000,\n            largeThreshold: 250,\n            maxShards: 1,\n            messageLimit: 100,\n            opusOnly: false,\n            restMode: false,\n            seedVoiceConnections: false,\n            sequencerWait: 200,\n            defaultImageFormat: \"jpg\",\n            defaultImageSize: 128\n        };\n        if(typeof options === \"object\") {\n            for(var property of Object.keys(options)) {\n                this.options[property] = options[property];\n            }\n        }\n        if(this.options.lastShardID === undefined) {\n            this.options.lastShardID = this.options.maxShards - 1;\n        }\n        if(typeof window !== \"undefined\") {\n            try {\n                require(\"pako\");\n            } catch(err) {\n                this.options.compress = false; // zlib does not like Blobs, Pako is not here\n            }\n        }\n        if(!~Constants.ImageFormats.indexOf(this.options.defaultImageFormat.toLowerCase())) {\n            this.options.defaultImageFormat = \"jpg\";\n        }\n        if(!~Constants.ImageSizes.indexOf(this.options.defaultImageSize)) {\n            this.options.defaultImageSize = 128;\n        }\n\n        this.token = token;\n\n        this.requestHandler = new RequestHandler(this);\n\n        this.ready = false;\n        this.bot = this.options.restMode ? this.token.startsWith(\"Bot \") : true;\n        this.startTime = 0;\n        this.lastConnect = 0;\n        this.connectQueue = [];\n        this.channelGuildMap = {};\n        this.shards = new ShardManager(this);\n        this.groupChannels = new Collection(GroupChannel);\n        this.guilds = new Collection(Guild);\n        this.privateChannelMap = {};\n        this.privateChannels = new Collection(PrivateChannel);\n        this.retryAfters = {};\n        this.guildShardMap = {};\n        this.sharedStreams = {};\n        this.unavailableGuilds = new Collection(UnavailableGuild);\n        this.relationships = new Collection(Relationship);\n        this.users = new Collection(User);\n        this.presence = {\n            game: null,\n            status: \"offline\"\n        };\n        this.userGuildSettings = [];\n        this.userSettings = {};\n        this.notes = {};\n        this.voiceConnections = new VoiceConnectionManager();\n    }\n\n    get uptime() {\n        return this.startTime ? Date.now() - this.startTime : 0;\n    }\n\n    /**\n    * Tells all shards to connect.\n    * @returns {Promise} Resolves when all shards are initialized\n    */\n    connect() {\n        return this.getGateway().then((data) => {\n            if(!data.url) {\n                return Promise.reject(new Error(\"Invalid response from gateway REST call\"));\n            }\n            if(data.url.includes(\"?\")) {\n                data.url = data.url.substring(0, data.url.indexOf(\"?\"));\n            }\n            if(!data.url.endsWith(\"/\")) {\n                data.url += \"/\";\n            }\n            this.gatewayURL = data.url + \"?v=\" + Constants.GATEWAY_VERSION + \"&encoding=\" + (Erlpack ? \"etf\" : \"json\");\n            for(var i = this.options.firstShardID; i <= this.options.lastShardID; ++i) {\n                this.shards.spawn(i);\n            }\n        }).catch((err) => {\n            this.emit(\"error\", err);\n            setTimeout(() => this.connect(), 2000);\n        });\n    }\n\n    /**\n    * Get the Discord gateway URL\n    * @returns {Promise<String>} Resolves with the gateway URL\n    */\n    getGateway() {\n        return this.requestHandler.request(\"GET\", Endpoints.GATEWAY);\n    }\n\n    /**\n    * Get the Discord gateway URL along with bot metadata\n    * @returns {Promise<Object>} Resolves with the gateway data\n    */\n    getBotGateway() {\n        if(!this.token.startsWith(\"Bot \")) {\n            this.token = \"Bot \" + this.token;\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GATEWAY_BOT, true);\n    }\n\n    /**\n    * Disconnects all shards\n    * @arg {Object?} [options] Shard disconnect options\n    * @arg {String | Boolean} [options.reconnect] false means destroy everything, true means you want to reconnect in the future, \"auto\" will autoreconnect\n    */\n    disconnect(options) {\n        this.ready = false;\n        this.shards.forEach((shard) => {\n            shard.disconnect(options);\n        });\n        this.connectQueue = [];\n    }\n\n    /**\n    * Join a voice channel. If joining a group call, the voice connection ID will be stored in voiceConnections as \"call\". Otherwise, it will be the guild ID\n    * @arg {String} channelID The ID of the voice channel\n    * @arg {Object} [options] VoiceConnection constructor options\n    * @arg {Object} [options.shared] Whether the VoiceConnection will be part of a SharedStream or not\n    * @arg {Object} [options.opusOnly] Skip opus encoder initialization. You should not enable this unless you know what you are doing\n    * @returns {Promise<VoiceConnection>} Resolves with a VoiceConnection\n    */\n    joinVoiceChannel(channelID, options) {\n        var channel = this.getChannel(channelID);\n        if(!channel) {\n            return Promise.reject(new Error(\"Channel not found\"));\n        }\n        if(channel.guild && !channel.permissionsOf(this.user.id).allow & Constants.Permissions.voiceConnect) {\n            return Promise.reject(new Error(\"Insufficient permission to connect to voice channel\"));\n        }\n        this.shards.get(this.guildShardMap[this.channelGuildMap[channelID]] || 0).sendWS(Constants.GatewayOPCodes.VOICE_STATE_UPDATE, {\n            guild_id: this.channelGuildMap[channelID] || null,\n            channel_id: channelID || null,\n            self_mute: false,\n            self_deaf: false\n        });\n        options = options || {};\n        if(options.opusOnly === undefined) {\n            options.opusOnly = this.options.opusOnly;\n        }\n        return this.voiceConnections.join(this.channelGuildMap[channelID] || \"call\", channelID, options);\n    }\n\n    /**\n    * Leaves a voice channel\n    * @arg {String} channelID The ID of the voice channel\n    */\n    leaveVoiceChannel(channelID) {\n        var channel = this.getChannel(channelID);\n        if(!channel) {\n            return;\n        }\n        this.shards.get(this.guildShardMap[this.channelGuildMap[channelID]] || 0).sendWS(Constants.GatewayOPCodes.VOICE_STATE_UPDATE, {\n            guild_id: this.channelGuildMap[channelID] || null,\n            channel_id: null,\n            self_mute: false,\n            self_deaf: false\n        });\n        this.voiceConnections.leave(this.channelGuildMap[channelID] || \"call\");\n    }\n\n    /**\n    * Updates the bot's status on all guilds\n    * @arg {String} [status] Sets the bot's status, either \"online\", \"idle\", \"dnd\", or \"invisible\"\n    * @arg {Object} [game] Sets the bot's active game, null to clear\n    * @arg {String} game.name Sets the name of the bot's active game\n    * @arg {Number} [game.type] The type of game. 0 is default, 1 is streaming (Twitch only)\n    * @arg {String} [game.url] Sets the url of the shard's active game\n    */\n    editStatus(status, game) {\n        this.shards.forEach((shard) => {\n            shard.editStatus(status, game);\n        });\n\n        if(game === undefined && typeof status === \"object\") {\n            game = status;\n            status = undefined;\n        }\n        if(status) {\n            this.presence.status = status;\n        }\n        if(game !== undefined) {\n            this.presence.game = game;\n        }\n    }\n\n    /**\n    * Get a Channel object from a channelID\n    * @arg {String} [channelID] The ID of the channel\n    * @returns {GuildChannel | GroupChannel | PrivateChannel}\n    */\n    getChannel(channelID) {\n        return this.channelGuildMap[channelID] ? this.guilds.get(this.channelGuildMap[channelID]).channels.get(channelID) : this.privateChannels.get(channelID) || this.groupChannels.get(channelID);\n    }\n\n    /**\n    * Create a channel in a guild\n    * @arg {String} guildID The ID of the guild to create the channel in\n    * @arg {String} name The name of the channel\n    * @arg {String} [type=0] The type of the channel, either 0 or 2\n    * @returns {Promise<GuildChannel>}\n    */\n    createChannel(guildID, name, type) {\n        var guild = this.guilds.get(guildID);\n        if(!guild) {\n            return Promise.reject(new Error(`Guild ${guildID} not found`));\n        }\n        return this.requestHandler.request(\"POST\", Endpoints.GUILD_CHANNELS(guildID), true, {\n            name,\n            type\n        }).then((channel) => new GuildChannel(channel, guild));\n    }\n\n    /**\n    * Edit a channel's properties\n    * @arg {String} channelID The ID of the channel\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The name of the channel\n    * @arg {String} [options.icon] The icon of the channel as a base64 data URI (group channels only). Note: base64 strings alone are not base64 data URI strings\n    * @arg {String} [options.ownerID] The ID of the channel owner (group channels only)\n    * @arg {String} [options.topic] The topic of the channel (guild text channels only)\n    * @arg {Number} [options.bitrate] The bitrate of the channel (guild voice channels only)\n    * @arg {Number} [options.userLimit] The channel user limit (guild voice channels only)\n    * @returns {Promise<GroupChannel | GuildChannel>}\n    */\n    editChannel(channelID, options) {\n        var channel = this.getChannel(channelID);\n        if(!channel) {\n            return Promise.reject(new Error(`Channel ${channelID} not found`));\n        }\n\n        return this.requestHandler.request(\"PATCH\", Endpoints.CHANNEL(channelID), true, {\n            name: options.name,\n            icon: options.icon,\n            owner_id: options.ownerID,\n            topic: options.topic,\n            bitrate: options.bitrate,\n            user_limit: options.userLimit\n        }).then((data) => {\n            if(channel.guild) {\n                return new GuildChannel(data, channel.guild);\n            } else {\n                return new GroupChannel(data, this);\n            }\n        });\n    }\n\n    /**\n    * Edit a guild channel's position. Note that channel position numbers are lowest on top and highest at the bottom.\n    * @arg {String} channelID The ID of the channel\n    * @arg {Number} position The new position of the channel\n    * @returns {Promise}\n    */\n    editChannelPosition(channelID, position) {\n        var channels = this.guilds.get(this.channelGuildMap[channelID]).channels;\n        var channel = channels.get(channelID);\n        if(!channel) {\n            return Promise.reject(new Error(`Channel ${channelID} not found`));\n        }\n        if(channel.position === position) {\n            return Promise.resolve();\n        }\n        var min = Math.min(position, channel.position);\n        var max = Math.max(position, channel.position);\n        channels = channels.filter((chan) => chan.type === channel.type && min <= chan.position && chan.position <= max && chan.id !== channelID).sort((a, b) => a.position - b.position);\n        if(position > channel.position) {\n            channels.push(channel);\n        } else {\n            channels.unshift(channel);\n        }\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_CHANNELS(this.channelGuildMap[channelID]), true, channels.map((channel, index) => ({\n            id: channel.id,\n            position: index + min\n        })));\n    }\n\n    /**\n    * Delete a guild channel, or leave a private or group channel\n    * @arg {String} channelID The ID of the channel\n    * @returns {Promise}\n    */\n    deleteChannel(channelID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL(channelID), true);\n    }\n\n    /**\n    * Send typing status in a channel\n    * @arg {String} channelID The ID of the channel\n    * @returns {Promise}\n    */\n    sendChannelTyping(channelID) {\n        return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_TYPING(channelID), true);\n    }\n\n    /**\n    * Create a channel permission overwrite\n    * @arg {String} channelID The ID of channel\n    * @arg {String} overwriteID The ID of the overwritten user or role\n    * @arg {Number} allow The permissions number for allowed permissions\n    * @arg {Number} deny The permissions number for denied permissions\n    * @arg {String} type The object type of the overwrite, either \"member\" or \"role\"\n    * @returns {Promise}\n    */\n    editChannelPermission(channelID, overwriteID, allow, deny, type) {\n        return this.requestHandler.request(\"PUT\", Endpoints.CHANNEL_PERMISSION(channelID, overwriteID), true, {\n            allow,\n            deny,\n            type\n        });\n    }\n\n    /**\n    * Delete a channel permission overwrite\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} overwriteID The ID of the overwritten user or role\n    * @returns {Promise}\n    */\n    deleteChannelPermission(channelID, overwriteID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL_PERMISSION(channelID, overwriteID), true);\n    }\n\n    /**\n    * Get all invites in a channel\n    * @arg {String} channelID The ID of the channel\n    * @returns {Promise<Invite[]>}\n    */\n    getChannelInvites(channelID) {\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_INVITES(channelID), true).then((invites) => invites.map((invite) => new Invite(invite, this)));\n    }\n\n    /**\n    * Create an invite for a channel\n    * @arg {String} channelID The ID of the channel\n    * @arg {Object} [options] Invite generation options\n    * @arg {Number} [options.maxAge] How long the invite should last in seconds\n    * @arg {Number} [options.maxUses] How many uses the invite should last for\n    * @arg {Boolean} [options.temporary] Whether the invite is temporary or not\n    * @arg {Boolean} [options.unique] Whether the invite is unique or not\n    * @returns {Promise<Invite>}\n    */\n    createChannelInvite(channelID, options) {\n        options = options || {};\n        return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_INVITES(channelID), true, {\n            max_age: options.maxAge,\n            max_uses: options.maxUses,\n            temporary: options.temporary,\n            unique: options.unique\n        }).then(invite => new Invite(invite, this));\n    }\n\n    /**\n    * Get all the webhooks in a channel\n    * @arg {String} channelID The ID of the channel to get webhooks for\n    * @returns {Promise<Object[]>} Resolves with an array of webhook objects\n    */\n    getChannelWebhooks(channelID) {\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_WEBHOOKS(channelID), true);\n    }\n\n    /**\n    * Get a webhook\n    * @arg {String} webhookID The ID of the webhook\n    * @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token\n    * @returns {Promise<Object>} Resolves with a webhook object\n    */\n    getWebhook(webhookID, token) {\n        return this.requestHandler.request(\"GET\", token ? Endpoints.WEBHOOK_TOKEN(webhookID, token) : Endpoints.WEBHOOK(webhookID), !token);\n    }\n\n    /**\n    * Create a channel webhook\n    * @arg {String} channelID The ID of the channel to create the webhook in\n    * @arg {Object} options Webhook options\n    * @arg {String} options.name The default name\n    * @arg {String} options.avatar The default avatar as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @returns {Promise<Object>} Resolves with a webhook object\n    */\n    createChannelWebhook(channelID, options) {\n        return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_WEBHOOKS(channelID), true, options);\n    }\n\n    /**\n    * Edit a webhook\n    * @arg {String} webhookID The ID of the webhook\n    * @arg {Object} options Webhook options\n    * @arg {String} [options.name] The new default name\n    * @arg {String} [options.avatar] The new default avatar as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token\n    * @returns {Promise<Object>} Resolves with a webhook object\n    */\n    editWebhook(webhookID, options, token) {\n        return this.requestHandler.request(\"PATCH\", token ? Endpoints.WEBHOOK_TOKEN(webhookID, token) : Endpoints.WEBHOOK(webhookID), !token, options);\n    }\n\n    /**\n    * Execute a webhook\n    * @arg {String} webhookID The ID of the webhook\n    * @arg {String} token The token of the webhook\n    * @arg {Object} options Webhook execution options\n    * @arg {String} [options.content=\"\"] A content string\n    * @arg {Object} [options.file] A file object\n    * @arg {Buffer} options.file.file A buffer containing file data\n    * @arg {String} options.file.name What to name the file\n    * @arg {Object[]} [options.embeds] An array of Discord embeds\n    * @arg {String} [options.username] A custom username, defaults to webhook default username if not specified\n    * @arg {String} [options.avatarURL] A URL for a custom avatar, defaults to webhook default avatar if not specified\n    * @arg {Boolean} [options.tts=false] Whether the message should be a TTS message or not\n    * @arg {Boolean} [options.wait=false] Whether to wait for the server to confirm the message create or not\n    * @arg {Boolean} [options.disableEveryone] Whether to filter @everyone/@here or not (overrides default)\n    * @returns {Promise}\n    */\n    executeWebhook(webhookID, token, options) {\n        if(!options.content && !options.file && !options.embeds) {\n            return Promise.reject(new Error(\"No content, file, or embeds\"));\n        }\n        if(options.content && (options.disableEveryone !== undefined ? options.disableEveryone : this.options.disableEveryone)) {\n            options.content = options.content.replace(/@everyone/g, \"@\\u200beveryone\").replace(/@here/g, \"@\\u200bhere\");\n        }\n        return this.requestHandler.request(\"POST\", Endpoints.WEBHOOK_TOKEN(webhookID, token) + (options.wait ? \"?wait=true\" : \"\"), true, {\n            content: options.content,\n            embeds: options.embeds,\n            username: options.username,\n            avatar_url: options.avatarURL,\n            tts: options.tts\n        }, options.file);\n    }\n\n    /**\n    * Execute a slack-style webhook\n    * @arg {String} webhookID The ID of the webhook\n    * @arg {String} token The token of the webhook\n    * @arg {Object} options Slack webhook options\n    * @arg {Boolean} [options.wait=false] Whether to wait for the server to confirm the message create or not\n    * @returns {Promise}\n    */\n    executeSlackWebhook(webhookID, token, options) {\n        var wait = !!options.wait;\n        options.wait = undefined;\n        return this.requestHandler.request(\"POST\", Endpoints.WEBHOOK_TOKEN_SLACK(webhookID, token) + (wait ? \"?wait=true\" : \"\"), true, options);\n    }\n\n    /**\n    * Delete a webhook\n    * @arg {String} webhookID The ID of the webhook\n    * @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token\n    * @returns {Promise}\n    */\n    deleteWebhook(webhookID, token) {\n        return this.requestHandler.request(\"DELETE\", token ? Endpoints.WEBHOOK_TOKEN(webhookID, token) : Endpoints.WEBHOOK(webhookID), !token);\n    }\n\n    /**\n    * Get all the webhooks in a guild\n    * @arg {String} guildID The ID of the guild to get webhooks for\n    * @returns {Promise<Object[]>} Resolves with an array of webhook objects\n    */\n    getGuildWebhooks(guildID) {\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_WEBHOOKS(guildID), true);\n    }\n\n    /**\n    * Create a guild emoji object (not for bot accounts)\n    * @arg {String} guildID The ID of the guild to create the emoji in\n    * @arg {Object} options Emoji options\n    * @arg {String} options.name The name of emoji\n    * @arg {String} options.image The base 64 encoded string\n    * @arg {Array} [options.roles] An array containing authorized role IDs\n    * @returns {Promise<Object>} A guild emoji object\n    */\n    createGuildEmoji(guildID, options) {\n      return this.requestHandler.request(\"POST\", Endpoints.GUILD_EMOJIS(guildID), true, options);\n    }\n    /**\n    * Edit a guild emoji object (not for bot accounts)\n    * @arg {String} guildID The ID of the guild to edit the emoji in\n    * @arg {String} emojiID The ID of the emoji you want to modify\n    * @arg {Object} options Emoji options\n    * @arg {String} [options.name] The name of emoji\n    * @arg {Array} [options.roles] An array containing authorized role IDs\n    * @returns {Promise<Object>} A guild emoji object\n    */\n    editGuildEmoji(guildID, emojiID, options) {\n      return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_EMOJI(guildID, emojiID), true, options);\n    }\n    /**\n    * Delete a guild emoji object (not for bot accounts)\n    * @arg {String} guildID The ID of the guild to delete the emoji in\n    * @arg {String} emojiID The ID of the emoji\n    * @returns {Promise}\n    */\n    deleteGuildEmoji(guildID, emojiID) {\n      return this.requestHandler.request(\"DELETE\", Endpoints.GUILD_EMOJI(guildID, emojiID), true);\n    }\n    /**\n    * Create a guild role\n    * @arg {String} guildID The ID of the guild to create the role in\n    * @arg {Object} [options] The properties to set\n    * @arg {String} [options.name] The name of the role\n    * @arg {Number} [options.permissions] The role permissions number\n    * @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3d15b3 or 4040115)\n    * @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not\n    * @arg {Boolean} [options.mentionable] Whether the role is mentionable or not\n    * @returns {Promise<Role>}\n    */\n    createRole(guildID, options) {\n        return this.requestHandler.request(\"POST\", Endpoints.GUILD_ROLES(guildID), true, options).then((role) => new Role(role, this.guilds.get(guildID)));\n    }\n\n    /**\n    * Edit a guild role\n    * @arg {String} guildID The ID of the guild the role is in\n    * @arg {String} roleID The ID of the role\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The name of the role\n    * @arg {Number} [options.permissions] The role permissions number\n    * @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3da5b3 or 4040115)\n    * @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not\n    * @arg {Boolean} [options.mentionable] Whether the role is mentionable or not\n    * @returns {Promise<Role>}\n    */\n    editRole(guildID, roleID, options) {\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_ROLE(guildID, roleID), true, options).then((role) => new Role(role, this.guilds.get(guildID)));\n    }\n\n    /**\n    * Edit a guild role's position. Note that role position numbers are highest on top and lowest at the bottom.\n    * @arg {String} guildID The ID of the guild the role is in\n    * @arg {String} roleID The ID of the role\n    * @arg {Number} position The new position of the role\n    * @returns {Promise}\n    */\n    editRolePosition(guildID, roleID, position) {\n        if(guildID === roleID) {\n            return Promise.reject(new Error(\"Cannot move default role\"));\n        }\n        var roles = this.guilds.get(guildID).roles;\n        var role = roles.get(roleID);\n        if(!role) {\n            return Promise.reject(new Error(`Role ${roleID} not found`));\n        }\n        if(role.position === position) {\n            return Promise.resolve();\n        }\n        var min = Math.min(position, role.position);\n        var max = Math.max(position, role.position);\n        roles = roles.filter((role) => min <= role.position && role.position <= max && role.id !== roleID).sort((a, b) => a.position - b.position);\n        if(position > role.position) {\n            roles.push(role);\n        } else {\n            roles.unshift(role);\n        }\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_ROLES(guildID), true, roles.map((role, index) => ({\n            id: role.id,\n            position: index + min\n        })));\n    }\n\n    /**\n    * Create a guild role\n    * @arg {String} guildID The ID of the guild to create the role in\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    deleteRole(guildID, roleID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.GUILD_ROLE(guildID, roleID), true);\n    }\n\n    /**\n    * Get the prune count for a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {Number} days The number of days of inactivity to prune for\n    * @returns {Promise<Number>} Resolves with the number of users that would be pruned\n    */\n    getPruneCount(guildID, days) {\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_PRUNE(guildID), true, {\n            days\n        }).then((data) => data.pruned);\n    }\n\n    /**\n    * Begin pruning a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {Number} days The number of days of inactivity to prune for\n    * @returns {Promise<Number>} Resolves with the number of pruned users\n    */\n    pruneMembers(guildID, days) {\n        return this.requestHandler.request(\"POST\", Endpoints.GUILD_PRUNE(guildID), true, {\n            days\n        }).then((data) => data.pruned);\n    }\n\n    /**\n    * Get a list of general/guild-specific voice reigons\n    * @arg {String} [guildID] The ID of the guild\n    * @returns {Promise<Object[]>} Resolves with an array of voice region objects\n    */\n    getVoiceRegions(guildID) {\n        return guildID ? this.requestHandler.request(\"GET\", Endpoints.GUILD_VOICE_REGIONS(guildID), true) : this.requestHandler.request(\"GET\", Endpoints.VOICE_REGIONS, true); // TODO parse regions\n    }\n\n    /**\n    * Get info on an invite\n    * @arg {String} inviteID The ID of the invite\n    * @returns {Promise<Invite>}\n    */\n    getInvite(inviteID) {\n        return this.requestHandler.request(\"GET\", Endpoints.INVITE(inviteID), true).then((invite) => {\n            if(this.channelGuildMap[invite.channel.id] && this.getChannel(invite.channel.id).permissionsOf(this.user.id).json.manageChannels) {\n                return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_INVITES(invite.channel.id), true, {\n                    validate: inviteID\n                }).then((extendedInvite) => new Invite(extendedInvite, this));\n            }\n            return new Invite(invite, this);\n        });\n    }\n\n    /**\n    * Accept an invite (not for bot accounts)\n    * @arg {String} inviteID The ID of the invite\n    * @returns {Promise<Invite>}\n    */\n    acceptInvite(inviteID) {\n        return this.requestHandler.request(\"POST\", Endpoints.INVITE(inviteID), true).then((invite) => new Invite(invite, this));\n    }\n\n    /**\n    * Delete an invite\n    * @arg {String} inviteID The ID of the invite\n    * @returns {Promise}\n    */\n    deleteInvite(inviteID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.INVITE(inviteID), true);\n    }\n\n    /**\n    * Get properties of the bot user\n    * @returns {Promise<ExtendedUser>}\n    */\n    getSelf() {\n        return this.requestHandler.request(\"GET\", Endpoints.USER(\"@me\"), true).then((data) => new ExtendedUser(data, this));\n    }\n\n    /**\n    * Edit properties of the bot user\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.username] The new username\n    * @arg {String} [options.avatar] The new avatar as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @returns {Promise<ExtendedUser>}\n    */\n    editSelf(options) {\n        return this.requestHandler.request(\"PATCH\", Endpoints.USER(\"@me\"), true, options).then((data) => new ExtendedUser(data, this));\n    }\n\n    /**\n    * Get a DM channel with a user, or create one if it does not exist\n    * @arg {String} userID The ID of the user\n    * @returns {Promise<PrivateChannel>}\n    */\n    getDMChannel(userID) {\n        if(this.privateChannelMap[userID]) {\n            return Promise.resolve(this.privateChannels.get(this.privateChannelMap[userID]));\n        }\n        return this.requestHandler.request(\"POST\", Endpoints.USER_CHANNELS(\"@me\"), true, {\n            recipients: [userID],\n            type: 1\n        }).then((privateChannel) => new PrivateChannel(privateChannel, this));\n    }\n\n    /**\n    * Create a group channel with other users\n    * @arg {String[]} userIDs The IDs of the other users\n    * @returns {Promise<PrivateChannel>}\n    */\n    createGroupChannel(userIDs) {\n        return this.requestHandler.request(\"POST\", Endpoints.USER_CHANNELS(\"@me\"), true, {\n            recipients: userIDs,\n            type: 3\n        }).then((privateChannel) => new GroupChannel(privateChannel, this));\n    }\n\n    /**\n    * Get a previous message in a channel\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise<Message>}\n    */\n    getMessage(channelID, messageID) {\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_MESSAGE(channelID, messageID), true).then((message) => new Message(message, this));\n    }\n\n    /**\n    * Get previous messages in a channel\n    * @arg {String} channelID The ID of the channel\n    * @arg {Number} [limit=50] The max number of messages to get\n    * @arg {String} [before] Get messages before this message ID\n    * @arg {String} [after] Get messages after this message ID\n    * @arg {String} [around] Get messages around this message ID (does not work with limit > 100)\n    * @returns {Promise<Message[]>}\n    */\n    getMessages(channelID, limit, before, after, around) {\n        if(limit && limit > 100) {\n            return new Promise((resolve, reject) => {\n                var logs = [];\n                var get = (_before, _after) => {\n                    this.requestHandler.request(\"GET\", Endpoints.CHANNEL_MESSAGES(channelID), true, {\n                        limit: 100,\n                        before: _before || undefined,\n                        after: _after || undefined\n                    }).then((messages) => {\n                        if(limit <= messages.length) {\n                            return resolve((_after ? messages.slice(messages.length - limit, messages.length).map((message) => new Message(message, this)).concat(logs) : logs.concat(messages.slice(0, limit).map((message) => new Message(message, this)))));\n                        }\n                        limit -= messages.length;\n                        logs = (_after ? messages.map((message) => new Message(message, this)).concat(logs) : logs.concat(messages.map((message) => new Message(message, this))));\n                        if(messages.length < 100) {\n                            return resolve(logs);\n                        }\n                        this.emit(\"debug\", `Getting ${limit} more messages during getMessages for ${channelID}: ${_before} ${_after}`, -1);\n                        get((_before || !_after) && messages[messages.length - 1].id, _after && messages[0].id);\n                    }).catch(reject);\n                };\n                get(before, after);\n            });\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_MESSAGES(channelID), true, {\n            limit: limit || 50,\n            before,\n            after,\n            around\n        }).then((messages) => messages.map((message) => {\n            try {\n                return new Message(message, this);\n            } catch(err) {\n                this.emit(\"error\", `ERROR CREATING MESSAGE FROM CHANNEL MESSAGES: ${JSON.stringify(messages)}`);\n                return null;\n            }\n        }));\n    }\n\n    /**\n    * Get all the pins in a channel\n    * @arg {String} channelID The ID of the channel\n    * @returns {Promise<Message[]>}\n    */\n    getPins(channelID) {\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_PINS(channelID), true).then((messages) => messages.map((message) => new Message(message, this)));\n    }\n\n    /**\n    * Create a message in a channel\n    * Note: If you want to DM someone, the user ID is **not** the DM channel ID. use Client.getDMChannel() to get the DM channel for a user\n    * @arg {String} channelID The ID of the channel\n    * @arg {String | Array | Object} content A string, array of strings, or object. If an object is passed:\n    * @arg {String} content.content A content string\n    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers/docs/resources/channel#embed-object) for object structure\n    * @arg {Boolean} [content.tts] Set the message TTS flag\n    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)\n    * @arg {Object} [file] A file object\n    * @arg {Buffer} file.file A buffer containing file data\n    * @arg {String} file.name What to name the file\n    * @returns {Promise<Message>}\n    */\n    createMessage(channelID, content, file) {\n        if(typeof content === \"string\") {\n            content = {\n                content: content\n            };\n        } else if(typeof content !== \"object\" || content == null) {\n            content = {\n                content: content ? \"\" + content : \"\"\n            };\n        } else if(typeof content.content !== \"string\") {\n            content.content = content.content ? \"\" + content.content : \"\";\n        }\n        if(!content.content && !file && !content.embed) {\n            return Promise.reject(new Error(\"No content, file, or embed\"));\n        }\n        if(content.disableEveryone !== undefined ? content.disableEveryone : this.options.disableEveryone) {\n            content.content = content.content.replace(/@everyone/g, \"@\\u200beveryone\").replace(/@here/g, \"@\\u200bhere\");\n        }\n        return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_MESSAGES(channelID), true, content, file).then((message) => new Message(message, this));\n    }\n\n    /**\n    * Edit a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @arg {String | Array | Object} content A string, array of strings, or object. If an object is passed:\n    * @arg {String} content.content A content string\n    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)\n    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers/docs/resources/channel#embed-object) for object structure\n    * @returns {Promise<Message>}\n    */\n    editMessage(channelID, messageID, content) {\n        if(typeof content === \"string\") {\n            content = {\n                content: content\n            };\n        } else if(typeof content !== \"object\" || content == null) {\n            content = {\n                content: content ? \"\" + content : \"\"\n            };\n        } else if(typeof content.content !== \"string\") {\n            content.content = content.content ? \"\" + content.content : \"\";\n        }\n        if(!content.content && !content.embed) {\n            return Promise.reject(new Error(\"No content or embed\"));\n        }\n        if(content.disableEveryone !== undefined ? content.disableEveryone : this.options.disableEveryone) {\n            content.content = content.content.replace(/@everyone/g, \"@\\u200beveryone\").replace(/@here/g, \"@\\u200bhere\");\n        }\n        return this.requestHandler.request(\"PATCH\", Endpoints.CHANNEL_MESSAGE(channelID, messageID), true, content).then((message) => new Message(message, this));\n    }\n\n    /**\n    * Pin a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    pinMessage(channelID, messageID) {\n        return this.requestHandler.request(\"PUT\", Endpoints.CHANNEL_PIN(channelID, messageID), true);\n    }\n\n    /**\n    * Unpin a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    unpinMessage(channelID, messageID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL_PIN(channelID, messageID), true);\n    }\n\n    /**\n    * Get a list of users who reacted with a specific reaction\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {Number} [limit=100] The maximum number of users to get\n    * @returns {Promise<User[]>}\n    */\n    getMessageReaction(channelID, messageID, reaction, limit) {\n        if(reaction === decodeURI(reaction)) {\n            reaction = encodeURIComponent(reaction);\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_MESSAGE_REACTION(channelID, messageID, reaction), true, {\n            limit: limit || 100\n        }).then((users) => users.map((user) => new User(user, this)));\n    }\n\n    /**\n    * Add a reaction to a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {String} [userID=\"@me\"] The ID of the user to react as\n    * @returns {Promise}\n    */\n    addMessageReaction(channelID, messageID, reaction, userID) {\n        if(reaction === decodeURI(reaction)) {\n            reaction = encodeURIComponent(reaction);\n        }\n        return this.requestHandler.request(\"PUT\", Endpoints.CHANNEL_MESSAGE_REACTION_USER(channelID, messageID, reaction, userID || \"@me\"), true);\n    }\n\n    /**\n    * Remove a reaction from a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {String} [userID=\"@me\"] The ID of the user to remove the reaction for\n    * @returns {Promise}\n    */\n    removeMessageReaction(channelID, messageID, reaction, userID) {\n        if(reaction === decodeURI(reaction)) {\n            reaction = encodeURIComponent(reaction);\n        }\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL_MESSAGE_REACTION_USER(channelID, messageID, reaction, userID || \"@me\"), true);\n    }\n\n    /**\n    * Remove all reactions from a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    removeMessageReactions(channelID, messageID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL_MESSAGE_REACTIONS(channelID, messageID), true);\n    }\n\n    /**\n    * Delete a message\n    * @arg {String} channelID The ID of the channel\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    deleteMessage(channelID, messageID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL_MESSAGE(channelID, messageID), true);\n    }\n\n    /**\n    * Bulk delete messages (bot accounts only)\n    * @arg {String} channelID The ID of the channel\n    * @arg {String[]} messageIDs Array of message IDs to delete\n    * @returns {Promise}\n    */\n    deleteMessages(channelID, messageIDs) {\n        if(messageIDs.length === 0) {\n            return Promise.resolve();\n        }\n        if(messageIDs.length === 1) {\n            return this.deleteMessage(channelID, messageIDs[0]);\n        }\n\n        var oldestAllowedSnowflake = (Date.now() - 1421280000000) * 4194304;\n        var invalidMessage = messageIDs.find((messageID) => messageID < oldestAllowedSnowflake);\n        if(invalidMessage) {\n            return Promise.reject(new Error(`Message ${invalidMessage} is more than 2 weeks old.`));\n        }\n\n        if(messageIDs.length > 100) {\n            return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_BULK_DELETE(channelID), true, {\n                messages: messageIDs.splice(0, 100)\n            }).then(() => this.deleteMessages(channelID, messageIDs));\n        }\n        return this.requestHandler.request(\"POST\", Endpoints.CHANNEL_BULK_DELETE(channelID), true, {\n            messages: messageIDs\n        });\n    }\n\n    /**\n    * Purge previous messages in a channel with an optional filter (bot accounts only)\n    * @arg {String} channelID The ID of the channel\n    * @arg {Number} limit The max number of messages to search through, -1 for no limit\n    * @arg {function} [filter] Optional filter function that returns a boolean when passed a Message object\n    * @arg {String} [before] Get messages before this message ID\n    * @arg {String} [after] Get messages after this message ID\n    * @returns {Promise<Number>} Resolves with the number of messages deleted\n    */\n    purgeChannel(channelID, limit, filter, before, after) {\n        if(typeof filter === \"string\") {\n            filter = (msg) => msg.content.includes(filter);\n        }\n        return new Promise((resolve, reject) => {\n            var toDelete = [];\n            var deleted = 0;\n            var done = false;\n            var checkToDelete = () => {\n                var messageIDs = (done && toDelete) || (toDelete.length >= 100 && toDelete.splice(0, 100));\n                if(messageIDs) {\n                    deleted += messageIDs.length;\n                    this.deleteMessages(channelID, messageIDs).then(() => {\n                        if(done) {\n                            return resolve(deleted);\n                        }\n                        setTimeout(() => {\n                            checkToDelete();\n                        }, 1000);\n                    }).catch(reject);\n                } else if(done) {\n                    return resolve(deleted);\n                } else {\n                    setTimeout(() => {\n                        checkToDelete();\n                    }, 250);\n                }\n            };\n            var del = (_before, _after) => {\n                this.getMessages(channelID, 100, _before, _after).then((messages) => {\n                    if(limit === 0) {\n                        done = true;\n                        return;\n                    }\n                    for(var message of messages) {\n                        if(limit === 0) {\n                            break;\n                        }\n                        if(message.timestamp < Date.now() - 1209600000) { // 14d * 24h * 60m * 60s * 1000ms\n                            done = true;\n                            return;\n                        }\n                        if(!filter || filter(message)) {\n                            toDelete.push(message.id);\n                        }\n                        limit--;\n                    }\n                    if(limit === 0 || messages.length < 100) {\n                        done = true;\n                        return;\n                    }\n                    del((_before || !_after) && messages[messages.length - 1].id, _after && messages[0].id);\n                }).catch(reject);\n            };\n            del(before, after);\n            checkToDelete();\n        });\n    }\n\n    /**\n    * Get a guild's embed object\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<Object>} A guild embed object\n    */\n    getGuildEmbed(guildID) {\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_EMBED(guildID), true);\n    }\n\n    /**\n    * Get a list of integrations for a guild\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<GuildIntegration[]>}\n    */\n    getGuildIntegrations(guildID) {\n        var guild = this.guilds.get(guildID);\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_INTEGRATIONS(guildID), true).then((integrations) => integrations.map((integration) => new GuildIntegration(integration, guild)));\n    }\n\n    /**\n    * Edit a guild integration\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} integrationID The ID of the integration\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.expireBehavior] What to do when a user's subscription runs out\n    * @arg {String} [options.expireGracePeriod] How long before the integration's role is removed from an unsubscribed user\n    * @arg {String} [options.enableEmoticons] Whether to enable integration emoticons or not\n    * @returns {Promise}\n    */\n    editGuildIntegration(guildID, integrationID, options) {\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_INTEGRATION(guildID, integrationID), true, {\n            expire_behavior: options.expireBehavior,\n            expire_grace_period: options.expireGracePeriod,\n            enable_emoticons: options.enableEmoticons\n        });\n    }\n\n    /**\n    * Delete a guild integration\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} integrationID The ID of the integration\n    * @returns {Promise}\n    */\n    deleteGuildIntegration(guildID, integrationID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.GUILD_INTEGRATION(guildID, integrationID), true);\n    }\n\n    /**\n    * Force a guild integration to sync\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} integrationID The ID of the integration\n    * @returns {Promise}\n    */\n    syncGuildIntegration(guildID, integrationID) {\n        return this.requestHandler.request(\"POST\", Endpoints.GUILD_INTEGRATION_SYNC(guildID, integrationID), true);\n    }\n\n    /**\n    * Get all invites in a guild\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<Invite[]>}\n    */\n    getGuildInvites(guildID) {\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_INVITES(guildID), true).then((invites) => invites.map((invite) => new Invite(invite, this)));\n    }\n\n    /**\n    * Ban a user from a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} userID The ID of the user\n    * @arg {Number} [deleteMessageDays=0] Number of days to delete messages for, between 0-7 inclusive\n    * @returns {Promise}\n    */\n    banGuildMember(guildID, userID, deleteMessageDays) {\n        if(!isNaN(deleteMessageDays) && (deleteMessageDays < 0 || deleteMessageDays > 7)) {\n            return Promise.reject(new Error(`Invalid deleteMessageDays value (${deleteMessageDays}), should be a number between 0-7 inclusive`));\n        }\n        return this.requestHandler.request(\"PUT\", Endpoints.GUILD_BAN(guildID, userID), true, {\n            \"delete-message-days\": deleteMessageDays || 0\n        });\n    }\n\n    /**\n    * Unban a user from a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} userID The ID of the user\n    * @returns {Promise}\n    */\n    unbanGuildMember(guildID, userID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.GUILD_BAN(guildID, userID), true);\n    }\n\n    /**\n    * Create a guild\n    * @arg {String} name The name of the guild\n    * @arg {String} region The region of the guild\n    * @arg {String} [icon] The guild icon as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @returns {Promise<Guild>}\n    */\n    createGuild(name, region, icon) {\n        icon = icon || null;\n        return this.requestHandler.request(\"POST\", Endpoints.GUILDS, true, {\n            name,\n            region,\n            icon\n        }).then((guild) => new Guild(guild, this));\n    }\n\n    /**\n    * Edit a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The ID of the guild\n    * @arg {String} [options.region] The region of the guild\n    * @arg {String} [options.icon] The guild icon as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @arg {Number} [options.verificationLevel] The guild verification level\n    * @arg {Number} [options.defaultNotifications] The default notification settings for the guild. 0 is \"All Messages\", 1 is \"Only @mentions\".\n    * @arg {String} [options.afkChannelID] The ID of the AFK voice channel\n    * @arg {Number} [options.afkTimeout] The AFK timeout in seconds\n    * @arg {String} [options.ownerID] The ID of the user to transfer server ownership to (bot user must be owner)\n    * @arg {String} [options.splash] The guild splash image as a base64 data URI (VIP only). Note: base64 strings alone are not base64 data URI strings\n    * @returns {Promise<Guild>}\n    */\n    editGuild(guildID, options) {\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD(guildID), true, {\n            name: options.name,\n            region: options.region,\n            icon: options.icon,\n            verification_level: options.verificationLevel,\n            default_message_notifications: options.defaultNotifications,\n            afk_channel_id: options.afkChannelID,\n            afk_timeout: options.afkTimeout,\n            splash: options.splash,\n            owner_id: options.ownerID\n        }).then((guild) => new Guild(guild, this));\n    }\n\n    /**\n    * Get the ban list of a guild\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<User[]>}\n    */\n    getGuildBans(guildID) {\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_BANS(guildID), true).then((bans) => bans.map((ban) => new User(ban.user, this)));\n    }\n\n    /**\n    * Edit a guild member\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} memberID The ID of the member\n    * @arg {Object} options The properties to edit\n    * @arg {String[]} [options.roles] The array of role IDs the member should have\n    * @arg {String} [options.nick] Set the member's server nickname, \"\" to remove\n    * @arg {Boolean} [options.mute] Server mute the member\n    * @arg {Boolean} [options.deaf] Server deafen the member\n    * @arg {String} [options.channelID] The ID of the voice channel to move the member to (must be in voice)\n    * @returns {Promise}\n    */\n    editGuildMember(guildID, memberID, options) {\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_MEMBER(guildID, memberID), true, {\n            roles: options.roles,\n            nick: options.nick,\n            mute: options.mute,\n            deaf: options.deaf,\n            channel_id: options.channelID\n        });\n    }\n\n    /**\n    * Add a role to a guild member\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} memberID The ID of the member\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    addGuildMemberRole(guildID, memberID, roleID) {\n        return this.requestHandler.request(\"PUT\", Endpoints.GUILD_MEMBER_ROLE(guildID, memberID, roleID), true);\n    }\n\n    /**\n    * Remve a role from a guild member\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} memberID The ID of the member\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    removeGuildMemberRole(guildID, memberID, roleID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.GUILD_MEMBER_ROLE(guildID, memberID, roleID), true);\n    }\n\n    /**\n    * Edit the bot's nickname in a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} nick The nickname\n    * @returns {Promise}\n    */\n    editNickname(guildID, nick) {\n        return this.requestHandler.request(\"PATCH\", Endpoints.GUILD_MEMBER_NICK(guildID, \"@me\"), true, {\n            nick\n        });\n    }\n\n    /**\n    * Kick a user from a guild\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} userID The ID of the user\n    * @returns {Promise}\n    */\n    kickGuildMember(guildID, userID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.GUILD_MEMBER(guildID, userID), true);\n    }\n\n    /**\n    * Delete a guild (bot user must be owner)\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise}\n    */\n    deleteGuild(guildID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.GUILD(guildID), true);\n    }\n\n    /**\n    * Leave a guild\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise}\n    */\n    leaveGuild(guildID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.USER_GUILD(\"@me\", guildID), true);\n    }\n\n    /**\n    * Get data on an OAuth2 application\n    * @arg {String} [appID=\"@me\"] The client ID of the application to get data for. \"@me\" refers to the logged in user's own application\n    * @returns {Promise<Object>} The bot's application data. Refer to [the official Discord API documentation entry](https://discordapp.com/developers/docs/topics/oauth2#get-current-application-information) for object structure\n    */\n    getOAuthApplication(appID) {\n        return this.requestHandler.request(\"GET\", Endpoints.OAUTH2_APPLICATION(appID || \"@me\"), true);\n    }\n\n    /**\n    * Get user settings (user accounts only)\n    * @returns {Promise<Object>} The user's settings data.\n    */\n    getUserSettings() {\n        return this.requestHandler.request(\"GET\", Endpoints.USER_SETTINGS(\"@me\"), true);\n    }\n\n    /**\n    * Create a relationship with a user\n    * @arg {String} userID The ID of the target user\n    * @arg {Boolean} [block=false] If true, block the user. Otherwise, add the user as a friend\n    * @returns {Promise}\n    */\n    addRelationship(userID, block) {\n        return this.requestHandler.request(\"PUT\", Endpoints.USER_RELATIONSHIP(\"@me\", userID), true, {\n            type: block ? 2 : undefined\n        });\n    }\n\n    /**\n    * Remove a relationship with a user\n    * @arg {String} userID The ID of the target user\n    * @returns {Promise}\n    */\n    removeRelationship(userID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.USER_RELATIONSHIP(\"@me\", userID), true);\n    }\n\n    /**\n    * Add a user to a group\n    * @arg {String} groupID The ID of the target group\n    * @arg {String} userID The ID of the target user\n    * @returns {Promise}\n    */\n    addGroupRecipient(groupID, userID) {\n        return this.requestHandler.request(\"PUT\", Endpoints.CHANNEL_RECIPIENT(groupID, userID), true);\n    }\n\n    /**\n    * Remove a user from a group\n    * @arg {String} groupID The ID of the target group\n    * @arg {String} userID The ID of the target user\n    * @returns {Promise}\n    */\n    removeGroupRecipient(groupID, userID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.CHANNEL_RECIPIENT(groupID, userID), true);\n    }\n\n    /**\n    * Get profile data for a user (user accounts only)\n    * @arg {String} userID The ID of the target user\n    * @returns {Promise<Object>} The user's profile data.\n    */\n    getUserProfile(userID) {\n        return this.requestHandler.request(\"GET\", Endpoints.USER_PROFILE(userID), true);\n    }\n\n    /**\n    * Edit the current user's note for another user (user accounts only)\n    * @arg {String} note The note\n    * @returns {Promise}\n    */\n    editUserNote(userID, note) {\n        return this.requestHandler.request(\"GET\", Endpoints.USER_NOTE(\"@me\", userID), true, {\n            note: note\n        });\n    }\n\n    /**\n    * Delete the current user's note for another user (user accounts only)\n    * @returns {Promise}\n    */\n    deleteUserNote(userID) {\n        return this.requestHandler.request(\"DELETE\", Endpoints.USER_NOTE(\"@me\", userID), true);\n    }\n\n    /**\n    * Get a channel's data via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} channelID The ID of the channel\n    * @returns {Promise<GuildChannel | GroupChannel | PrivateChannel>}\n    */\n    getRESTChannel(channelID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL(channelID), true).then((channel) => {\n            if(channel.type === 0 || channel.type === 2) {\n                return new GuildChannel(channel, null, this.options.messageLimit);\n            } else if(channel.type === 1) {\n                return new PrivateChannel(channel, this);\n            } else if(channel.type === 3) {\n                return new GroupChannel(channel, this);\n            } else {\n                return channel;\n            }\n        });\n    }\n\n    /**\n    * Get a guild's data via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<Guild>}\n    */\n    getRESTGuild(guildID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD(guildID), true).then((guild) => new Guild(guild, this));\n    }\n\n    /**\n    * Get a list of the user's guilds via the REST API. REST mode is required to use this endpoint.\n    * @arg {Number} [limit=100] The max number of guilds to get (1 to 1000)\n    * @arg {String} [before] The lowest guild ID of the next page\n    * @arg {String} [after] The highest guild ID of the previous page\n    * @returns {Promise<Guild[]>}\n    */\n    getRESTGuilds(limit, before, after) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.USER_GUILDS(\"@me\"), true, {\n            limit,\n            before,\n            after\n        }).then((guilds) => guilds.map((guild) => new Guild(guild, this)));\n    }\n\n    /**\n    * Get a guild's channels via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<GuildChannel[]>}\n    */\n    getRESTGuildChannels(guildID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_CHANNELS(guildID), true).then((channels) => channels.map((channel) => new GuildChannel(channel, null, this.options.messageLimit)));\n    }\n\n    /**\n    * Get a guild's emojis via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<Object[]>} An array of guild emoji objects\n    */\n    getRESTGuildEmojis(guildID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_EMOJIS(guildID), true);\n    }\n\n    /**\n    * Get a guild emoji via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} emojiID The ID of the emoji\n    * @returns {Promise<Object>} An emoji object\n    */\n    getRESTGuildEmoji(guildID, emojiID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_EMOJI(guildID, emojiID), true);\n    }\n\n    /**\n    * Get a guild's members via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @arg {Number} [limit=1] The max number of members to get (1 to 1000)\n    * @arg {String} [after] The highest user ID of the previous page\n    * @returns {Promise<Member[]>}\n    */\n    getRESTGuildMembers(guildID, limit, after) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_MEMBERS(guildID), true, {\n            limit,\n            after\n        }).then((members) => members.map((member) => new Member(member, null)));\n    }\n\n    /**\n    * Get a guild's members via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @arg {String} memberID The ID of the member\n    * @returns {Promise<Member>}\n    */\n    getRESTGuildMember(guildID, memberID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_MEMBER(guildID, memberID), true).then((member) => new Member(member, null));\n    }\n\n    /**\n    * Get a guild's roles via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} guildID The ID of the guild\n    * @returns {Promise<Role[]>}\n    */\n    getRESTGuildRoles(guildID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_ROLES(guildID), true).then((roles) => roles.map((role) => new Role(role, null)));\n    }\n\n    /**\n    * Get a user's data via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} userID The ID of the user\n    * @returns {Promise<User>}\n    */\n    getRESTUser(userID) {\n        if(!this.options.restMode) {\n            return Promise.reject(new Error(\"Eris REST mode is not enabled\"));\n        }\n        return this.requestHandler.request(\"GET\", Endpoints.USER(userID), true).then((user) => new User(user, this));\n    }\n\n    /**\n    * Search a channel's messages\n    * @arg {String} channelID The ID of the channel\n    * @arg {Object} query Search parameters\n    * @arg {String} [query.sortBy=\"timestamp\"] What to sort by, either \"timestamp\" or \"relevance\"\n    * @arg {String} [query.sortOrder=\"desc\"] What order to sort by, either \"asc\" or \"desc\"\n    * @arg {String} [query.content] Filter results by a content string\n    * @arg {String} [query.authorID] Filter results by an author ID\n    * @arg {String} [query.minID] The minimum message ID to return results for\n    * @arg {String} [query.maxID] The maximum message ID to return results for\n    * @arg {Number} [query.limit=25] How many messages to return, 1 <= limit <= 25\n    * @arg {Number} [query.offset=0] The query index of the first message to be returned, 0 <= offset <= 5000\n    * @arg {Number} [query.contextSize=2] How many context messages around each result to return.\n    * For example, if you searched for `6` and contextSize was 2, `[4, 5, 6, 7, 8]` would be returned\n    * @arg {String} [query.has] Only return messages with an \"attachment\", \"embed\", or \"link\"\n    * @arg {String} [query.embedProviders] Filter results by embed provider\n    * @arg {String} [query.embedTypes] Filter results by embed type\n    * @arg {String} [query.attachmentExtensions] Filter results by attachment extension\n    * @arg {String} [query.attachmentFilename] Filter results by attachment filename\n    * @returns {Promise<Object>} A search result object. The object will have a `totalResults` key and `results` key.\n    * Each entry in the result array is an array of Message objects.\n    * In each array, the message where `Message.hit === true` is the matched message, while the other messages are context messages.\n    * Sample return: ```\n    * {\n    *     totalResults: 2,\n    *     results: [\n    *         [Message, Message, Message (Message.hit = true), Message],\n    *         [Message, Message, Message (Message.hit = true), Message, Message]\n    *     ]\n    * }\n    * ```\n    */\n    searchChannelMessages(channelID, query) {\n        return this.requestHandler.request(\"GET\", Endpoints.CHANNEL_MESSAGES_SEARCH(channelID), true, {\n            sort_by: query.sortBy,\n            sort_order: query.sortOrder,\n            content: query.content,\n            author_id: query.authorID,\n            min_id: query.minID,\n            max_id: query.maxID,\n            limit: query.limit,\n            offset: query.offset,\n            context_size: query.contextSize,\n            has: query.has,\n            embed_providers: query.embedProviders,\n            embed_types: query.embedTypes,\n            attachment_extensions: query.attachmentExtensions,\n            attachment_filename: query.attachmentFilename\n        }).then((results) => ({\n            totalResults: results.total_results,\n            results: results.messages.map((result) => result.map((message) => new Message(message, this)))\n        }));\n    }\n\n    /**\n    * Search a guild's messages\n    * @arg {String} guildID The ID of the guild\n    * @arg {Object} query Search parameters\n    * @arg {String} [query.sortBy=\"timestamp\"] What to sort by, either \"timestamp\" or \"relevance\"\n    * @arg {String} [query.sortOrder=\"desc\"] What order to sort by, either \"asc\" or \"desc\"\n    * @arg {String} [query.content] Filter results by a content string\n    * @arg {String} [query.authorID] Filter results by an author ID\n    * @arg {String} [query.minID] The minimum message ID to return results for\n    * @arg {String} [query.maxID] The maximum message ID to return results for\n    * @arg {Number} [query.limit=25] How many messages to return, 1 <= limit <= 25\n    * @arg {Number} [query.offset=0] The query index of the first message to be returned, 0 <= offset <= 5000\n    * @arg {Number} [query.contextSize=2] How many context messages around each result to return.\n    * For example, if you searched for `6` and contextSize was 2, `[4, 5, 6, 7, 8]` would be returned\n    * @arg {String} [query.has] Only return messages with an \"attachment\", \"embed\", or \"link\"\n    * @arg {String} [query.embedProviders] Filter results by embed provider\n    * @arg {String} [query.embedTypes] Filter results by embed type\n    * @arg {String} [query.attachmentExtensions] Filter results by attachment extension\n    * @arg {String} [query.attachmentFilename] Filter results by attachment filename\n    * @arg {String[]} [query.channelIDs] Filter results by channel ID\n    * @returns {Promise<Object>} A search result object. The object will have a `totalResults` key and `results` key.\n    * Each entry in the result array is an array of Message objects.\n    * In each array, the message where `Message.hit === true` is the matched message, while the other messages are context messages.\n    * Sample return: ```\n    * {\n    *     totalResults: 2,\n    *     results: [\n    *         [Message, Message, Message (Message.hit = true), Message],\n    *         [Message, Message, Message (Message.hit = true), Message, Message]\n    *     ]\n    * }\n    * ```\n    */\n    searchGuildMessages(guildID, query) {\n        return this.requestHandler.request(\"GET\", Endpoints.GUILD_MESSAGES_SEARCH(guildID), true, {\n            sort_by: query.sortBy,\n            sort_order: query.sortOrder,\n            content: query.content,\n            author_id: query.authorID,\n            min_id: query.minID,\n            max_id: query.maxID,\n            limit: query.limit,\n            offset: query.offset,\n            context_size: query.contextSize,\n            has: query.has,\n            embed_providers: query.embedProviders,\n            embed_types: query.embedTypes,\n            attachment_extensions: query.attachmentExtensions,\n            attachment_filename: query.attachmentFilename,\n            channel_id: query.channelIDs\n        }).then((results) => ({\n            totalResults: results.total_results,\n            results: results.messages.map((result) => result.map((message) => new Message(message, this)))\n        }));\n    }\n}\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/GuildChannel.js":"\"use strict\";\n\nconst Channel = require(\"./Channel\");\nconst Collection = require(\"../util/Collection\");\nconst Member = require(\"./Member\");\nconst Message = require(\"./Message\");\nconst Permission = require(\"./Permission\");\nconst Permissions = require(\"../Constants\").Permissions;\nconst PermissionOverwrite = require(\"./PermissionOverwrite\");\n\n/**\n* Represents a guild channel\n* @extends Channel\n* @prop {String} mention A string that mentions the channel\n* @prop {Guild} guild The guild that owns the channel\n* @prop {Collection<Message>} messages Collection of Messages in this channel\n* @prop {String} lastMessageID The ID of the last message in this channel\n* @prop {Number} lastPinTimestamp The timestamp of the last pinned message\n* @prop {Collection<PermissionOverwrite>} permissionOverwrites Collection of PermissionOverwrites in this channel\n* @prop {Number} type The type of the channel, either 0 (text) or 2 (voice)\n* @prop {String} name The name of the channel\n* @prop {Number} position The position of the channel\n* @prop {String?} topic The topic of the channel (text channels only)\n* @prop {Number?} bitrate The bitrate of the channel (voice channels only)\n* @prop {Number?} userLimit The max number of users that can join the channel (voice channels only)\n* @prop {Collection<Member>?} voiceMembers Collection of Members in this channel (voice channels only)\n*/\nclass GuildChannel extends Channel {\n    constructor(data, guild, messageLimit) {\n        super(data);\n        this.guild = guild;\n        if(this.type === 2) {\n            this.voiceMembers = new Collection(Member);\n        } else {\n            if(messageLimit == null && guild) {\n                messageLimit = guild.shard.client.options.messageLimit;\n            }\n            this.messages = new Collection(Message, messageLimit);\n            this.lastMessageID = data.last_message_id || null;\n            this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n        }\n        this.update(data);\n    }\n\n    update(data) {\n        this.name = data.name !== undefined ? data.name : this.name;\n        this.topic = data.topic !== undefined ? data.topic : this.topic;\n        this.position = data.position !== undefined ? data.position : this.position;\n        this.bitrate = data.bitrate !== undefined ? data.bitrate : this.bitrate;\n        this.userLimit = data.user_limit !== undefined ? data.user_limit : this.userLimit;\n        if(data.permission_overwrites) {\n            this.permissionOverwrites = new Collection(PermissionOverwrite);\n            data.permission_overwrites.forEach((overwrite) => {\n                this.permissionOverwrites.add(overwrite);\n            });\n        }\n    }\n\n    /**\n    * Get the channel-specific permissions of a member\n    * @arg {String} memberID The ID of the member\n    * @returns {Permission}\n    */\n    permissionsOf(memberID) {\n        var member = this.guild.members.get(memberID);\n        var permission = member.permission.allow;\n        if(permission & Permissions.administrator) {\n            return new Permission(Permissions.all);\n        }\n        var deny = 0;\n        var allow = 0;\n        for(var overwrite of this.permissionOverwrites) {\n            if(overwrite[1].type === \"role\" && (overwrite[1].id === this.guild.id || ~member.roles.indexOf(overwrite[1].id))) {\n                deny |= overwrite[1].deny;\n                allow |= overwrite[1].allow;\n            }\n        }\n        permission = (permission & ~deny) | allow;\n        var memberOverwrite = this.permissionOverwrites.get(memberID);\n        if(memberOverwrite) {\n            permission = (permission & ~memberOverwrite.deny) | memberOverwrite.allow;\n        }\n        return new Permission(permission);\n    }\n\n    get mention() {\n        return `<#${this.id}>`;\n    }\n\n    /**\n    * Edit the channel's properties\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The name of the channel\n    * @arg {String} [options.topic] The topic of the channel (guild text channels only)\n    * @arg {Number} [options.bitrate] The bitrate of the channel (guild voice channels only)\n    * @arg {Number} [options.userLimit] The channel user limit (guild voice channels only)\n    * @returns {Promise<GuildChannel>}\n    */\n    edit(options) {\n        return this.guild.shard.client.editChannel.call(this.guild.shard.client, this.id, options);\n    }\n\n    /**\n    * Edit the channel's position. Note that channel position numbers are lowest on top and highest at the bottom.\n    * @arg {Number} position The new position of the channel\n    * @returns {Promise}\n    */\n    editPosition(position) {\n        return this.guild.shard.client.editChannelPosition.call(this.guild.shard.client, this.id, position);\n    }\n\n    /**\n    * Delete the channel\n    * @returns {Promise}\n    */\n    delete() {\n        return this.guild.shard.client.deleteChannel.call(this.guild.shard.client, this.id);\n    }\n\n    /**\n    * Create a channel permission overwrite\n    * @arg {String} overwriteID The ID of the overwritten user or role\n    * @arg {Number} allow The permissions number for allowed permissions\n    * @arg {Number} deny The permissions number for denied permissions\n    * @arg {String} type The object type of the overwrite, either \"member\" or \"role\"\n    * @returns {Promise<PermissionOverwrite>}\n    */\n    editPermission(overwriteID, allow, deny, type) {\n        return this.guild.shard.client.editChannelPermission.call(this.guild.shard.client, this.id, overwriteID, allow, deny, type);\n    }\n\n    /**\n    * Delete a channel permission overwrite\n    * @arg {String} overwriteID The ID of the overwritten user or role\n    * @returns {Promise}\n    */\n    deletePermission(overwriteID) {\n        return this.guild.shard.client.deleteChannelPermission.call(this.guild.shard.client, this.id, overwriteID);\n    }\n\n    /**\n    * Get all invites in the channel\n    * @returns {Promise<Invite[]>}\n    */\n    getInvites() {\n        return this.guild.shard.client.getChannelInvites.call(this.guild.shard.client, this.id);\n    }\n\n    /**\n    * Create an invite for the channel\n    * @arg {Object} [options] Invite generation options\n    * @arg {Number} [options.maxAge] How long the invite should last in seconds\n    * @arg {Number} [options.maxUses] How many uses the invite should last for\n    * @arg {Boolean} [options.temporary] Whether the invite is temporary or not\n    * @returns {Promise<Invite>}\n    */\n    createInvite(options) {\n        return this.guild.shard.client.createChannelInvite.call(this.guild.shard.client, this.id, options);\n    }\n\n    /**\n    * Get all the webhooks in the channel\n    * @returns {Promise<Object[]>} Resolves with an array of webhook objects\n    */\n    getWebhooks() {\n        return this.guild.shard.client.getChannelWebhooks.call(this.guild.shard.client, this.id);\n    }\n\n    /**\n    * Create a channel webhook\n    * @arg {Object} options Webhook options\n    * @arg {String} options.name The default name\n    * @arg {String} options.avatar The default avatar as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @returns {Promise<Object>} Resolves with a webhook object\n    */\n    createWebhook(options) {\n        return this.guild.shard.client.createChannelWebhook.call(this.guild.shard.client, this.id, options);\n    }\n}\n\nmodule.exports = GuildChannel;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Channel.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\n\n/**\n* Represents a channel. You also probably want to look at GroupChannel, GuildChannel, and PrivateChannel\n* @prop {String} id The ID of the channel\n* @prop {Number} createdAt Timestamp of the channel's creation\n*/\nclass Channel extends Base {\n    constructor(data) {\n        super(data.id);\n        this.type = data.type;\n    }\n\n    /**\n    * Send typing status in a text channel\n    * @returns {Promise}\n    */\n    sendTyping() {\n        return (this._client || this.guild.shard.client).sendChannelTyping.call((this._client || this.guild.shard.client), this.id);\n    }\n\n    /**\n    * Get a previous message in a text channel\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise<Message>}\n    */\n    getMessage(messageID) {\n        return (this._client || this.guild.shard.client).getMessage.call((this._client || this.guild.shard.client), this.id, messageID);\n    }\n\n    /**\n    * Get a previous message in a text channel\n    * @arg {Number} [limit=50] The max number of messages to get\n    * @arg {String} [before] Get messages before this message ID\n    * @arg {String} [after] Get messages after this message ID\n    * @arg {String} [around] Get messages around this message ID (does not work with limit > 100)\n    * @returns {Promise<Message[]>}\n    */\n    getMessages(limit, before, after, around) {\n        return (this._client || this.guild.shard.client).getMessages.call((this._client || this.guild.shard.client), this.id, limit, before, after, around);\n    }\n\n    /**\n    * Get all the pins in a text channel\n    * @returns {Promise<Message[]>}\n    */\n    getPins() {\n        return (this._client || this.guild.shard.client).getPins.call((this._client || this.guild.shard.client), this.id);\n    }\n\n    /**\n    * Create a message in a text channel\n    * Note: If you want to DM someone, the user ID is **not** the DM channel ID. use Client.getDMChanne() to get the DM channel ID for a user\n    * @arg {String | Object} content A string or object. If an object is passed:\n    * @arg {String} content.content A content string\n    * @arg {Boolean} [content.tts] Set the message TTS flag\n    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)\n    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers/docs/resources/channel#embed-object) for object structure\n    * @arg {Object} [file] A file object\n    * @arg {String} file.file A buffer containing file data\n    * @arg {String} file.name What to name the file\n    * @returns {Promise<Message>}\n    */\n    createMessage(content, file) {\n        return (this._client || this.guild.shard.client).createMessage.call((this._client || this.guild.shard.client), this.id, content, file);\n    }\n\n    /**\n    * Edit a message\n    * @arg {String} messageID The ID of the message\n    * @arg {String | Array | Object} content A string, array of strings, or object. If an object is passed:\n    * @arg {String} content.content A content string\n    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)\n    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers/docs/resources/channel#embed-object) for object structure\n    * @returns {Promise<Message>}\n    */\n    editMessage(messageID, content) {\n        return (this._client || this.guild.shard.client).editMessage.call((this._client || this.guild.shard.client), this.id, messageID, content);\n    }\n\n    /**\n    * Pin a message\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    pinMessage(messageID) {\n        return (this._client || this.guild.shard.client).pinMessage.call((this._client || this.guild.shard.client), this.id, messageID);\n    }\n\n    /**\n    * Unpin a message\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    unpinMessage(messageID) {\n        return (this._client || this.guild.shard.client).unpinMessage.call((this._client || this.guild.shard.client), this.id, messageID);\n    }\n\n    /**\n    * Get a list of users who reacted with a specific reaction\n    * @arg {String} messageID The ID of the message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {Number} [limit=100] The maximum number of users to get\n    * @returns {Promise<User[]>}\n    */\n    getMessageReaction(messageID, reaction, limit) {\n        return (this._client || this.guild.shard.client).getMessageReaction.call((this._client || this.guild.shard.client), this.id, messageID, reaction, limit);\n    }\n\n    /**\n    * Add a reaction to a message\n    * @arg {String} messageID The ID of the message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {String} [userID=\"@me\"] The ID of the user to react as\n    * @returns {Promise}\n    */\n    addMessageReaction(messageID, reaction, userID) {\n        return (this._client || this.guild.shard.client).addMessageReaction.call((this._client || this.guild.shard.client), this.id, messageID, reaction, userID);\n    }\n\n    /**\n    * Remove a reaction from a message\n    * @arg {String} messageID The ID of the message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {String} [userID=\"@me\"] The ID of the user to remove the reaction for\n    * @returns {Promise}\n    */\n    removeMessageReaction(messageID, reaction, userID) {\n        return (this._client || this.guild.shard.client).removeMessageReaction.call((this._client || this.guild.shard.client), this.id, messageID, reaction, userID);\n    }\n\n    /**\n    * Remove all reactions from a message\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    removeMessageReactions(messageID) {\n        return (this._client || this.guild.shard.client).removeMessageReactions.call((this._client || this.guild.shard.client), this.id, messageID);\n    }\n\n    /**\n    * Delete a message\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    deleteMessage(messageID) {\n        return (this._client || this.guild.shard.client).deleteMessage.call((this._client || this.guild.shard.client), this.id, messageID);\n    }\n\n    /**\n    * Un-send a message. You're welcome Programmix\n    * @arg {String} messageID The ID of the message\n    * @returns {Promise}\n    */\n    unsendMessage(messageID) {\n        return (this._client || this.guild.shard.client).deleteMessage.call((this._client || this.guild.shard.client), this.id, messageID);\n    }\n\n    /**\n    * Bulk delete messages (bot accounts only)\n    * @arg {String[]} messageIDs Array of message IDs to delete\n    * @returns {Promise}\n    */\n    deleteMessages(messageIDs) {\n        return (this._client || this.guild.shard.client).deleteMessages.call((this._client || this.guild.shard.client), this.id, messageIDs);\n    }\n\n    /**\n    * Purge previous messages in the channel with an optional filter (bot accounts only)\n    * @arg {Number} limit The max number of messages to search through, -1 for no limit\n    * @arg {function} [filter] Optional filter function that returns a boolean when passed a Message object\n    * @arg {String} [before] Get messages before this message ID\n    * @arg {String} [after] Get messages after this message ID\n    * @returns {Promise<Number>} Resolves with the number of messages deleted\n    */\n    purge(limit, filter, before, after) {\n        return (this._client || this.guild.shard.client).purgeChannel.call((this._client || this.guild.shard.client), this.id, limit, filter, before, after);\n    }\n}\n\nmodule.exports = Channel;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Base.js":"\"use strict\";\n\nclass Base {\n    constructor(id) {\n        if(id) {\n            this.id = id;\n        }\n    }\n\n    get createdAt() {\n        return (this.id / 4194304) + 1420070400000;\n    }\n\n    toJSON(arg, cache) {\n        cache = cache || [];\n        if(~cache.indexOf(this)) {\n            return \"[Circular]\";\n        } else {\n            cache.push(this);\n        }\n        var copy = {};\n        for(var key in this) {\n            if(this.hasOwnProperty(key) && !key.startsWith(\"_\")) {\n                if(!this[key]) {\n                    copy[key] = this[key];\n                } else if(this[key] instanceof Set) {\n                    copy[key] = Array.from(this[key]);\n                } else if(this[key] instanceof Map) {\n                    copy[key] = Array.from(this[key].values());\n                } else if(typeof this[key].toJSON === \"function\") {\n                    copy[key] = this[key].toJSON(key, cache);\n                } else {\n                    copy[key] = this[key];\n                }\n            }\n        }\n        return copy;\n    }\n\n    inspect() {\n        // http://stackoverflow.com/questions/5905492/dynamic-function-name-in-javascript\n        var copy = new (new Function(`return function ${this.constructor.name}(){}`)());\n        for(var key in this) {\n            if(this.hasOwnProperty(key) && !key.startsWith(\"_\") && this[key]) {\n                copy[key] = this[key];\n            }\n        }\n        return copy;\n    }\n}\n\nmodule.exports = Base;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/util/Collection.js":"\"use strict\";\n\n/**\n* Hold a bunch of something\n* @extends Map\n* @prop {Class} baseObject The base class for all items\n* @prop {Number?} limit Max number of items to hold\n*/\nclass Collection extends Map {\n    /**\n    * Construct a Collection\n    * @arg {Class} baseObject The base class for all items\n    * @arg {Number} [limit] Max number of items to hold\n    */\n    constructor(baseObject, limit) {\n        super();\n        this.baseObject = baseObject;\n        this.limit = limit;\n    }\n\n    /**\n    * Add an object\n    * @arg {Object} obj The object data\n    * @arg {String} obj.id The ID of the object\n    * @arg {Class?} extra An extra parameter the constructor may need\n    * @arg {Boolean} replace Whether to replace an existing object with the same ID\n    * @returns {Class} The existing or newly created object\n    */\n    add(obj, extra, replace) {\n        if(this.limit === 0) {\n            return (obj instanceof this.baseObject) ? obj : new this.baseObject(obj, extra);\n        }\n        if(obj.id == null) {\n            throw new Error(\"Missing object id\");\n        }\n        var existing = this.get(obj.id);\n        if(existing && !replace) {\n            return existing;\n        }\n        if(!(obj instanceof this.baseObject)) {\n            obj = new this.baseObject(obj, extra);\n        }\n\n        this.set(obj.id, obj);\n\n        if(this.limit && this.size > this.limit) {\n            var iter = this.keys();\n            while(this.size > this.limit) {\n                this.delete(iter.next().value);\n            }\n        }\n        return obj;\n    }\n\n    /**\n    * Return the first object to make the function evaluate true\n    * @arg {function} func A function that takes an object and returns true if it matches\n    * @returns {Class?} The first matching object, or undefined if no match\n    */\n    find(func) {\n        for(var item of this.values()) {\n            if(func(item)) {\n                return item;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n    * Get a random object from the Collection\n    * @returns {Class?} The random object, or undefined if there is no match\n    */\n    random() {\n        if(!this.size) {\n            return undefined;\n        }\n        return Array.from(this.values())[Math.floor(Math.random() * this.size)];\n    }\n\n    /**\n    * Return all the objects that make the function evaluate true\n    * @arg {function} func A function that takes an object and returns true if it matches\n    * @returns {Array<Class>} An array containing all the objects that matched\n    */\n    filter(func) {\n        var arr = [];\n        for(var item of this.values()) {\n            if(func(item)) {\n                arr.push(item);\n            }\n        }\n        return arr;\n    }\n\n    /**\n    * Return an array with the results of applying the given function to each element\n    * @arg {function} func A function that takes an object and returns something\n    * @returns {Array} An array containing the results\n    */\n    map(func) {\n        var arr = [];\n        for(var item of this.values()) {\n            arr.push(func(item));\n        }\n        return arr;\n    }\n\n    /**\n    * Update an object\n    * @arg {Object} obj The updated object data\n    * @arg {String} obj.id The ID of the object\n    * @arg {Class?} extra An extra parameter the constructor may need\n    * @arg {Boolean} replace Whether to replace an existing object with the same ID\n    * @returns {Class} The updated object\n    */\n    update(obj, extra, replace) {\n        if(!obj.id && obj.id !== 0) {\n            throw new Error(\"Missing object id\");\n        }\n        var item = this.get(obj.id);\n        if(!item) {\n            return this.add(obj, extra, replace);\n        }\n        item.update(obj, extra);\n        return item;\n    }\n\n    /**\n    * Remove an object\n    * @arg {Object} obj The object\n    * @arg {String} obj.id The ID of the object\n    * @returns {Class?} The removed object, or null if nothing was removed\n    */\n    remove(obj) {\n        var item = this.get(obj.id);\n        if(!item) {\n            return null;\n        }\n        this.delete(obj.id);\n        return item;\n    }\n\n    toString() {\n        return `[Collection<${this.baseObject.name}>]`;\n    }\n}\n\nmodule.exports = Collection;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Member.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst Permission = require(\"./Permission\");\nconst Permissions = require(\"../Constants\").Permissions;\nconst VoiceState = require(\"./VoiceState\");\n\n/**\n* Represents a server member\n* @prop {String} id The ID of the member\n* @prop {String} mention A string that mentions the member\n* @prop {Guild} guild The guild the member is in\n* @prop {Number} joinedAt Timestamp of when the member joined the guild\n* @prop {String} status The member's status. Either \"online\", \"idle\", or \"offline\"\n* @prop {Object?} game The active game the member is playing\n* @prop {String} game.name The name of the active game\n* @prop {Number} game.type The type of the active game (0 is default, 1 is Twitch, 2 is YouTube)\n* @prop {String?} game.url The url of the active game\n* @prop {VoiceState} voiceState The voice state of the member\n* @prop {String?} nick The server nickname of the member\n* @prop {String[]} roles An array of role IDs this member is a part of\n* @prop {User} user The user object of the member\n* @prop {Permission} permission The guild-wide permissions of the member\n* @prop {String} defaultAvatar The hash for the default avatar of a user if there is no avatar set\n* @prop {Number} createdAt Timestamp of user creation\n* @prop {Boolean} bot Whether the user is an OAuth bot or not\n* @prop {String} username The username of the user\n* @prop {String} discriminator The discriminator of the user\n* @prop {String?} avatar The hash of the user's avatar, or null if no avatar\n* @prop {String} defaultAvatarURL The URL of the user's default avatar\n* @prop {String} avatarURL The URL of the user's avatar which can be either a JPG or GIF\n* @prop {String} staticAvatarURL The URL of the user's avatar (always a JPG)\n*/\nclass Member extends Base {\n    constructor(data, guild) {\n        super(data.id);\n        if((this.guild = guild)) {\n            this.user = guild.shard.client.users.get(data.id);\n            if(!this.user && data.user) {\n                this.user = guild.shard.client.users.add(data.user, guild.shard.client);\n            }\n            if(!this.user) {\n                throw new Error(\"User associated with Member not found: \" + data.id);\n            }\n        } else {\n            this.user = null;\n        }\n        this.voiceState = new VoiceState(data);\n        this.update(data);\n    }\n\n    update(data) {\n        this.status = data.status !== undefined ? data.status : this.status || \"offline\";\n        this.game = data.game !== undefined ? data.game : this.game || null;\n        this.joinedAt = data.joined_at !== undefined ? Date.parse(data.joined_at) : this.joinedAt;\n\n        if(data.mute !== undefined) {\n            this.voiceState.update(data);\n        }\n\n        this.nick = data.nick !== undefined ? data.nick : this.nick || null;\n        if(data.roles !== undefined) {\n            this.roles = data.roles;\n        }\n    }\n\n    get permission() {\n        if(this.id === this.guild.ownerID) {\n            return new Permission(Permissions.all);\n        } else {\n            var permissions = this.guild.roles.get(this.guild.id).permissions.allow;\n            for(var role of this.roles) {\n                role = this.guild.roles.get(role);\n                if(!role) {\n                    continue;\n                }\n\n                var perm = role.permissions.allow;\n                if(perm & Permissions.administrator) {\n                    permissions = Permissions.all;\n                    break;\n                } else {\n                    permissions |= perm;\n                }\n            }\n            return new Permission(permissions);\n        }\n    }\n\n    get username() {\n        return this.user.username;\n    }\n\n    get discriminator() {\n        return this.user.discriminator;\n    }\n\n    get avatar() {\n        return this.user.avatar;\n    }\n\n    get bot() {\n        return this.user.bot;\n    }\n\n    get createdAt() {\n        return this.user.createdAt;\n    }\n\n    get defaultAvatar() {\n        return this.user.defaultAvatar;\n    }\n\n    get defaultAvatarURL() {\n        return this.user.defaultAvatarURL;\n    }\n\n    get staticAvatarURL(){\n        return this.user.staticAvatarURL;\n    }\n\n    get avatarURL() {\n        return this.user.avatarURL;\n    }\n\n    get mention() {\n        return `<@!${this.id}>`;\n    }\n\n    /**\n    * Edit the guild member\n    * @arg {Object} options The properties to edit\n    * @arg {String[]} [options.roles] The array of role IDs the user should have\n    * @arg {String} [options.nick] Set the user's server nickname, \"\" to remove\n    * @arg {Boolean} [options.mute] Server mute the user\n    * @arg {Boolean} [options.deaf] Server deafen the user\n    * @arg {String} [options.channelID] The ID of the voice channel to move the user to (must be in voice)\n    * @returns {Promise}\n    */\n    edit(options) {\n        return this.guild.shard.client.editGuildMember.call(this.guild.shard.client, this.guild.id, this.id, options);\n    }\n\n    /**\n    * Add a role to the guild member\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    addRole(roleID) {\n        return this.guild.shard.client.addGuildMemberRole.call(this.guild.shard.client, this.guild.id, this.id, roleID);\n    }\n\n    /**\n    * Remve a role from the guild member\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    removeRole(roleID) {\n        return this.guild.shard.client.removeGuildMemberRole.call(this.guild.shard.client, this.guild.id, this.id, roleID);\n    }\n\n    /**\n    * Kick the member from the guild\n    * @returns {Promise}\n    */\n    kick() {\n        return this.guild.shard.client.kickGuildMember.call(this.guild.shard.client, this.guild.id, this.id);\n    }\n\n    /**\n    * Ban the user from the guild\n    * @arg {Number} [deleteMessageDays=0] Number of days to delete messages for\n    * @returns {Promise}\n    */\n    ban(deleteMessageDays) {\n        return this.guild.shard.client.banGuildMember.call(this.guild.shard.client, this.guild.id, this.id, deleteMessageDays);\n    }\n\n    /**\n    * Unban the user from the guild\n    * @returns {Promise}\n    */\n    unban() {\n        return this.guild.shard.client.unbanGuildMember.call(this.guild.shard.client, this.guild.id, this.id);\n    }\n}\n\nmodule.exports = Member;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Permission.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst Permissions = require(\"../Constants\").Permissions;\n\n/**\n* Represents a calculated permissions number\n* @prop {Number} allow The allowed permissions number\n* @prop {Number} deny The denied permissions number\n* @prop {Object} json A JSON representation of the permissions number.\n* If a permission key isn't there, it is not set by this permission.\n* If a permission key is false, it is denied by the permission.\n* If a permission key is true, it is allowed by the permission.\n* i.e.:\n* {\n*   \"readMessages\": true,\n*   \"sendMessages\": true,\n*   \"manageMessages\": false\n* }\n* In the above example, readMessages and sendMessages are allowed permissions, and manageMessages is denied. Everything else is not explicitly set.\n* [A full list of permission nodes can be found on the docs reference page](/Eris/docs/reference)\n*/\nclass Permission extends Base {\n    constructor(allow, deny) {\n        super();\n        this.allow = allow;\n        this.deny = deny || 0;\n    }\n\n    get json() {\n        if(!this._json) {\n            this._json = {};\n            for(var perm of Object.keys(Permissions)) {\n                if(!perm.startsWith(\"all\")) {\n                    if(this.allow & Permissions[perm]) {\n                        this._json[perm] = true;\n                    } else if(this.deny & Permissions[perm]) {\n                        this._json[perm] = false;\n                    }\n                }\n            }\n        }\n        return this._json;\n    }\n\n    /**\n    * Check if this permission allows a specific permission\n    * @arg {String} permission The name of the permission. [A full list of permission nodes can be found on the docs reference page](/Eris/docs/reference)\n    * @returns {Boolean} Whether the permission allows the specified permission\n    */\n    has(permission) {\n        return !!(this.allow & Permissions[permission]);\n    }\n}\n\nmodule.exports = Permission;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/Constants.js":"\"use strict\";\n\nmodule.exports.DefaultAvatarHashes = [\n    \"6debd47ed13483642cf09e832ed0bc1b\",\n    \"322c936a8c8be1b803cd94861bdfa868\",\n    \"dd4dbc0016779df1378e7812eabaa04d\",\n    \"0e291f67c9274a1abdddeb3fd919cbaa\",\n    \"1cbd08c76f8af6dddce02c5138971129\"\n];\n\nmodule.exports.ImageFormats = [\n    \"jpg\",\n    \"png\",\n    \"webp\",\n    \"gif\"\n];\n\nmodule.exports.ImageSizes = [\n    128,\n    256,\n    512,\n    1024,\n    2048\n];\n\nmodule.exports.GatewayOPCodes = {\n    EVENT:              0,\n    HEARTBEAT:          1,\n    IDENTIFY:           2,\n    STATUS_UPDATE:      3,\n    VOICE_STATE_UPDATE: 4,\n    VOICE_SERVER_PING:  5,\n    RESUME:             6,\n    RECONNECT:          7,\n    GET_GUILD_MEMBERS:  8,\n    INVALID_SESSION:    9,\n    HELLO:             10,\n    HEARTBEAT_ACK:     11,\n    SYNC_GUILD:        12,\n    SYNC_CALL:         13\n};\n\nmodule.exports.GATEWAY_VERSION = 6;\n\nmodule.exports.Permissions = {\n    createInstantInvite: 1,\n    kickMembers:         1 << 1,\n    banMembers:          1 << 2,\n    administrator:       1 << 3,\n    manageChannels:      1 << 4,\n    manageGuild:         1 << 5,\n    addReactions:        1 << 6,\n    readMessages:        1 << 10,\n    sendMessages:        1 << 11,\n    sendTTSMessages:     1 << 12,\n    manageMessages:      1 << 13,\n    embedLinks:          1 << 14,\n    attachFiles:         1 << 15,\n    readMessageHistory:  1 << 16,\n    mentionEveryone:     1 << 17,\n    externalEmojis:      1 << 18,\n    voiceConnect:        1 << 20,\n    voiceSpeak:          1 << 21,\n    voiceMuteMembers:    1 << 22,\n    voiceDeafenMembers:  1 << 23,\n    voiceMoveMembers:    1 << 24,\n    voiceUseVAD:         1 << 25,\n    changeNickname:      1 << 26,\n    manageNicknames:     1 << 27,\n    manageRoles:         1 << 28,\n    manageWebhooks:      1 << 29,\n    manageEmojis:        1 << 30,\n    all:      0b1111111111101111111110000111111,\n    allGuild: 0b1111100000000000000000000111111,\n    allText:  0b0110000000001111111110000010001,\n    allVoice: 0b0110011111100000000000000010001\n};\n\nmodule.exports.VoiceOPCodes = {\n    IDENTIFY:            0,\n    SELECT_PROTOCOL:     1,\n    HELLO:               2,\n    HEARTBEAT:           3,\n    SESSION_DESCRIPTION: 4,\n    SPEAKING:            5\n};\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/VoiceState.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\n\n/**\n* Represents a member's voice state in a call/guild\n* @prop {String} id The ID of the member\n* @prop {String?} sessionID The ID of the member's current voice session\n* @prop {String?} channelID The ID of the member's current voice channel\n* @prop {Boolean} mute Whether the member is server muted or not\n* @prop {Boolean} deaf Whether the member is server deafened or not\n* @prop {Boolean} suppress Whether the member is suppressed or not\n* @prop {Boolean} selfMute Whether the member is self muted or not\n* @prop {Boolean} selfDeaf Whether the member is self deafened or not\n*/\nclass VoiceState extends Base {\n    constructor(data) {\n        super(data.id);\n        this.update(data);\n    }\n\n    update(data) {\n        if(data.channel_id !== undefined) {\n            this.channelID = data.channel_id;\n            this.sessionID = data.channel_id === null ? null : data.session_id;\n        } else if(this.channelID === undefined) {\n            this.channelID = this.sessionID = null;\n        }\n        this.mute = data.mute !== undefined ? data.mute : this.mute || false;\n        this.deaf = data.deaf !== undefined ? data.deaf : this.deaf || false;\n        this.suppress = data.suppress !== undefined ? data.suppress : this.suppress || false; // Bots ignore this\n        this.selfMute = data.self_mute !== undefined ? data.self_mute : this.selfMute || false;\n        this.selfDeaf = data.self_deaf !== undefined ? data.self_deaf : this.selfDeaf || false;\n    }\n}\n\nmodule.exports = VoiceState;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Message.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst Call = require(\"./Call\");\nconst User = require(\"./User\");\n\n/**\n* Represents a message\n* @prop {String} id The ID of the message\n* @prop {Channel} channel The channel the message is in\n* @prop {Guild?} guild The guild the message channel is in. Alias to channel.guild\n* @prop {Number} timestamp Timestamp of message creation\n* @prop {User} author The message author\n* @prop {Member?} member The message author with server-specific data\n* @prop {User[]} mentions Array of mentioned users\n* @prop {String} content Message content\n* @prop {String?} cleanContent Message content with mentions replaced by names, and @everyone/@here escaped\n* @prop {String[]} roleMentions Array of mentioned roles' ids\n* @prop {String[]?} channelMentions Array of mentions channels' ids\n* @prop {Number?} editedTimestamp Timestamp of latest message edit\n* @prop {Boolean} tts Whether to play the message using TTS or not\n* @prop {Boolean} mentionEveryone Whether the message mentions everyone/here or not\n* @prop {Object[]} attachments Array of attachments\n* @prop {Object[]} embeds Array of embeds\n* @prop {Object} reactions An object containing the reactions on the message\n* @prop {Number} reactions.count The number of times the reaction was used\n* @prop {Boolean} reactions.me Whether or not the bot user did the reaction\n* @prop {Boolean} command True if message is a command, false if not (CommandClient only)\n*/\nclass Message extends Base {\n    constructor(data, client) {\n        super(data.id);\n        this._client = client;\n        this.type = data.type;\n        this.timestamp = Date.parse(data.timestamp);\n        this.channel = client.getChannel(data.channel_id) || {\n            id: data.channel_id\n        };\n        this.content = \"\";\n        this.hit = !!data.hit;\n        this.reactions = {};\n        if(data.author) {\n            if(data.author.discriminator !== \"0000\") {\n                this.author = client.users.add(data.author);\n            } else {\n                this.author = new User(data.author, client);\n            }\n        } else if(data.timestamp) {\n            this._client.emit(\"warn\", \"MESSAGE_CREATE but no message author:\\n\" + JSON.stringify(data, null, 2));\n        }\n        if(this.type === 0 || this.type === undefined);\n        else if(this.type === 1) {\n            data.content = `${this.author.mention} added <@${data.mentions[0].id}>.`;\n        } else if(this.type === 2) {\n            if(this.author.id === data.mentions[0].id) {\n                data.content = `@${this.author.username} left the group.`;\n            } else {\n                data.content = `${this.author.mention} removed @${data.mentions[0].username}.`;\n            }\n        } else if(this.type === 3) { // ( \n            if(data.call.ended_timestamp) {\n                if((!this.channel.lastCall || this.channel.lastCall.endedTimestamp < Date.parse(data.call.ended_timestamp))) {\n                    data.call.id = this.id;\n                    this.channel.lastCall = new Call(data.call, this.channel);\n                }\n                if(~data.call.participants.indexOf(client.user.id)) {\n                    data.content = `You missed a call from ${this.author.mention}.`;\n                } else {\n                    data.content = `${this.author.mention} started a call.`;\n                }\n            } else {\n                if(!this.channel.call) {\n                    data.call.id = this.id;\n                    this.channel.call = new Call(data.call, this.channel);\n                }\n                data.content = `${this.author.mention} started a call.  Join the call.`;\n            }\n        } else if(this.type === 4) {\n            data.content = `${this.author.mention} changed the channel name: ${data.content}`;\n        } else if(this.type === 5) {\n            data.content = `${this.author.mention} changed the channel icon.`;\n        } else if(this.type === 6) {\n            data.content = `${this.author.mention} pinned a message to this channel. See all the pins.`;\n        } else {\n            throw new Error(\"Unhandled MESSAGE_CREATE type: \" + JSON.stringify(data, null, 2));\n        }\n\n        this.update(data, client);\n    }\n\n    update(data, client) {\n        if(this.type === 3) { // ( \n            (this.channel.call || this.channel.lastCall).update(data.call);\n        }\n        if(data.content !== undefined) {\n            this.content = data.content || \"\";\n            this._cleanContent = null;\n            this.mentionEveryone = !!data.mention_everyone;\n\n            this.mentions = data.mentions.map((mention) => client.users.add(mention, client));\n\n            this.roleMentions = data.mention_roles;\n        }\n\n        this.pinned = data.pinned !== undefined ? !!data.pinned : this.pinned;\n        this.editedTimestamp = data.edited_timestamp !== undefined ? Date.parse(data.edited_timestamp) : this.editedTimestamp;\n        this.tts = data.tts !== undefined ? data.tts : this.tts;\n        this.attachments = data.attachments !== undefined ? data.attachments : this.attachments; // TODO parse attachments\n        this.embeds = data.embeds !== undefined ? data.embeds : this.embeds; // TODO parse embeds\n\n        if(data.reactions) {\n            data.reactions.forEach((reaction) => {\n                this.reactions[reaction.emoji.id ? `${reaction.emoji.name}:${reaction.emoji.id}` : reaction.emoji.name] = {\n                    count: reaction.count,\n                    me: reaction.me\n                };\n            });\n        }\n    }\n\n    get cleanContent() {\n        if(this._cleanContent) {\n            return this._cleanContent;\n        }\n\n        this._cleanContent = this.content;\n\n        if(this.mentions) {\n            this.mentions.forEach((mention) => {\n                if(this.channel.guild) {\n                    var member = this.channel.guild.members.get(mention.id);\n                    if(member) {\n                        this._cleanContent = this._cleanContent.replace(new RegExp(`<@\\!${mention.id}>`, \"g\"), \"@\" + member.nick || mention.username);\n                    }\n                }\n                this._cleanContent = this._cleanContent.replace(new RegExp(`<@\\!?${mention.id}>`, \"g\"), \"@\" + mention.username);\n            });\n        }\n\n        if(this.channel.guild && this.roleMentions) {\n            for(var roleID of this.roleMentions) {\n                this._cleanContent = this._cleanContent.replace(new RegExp(`<@&${roleID}>`, \"g\"), \"@\" + this.channel.guild.roles.get(roleID).name);\n            }\n        }\n\n        this.channelMentions.forEach((id) => {\n            var channel = this._client.getChannel(id);\n            if(channel && channel.name && channel.mention) {\n                this._cleanContent = this._cleanContent.replace(channel.mention, \"#\" + channel.name);\n            }\n        });\n\n        return (this._cleanContent = this._cleanContent.replace(/@everyone/g, \"@\\u200beveryone\").replace(/@here/g, \"@\\u200bhere\"));\n    }\n\n    get channelMentions() {\n        if(this._channelMentions) {\n            return this._channelMentions;\n        }\n\n        return (this._channelMentions = (this.content.match(/<#[0-9]+>/g) || []).map((mention) => mention.substring(2, mention.length - 1)));\n    }\n\n    get member() {\n        return this.channel.guild && this.author && this.channel.guild.members.get(this.author.id) || null;\n    }\n\n    /**\n    * Edit the message\n    * @arg {String | Array | Object} content A string, array of strings, or object. If an object is passed:\n    * @arg {String} content.content A content string\n    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)\n    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers/docs/resources/channel#embed-object) for object structure\n    * @returns {Promise<Message>}\n    */\n    edit(content) {\n        return this._client.editMessage.call(this._client, this.channel.id, this.id, content);\n    }\n\n    /**\n    * Pin the message\n    * @returns {Promise}\n    */\n    pin() {\n        return this._client.pinMessage.call(this._client, this.channel.id, this.id);\n    }\n\n    /**\n    * Unpin the message\n    * @returns {Promise}\n    */\n    unpin() {\n        return this._client.unpinMessage.call(this._client, this.channel.id, this.id);\n    }\n\n    /**\n    * Get a list of users who reacted with a specific reaction\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {Number} [limit=100] The maximum number of users to get\n    * @returns {Promise<User[]>}\n    */\n    getReaction(reaction, limit) {\n        return this._client.getMessageReaction.call(this._client, this.channel.id, this.id, reaction, limit);\n    }\n\n    /**\n    * Add a reaction to a message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {String} [userID=\"@me\"] The ID of the user to react as\n    * @returns {Promise}\n    */\n    addReaction(reaction, userID) {\n        return this._client.addMessageReaction.call(this._client, this.channel.id, this.id, reaction, userID);\n    }\n\n    /**\n    * Remove a reaction from a message\n    * @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)\n    * @arg {String} [userID=\"@me\"] The ID of the user to remove the reaction for\n    * @returns {Promise}\n    */\n    removeReaction(reaction, userID) {\n        return this._client.removeMessageReaction.call(this._client, this.channel.id, this.id, reaction, userID);\n    }\n\n    /**\n    * Remove all reactions from a message\n    * @returns {Promise}\n    */\n    removeReactions() {\n        return this._client.removeMessageReactions.call(this._client, this.channel.id, this.id);\n    }\n\n    /**\n    * Delete the message\n    * @returns {Promise}\n    */\n    delete() {\n        return this._client.deleteMessage.call(this._client, this.channel.id, this.id);\n    }\n}\n\nmodule.exports = Message;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Call.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst Collection = require(\"../util/Collection\");\nconst VoiceState = require(\"./VoiceState\");\n\n/**\n* Represents a call\n* @prop {String} id The ID of the call\n* @prop {Number} createdAt Timestamp of the call's creation\n* @prop {GroupChannel} channel The call channel\n* @prop {Collection<VoiceState>} voiceStates The voice states of the call participants\n* @prop {String[]} participants The IDs of the call participants\n* @prop {Number?} endedTimestamp The timestamp of the call end\n* @prop {String[]?} ringing The IDs of people that still have not responded to the call request\n* @prop {String?} region The region of the call server\n* @prop {Boolean} unavailable Whether the call is unavailable or not\n*/\nclass Call extends Base {\n    constructor(data, channel) {\n        super(data.id);\n        this.channel = channel;\n        this.voiceStates = new Collection(VoiceState);\n        this.ringing = [];\n        this.update(data);\n    }\n\n    update(data) {\n        this.participants = data.participants !== undefined ? data.participants : this.participants || [];\n        if(data.ringing !== undefined) {\n            if(!~this.ringing.indexOf(this.channel._client.user.id) && ~(this.ringing = data.ringing).indexOf(this.channel._client.user.id)) {\n                /**\n                * Fired when the bot user is rung in a call\n                * @event Client#callRing\n                * @prop {Call} call The call\n                */\n                this.channel._client.emit(\"callRing\", this);\n            }\n        }\n        this.region = data.region !== undefined ? data.region : this.region || null;\n        this.endedTimestamp = data.ended_timestamp !== undefined ? Date.parse(data.ended_timestamp) : this.endedTimestamp || null;\n        this.unavailable = data.unavailable !== undefined ? data.unavailable : this.unavailable !== undefined ? this.unavailable : true;\n        if(data.voice_states) {\n            data.voice_states.forEach((voiceState) => {\n                voiceState.id = voiceState.user_id;\n                this.voiceStates.add(voiceState);\n            });\n        }\n    }\n}\n\nmodule.exports = Call;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/User.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst CDN_URL = require(\"../rest/Endpoints\").CDN_URL;\nconst DefaultAvatarHashes = require(\"../Constants\").DefaultAvatarHashes;\nconst Constants = require(\"../Constants\");\n\n/**\n* Represents a user\n* @prop {String} id The ID of the user\n* @prop {Number} createdAt Timestamp of the user's creation\n* @prop {String} mention A string that mentions the user\n* @prop {String} defaultAvatar The hash for the default avatar of a user if there is no avatar set\n* @prop {Number} createdAt Timestamp of user creation\n* @prop {Boolean} bot Whether the user is an OAuth bot or not\n* @prop {String} username The username of the user\n* @prop {String} discriminator The discriminator of the user\n* @prop {String?} avatar The hash of the user's avatar, or null if no avatar\n* @prop {String} defaultAvatarURL The URL of the user's default avatar\n* @prop {String} avatarURL The URL of the user's avatar which can be either a JPG or GIF\n* @prop {String} staticAvatarURL The URL of the user's avatar (always a JPG)\n*/\nclass User extends Base {\n    constructor(data, client) {\n        super(data.id);\n        this._client = client;\n        this.bot = !!data.bot;\n        this.update(data);\n    }\n\n    update(data) {\n        this.avatar = data.avatar !== undefined ? data.avatar : this.avatar;\n        this.username = data.username !== undefined ? data.username : this.username;\n        this.discriminator = data.discriminator !== undefined ? data.discriminator : this.discriminator;\n    }\n\n    get mention() {\n        return `<@${this.id}>`;\n    }\n\n    get defaultAvatar() {\n        return DefaultAvatarHashes[this.discriminator % DefaultAvatarHashes.length];\n    }\n\n    get defaultAvatarURL() {\n        return `https://discordapp.com/assets/${this.defaultAvatar}.png`;\n    }\n\n    get staticAvatarURL(){\n        return this.avatar ? `${CDN_URL}/avatars/${this.id}/${this.avatar}.${this._client.options.defaultImageFormat}?size=${this._client.options.defaultImageSize}` : this.defaultAvatarURL;\n    }\n\n    get avatarURL() {\n        return this.avatar ? `${CDN_URL}/avatars/${this.id}/${this.avatar}.${this.avatar.startsWith(\"a_\") ? \"gif\" : this._client.options.defaultImageFormat}?size=${this._client.options.defaultImageSize}` : this.defaultAvatarURL;\n    }\n\n    /**\n    * Get the user's avatar with the given format and size\n    * @arg {String} [format] The filetype of the avatar (\"jpg\", \"png\", \"gif\", or \"webp\")\n    * @arg {Number} [size] The size of the avatar (128, 256, 512, 1024, 2048)\n    */\n    dynamicAvatarURL(format, size) {\n        if(format === undefined || !~Constants.ImageFormats.indexOf(format.toLowerCase())) {\n            format = this.avatar.startsWith(\"a_\") ? \"gif\" : this._client.options.defaultImageFormat;\n        }\n        if(size === undefined || !~Constants.ImageSizes.indexOf(size)) {\n            size = this._client.options.defaultImageSize;\n        }\n        return this.avatar ? `${CDN_URL}/avatars/${this.id}/${this.avatar}.${format}?size=${size}` : this.defaultAvatarURL;\n    }\n\n    /**\n    * Get a DM channel with the user, or create one if it does not exist\n    * @returns {Promise<PrivateChannel>}\n    */\n    getDMChannel() {\n        return this._client.getDMChannel.call(this._client, this.id);\n    }\n\n    /**\n    * Create a relationship with the user\n    * @arg {Boolean} [block=false] If true, block the user. Otherwise, add the user as a friend\n    * @returns {Promise}\n    */\n    addRelationship(block) {\n        return this._client.addRelationship.call(this._client, this.id, block);\n    }\n\n    /**\n    * Remove a relationship with the user\n    * @returns {Promise}\n    */\n    removeRelationship() {\n        return this._client.removeRelationship.call(this._client, this.id);\n    }\n\n    /**\n    * Get profile data for the user (user accounts only)\n    * @returns {Promise<Object>} The user's profile data.\n    */\n    getProfile() {\n        return this._client.getUserProfile.call(this._client, this.id);\n    }\n}\n\nmodule.exports = User;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/rest/Endpoints.js":"\"use strict\";\n\nconst Constants = require(\"../Constants\");\n\nmodule.exports.BASE_URL = \"/api/v\" + Constants.GATEWAY_VERSION;\nmodule.exports.CDN_URL = \"https://cdn.discordapp.com\";\n\nmodule.exports.CHANNEL =                                                (chanID) => `/channels/${chanID}`;\nmodule.exports.CHANNEL_BULK_DELETE =                                    (chanID) => `/channels/${chanID}/messages/bulk_delete`;\nmodule.exports.CHANNEL_CALL_RING =                                      (chanID) => `/channels/${chanID}/call/ring`;\nmodule.exports.CHANNEL_INVITES =                                        (chanID) => `/channels/${chanID}/invites`;\nmodule.exports.CHANNEL_MESSAGE_REACTION =              (chanID, msgID, reaction) => `/channels/${chanID}/messages/${msgID}/reactions/${reaction}`;\nmodule.exports.CHANNEL_MESSAGE_REACTION_USER = (chanID, msgID, reaction, userID) => `/channels/${chanID}/messages/${msgID}/reactions/${reaction}/${userID}`;\nmodule.exports.CHANNEL_MESSAGE_REACTIONS =                       (chanID, msgID) => `/channels/${chanID}/messages/${msgID}/reactions`;\nmodule.exports.CHANNEL_MESSAGE =                                 (chanID, msgID) => `/channels/${chanID}/messages/${msgID}`;\nmodule.exports.CHANNEL_MESSAGES =                                       (chanID) => `/channels/${chanID}/messages`;\nmodule.exports.CHANNEL_MESSAGES_SEARCH =                                (chanID) => `/channels/${chanID}/messages/search`;\nmodule.exports.CHANNEL_PERMISSION =                             (chanID, overID) => `/channels/${chanID}/permissions/${overID}`;\nmodule.exports.CHANNEL_PERMISSIONS =                                    (chanID) => `/channels/${chanID}/permissions`;\nmodule.exports.CHANNEL_PIN =                                     (chanID, msgID) => `/channels/${chanID}/pins/${msgID}`;\nmodule.exports.CHANNEL_PINS =                                           (chanID) => `/channels/${chanID}/pins`;\nmodule.exports.CHANNEL_RECIPIENT =                             (groupID, userID) => `/channels/${groupID}/recipients/${userID}`;\nmodule.exports.CHANNEL_TYPING =                                         (chanID) => `/channels/${chanID}/typing`;\nmodule.exports.CHANNEL_WEBHOOKS =                                       (chanID) => `/channels/${chanID}/webhooks`;\nmodule.exports.CHANNELS =                                                           \"/channels\";\nmodule.exports.GATEWAY =                                                            \"/gateway\";\nmodule.exports.GATEWAY_BOT =                                                        \"/gateway/bot\";\nmodule.exports.GUILD =                                                 (guildID) => `/guilds/${guildID}`;\nmodule.exports.GUILD_BAN =                                   (guildID, memberID) => `/guilds/${guildID}/bans/${memberID}`;\nmodule.exports.GUILD_BANS =                                            (guildID) => `/guilds/${guildID}/bans`;\nmodule.exports.GUILD_CHANNELS =                                        (guildID) => `/guilds/${guildID}/channels`;\nmodule.exports.GUILD_EMBED =                                           (guildID) => `/guilds/${guildID}/embed`;\nmodule.exports.GUILD_EMOJI =                                  (guildID, emojiID) => `/guilds/${guildID}/emojis/${emojiID}`;\nmodule.exports.GUILD_EMOJIS =                                          (guildID) => `/guilds/${guildID}/emojis`;\nmodule.exports.GUILD_INTEGRATION =                             (guildID, inteID) => `/guilds/${guildID}/integrations/${inteID}`;\nmodule.exports.GUILD_INTEGRATION_SYNC =                        (guildID, inteID) => `/guilds/${guildID}/integrations/${inteID}/sync`;\nmodule.exports.GUILD_INTEGRATIONS =                                    (guildID) => `/guilds/${guildID}/integrations`;\nmodule.exports.GUILD_INVITES =                                         (guildID) => `/guilds/${guildID}/invites`;\nmodule.exports.GUILD_MEMBER =                                (guildID, memberID) => `/guilds/${guildID}/members/${memberID}`;\nmodule.exports.GUILD_MEMBER_NICK =                           (guildID, memberID) => `/guilds/${guildID}/members/${memberID}/nick`;\nmodule.exports.GUILD_MEMBER_ROLE =                   (guildID, memberID, roleID) => `/guilds/${guildID}/members/${memberID}/roles/${roleID}`;\nmodule.exports.GUILD_MEMBERS =                                         (guildID) => `/guilds/${guildID}/members`;\nmodule.exports.GUILD_MESSAGES_SEARCH =                                 (guildID) => `/guilds/${guildID}/messages/search`;\nmodule.exports.GUILD_PRUNE =                                           (guildID) => `/guilds/${guildID}/prune`;\nmodule.exports.GUILD_ROLE =                                    (guildID, roleID) => `/guilds/${guildID}/roles/${roleID}`;\nmodule.exports.GUILD_ROLES =                                           (guildID) => `/guilds/${guildID}/roles`;\nmodule.exports.GUILD_VOICE_REGIONS =                                   (guildID) => `/guilds/${guildID}/regions`;\nmodule.exports.GUILD_WEBHOOKS =                                        (guildID) => `/guilds/${guildID}/webhooks`;\nmodule.exports.GUILDS =                                                             \"/guilds\";\nmodule.exports.INVITE =                                               (inviteID) => `/invite/${inviteID}`;\nmodule.exports.OAUTH2_APPLICATION =                                      (appID) => `/oauth2/applications/${appID}`;\nmodule.exports.USER =                                                   (userID) => `/users/${userID}`;\nmodule.exports.USER_CHANNELS =                                          (userID) => `/users/${userID}/channels`;\nmodule.exports.USER_GUILD =                                    (userID, guildID) => `/users/${userID}/guilds/${guildID}`;\nmodule.exports.USER_GUILDS =                                            (userID) => `/users/${userID}/guilds`;\nmodule.exports.USER_NOTE =                                    (userID, targetID) => `/users/${userID}/note/${targetID}`;\nmodule.exports.USER_PROFILE =                                           (userID) => `/users/${userID}/profile`;\nmodule.exports.USER_RELATIONSHIP =                               (userID, relID) => `/users/${userID}/relationships/${relID}`;\nmodule.exports.USER_SETTINGS =                                          (userID) => `/users/${userID}/settings`;\nmodule.exports.USERS =                                                              \"/users\";\nmodule.exports.VOICE_REGIONS =                                                      \"/voice/regions\";\nmodule.exports.WEBHOOK =                                                (hookID) => `/webhooks/${hookID}`;\nmodule.exports.WEBHOOK_TOKEN =                                   (hookID, token) => `/webhooks/${hookID}/${token}`;\nmodule.exports.WEBHOOK_TOKEN_SLACK =                             (hookID, token) => `/webhooks/${hookID}/${token}/slack`;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/PermissionOverwrite.js":"\"use strict\";\n\nconst Permission = require(\"./Permission\");\n\n/**\n* Represents a permission overwrite\n* @extends Permission\n* @prop {String} id The ID of the overwrite\n* @prop {String} type The type of the overwrite, either \"user\" or \"role\"\n*/\nclass PermissionOverwrite extends Permission {\n    constructor(data) {\n        super(data.allow, data.deny);\n        this.id = data.id;\n        this.type = data.type;\n    }\n}\n\nmodule.exports = PermissionOverwrite;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/ExtendedUser.js":"\"use strict\";\n\nconst User = require(\"./User\");\n\n/**\n* Represents an extended user\n* @extends User\n* @prop {String} email The email of the user\n* @prop {Boolean} verified Whether the account email has been verified\n* @prop {Boolean} mfaEnabled Whether the user has enabled two-factor authentication\n*/\nclass ExtendedUser extends User {\n    constructor(data, client) {\n        super(data, client);\n        this.update(data);\n    }\n\n    update(data) {\n        super.update(data);\n        this.email = data.email !== undefined ? data.email : this.email;\n        this.verified = data.verified !== undefined ? data.verified : this.verified;\n        this.mfaEnabled = data.mfa_enabled !== undefined ? data.mfa_enabled : this.mfaEnabled;\n        this.premium = data.premium !== undefined ? data.premium : this.premium;\n    }\n}\n\nmodule.exports = ExtendedUser;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/GroupChannel.js":"\"use strict\";\n\nconst Collection = require(\"../util/Collection\");\nconst Endpoints = require(\"../rest/Endpoints\");\nconst PrivateChannel = require(\"./PrivateChannel\");\nconst User = require(\"./User\");\nconst Constants = require(\"../Constants\");\n\n/**\n* Represents a group channel. See PrivateChannel docs for additional properties.\n* @extends PrivateChannel\n* @prop {Call?} call The current group call, if any\n* @prop {Call?} lastCall The previous group call, if any\n* @prop {Collection<User>} recipients The recipients in this private channel\n* @prop {String} name The name of the group channel\n* @prop {String?} icon The hash of the group channel icon\n* @prop {String?} iconURL The URL of the group channel icon\n* @prop {String} ownerID The ID of the user that is the group owner\n*/\nclass GroupChannel extends PrivateChannel { // ( \n    constructor(data, client) {\n        super(data, client);\n        this.recipients = new Collection(User);\n        data.recipients.forEach((recipient) => {\n            this.recipients.add(client.options.restMode ? new User(recipient, client) : client.users.add(recipient, client));\n        });\n        this.update(data);\n    }\n\n    update(data) {\n        this.name = data.name !== undefined ? data.name : this.name;\n        this.ownerID = data.owner_id !== undefined ? data.owner_id : this.ownerID;\n        this.icon = data.icon !== undefined ? data.icon : this.icon;\n    }\n\n    /**\n    * Edit the channel's properties\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The name of the channel\n    * @arg {String} [options.icon] The icon of the channel as a base64 data URI (group channels only). Note: base64 strings alone are not base64 data URI strings\n    * @arg {String} [options.ownerID] The ID of the channel owner (group channels only)\n    * @returns {Promise<GroupChannel>}\n    */\n    edit(options) {\n        return this._client.editChannel.call(this._client, this.id, options);\n    }\n\n    /**\n    * Add a user to the group\n    * @arg {String} userID The ID of the target user\n    * @returns {Promise}\n    */\n    addRecipient(userID) {\n        return this._client.addGroupRecipient.call(this._client, this.id, userID);\n    }\n\n    /**\n    * Remove a user from the group\n    * @arg {String} userID The ID of the target user\n    * @returns {Promise}\n    */\n    removeRecipient(userID) {\n        return this._client.removeGroupRecipient.call(this._client, this.id, userID);\n    }\n\n    get iconURL() {\n        return this.icon ? `${Endpoints.CDN_URL}/channel-icons/${this.id}/${this.icon}.${this._client.options.defaultImageFormat}?size=${this._client.options.defaultImageSize}` : null;\n    }\n\n    /**\n    * Get the group's icon with the given format and size\n    * @arg {String} [format] The filetype of the icon (\"jpg\", \"png\", \"gif\", or \"webp\")\n    * @arg {Number} [size] The size of the icon (128, 256, 512, 1024, 2048)\n    */\n    dynamicIconURL(format, size) {\n        if(format === undefined || !~Constants.ImageFormats.indexOf(format.toLowerCase())) {\n            format = this._client.options.defaultImageFormat;\n        }\n        if(size === undefined || !~Constants.ImageSizes.indexOf(size)) {\n             size = this._client.options.defaultImageSize;\n        }\n        return this.icon ? `${Endpoints.CDN_URL}/channel-icons/${this.id}/${this.icon}.${format}?size=${size}` : null;\n     }\n}\n\nmodule.exports = GroupChannel;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/PrivateChannel.js":"\"use strict\";\n\nconst Channel = require(\"./Channel\");\nconst Collection = require(\"../util/Collection\");\nconst Endpoints = require(\"../rest/Endpoints\");\nconst Message = require(\"./Message\");\nconst OPCodes = require(\"../Constants\").GatewayOPCodes;\nconst User = require(\"./User\");\n\n/**\n* Represents a private channel\n* @extends Channel\n* @prop {String} lastMessageID The ID of the last message in this channel\n* @prop {User} recipient The recipient in this private channel (private channels only)\n* @prop {Collection<Message>} messages Collection of Messages in this channel\n*/\nclass PrivateChannel extends Channel {\n    constructor(data, client) {\n        super(data);\n        this._client = client;\n        this.lastMessageID = data.last_message_id;\n        this.call = this.lastCall = null;\n        if(this.type === 1 || this.type === undefined) {\n            this.recipient = new User(data.recipients[0], client);\n        }\n        this.messages = new Collection(Message, client.options.messageLimit);\n    }\n\n    /**\n    * Ring fellow group channel recipient(s)\n    * @arg {String[]} recipients The IDs of the recipients to ring\n    */\n    ring(recipients) {\n        this._client.requestHandler.request(\"POST\", Endpoints.CHANNEL_CALL_RING(this.id), true, {\n            recipients\n        });\n    }\n\n    /**\n    * Check if the channel has an existing call\n    */\n    syncCall() {\n        this._client.shards.values().next().value.sendWS(OPCodes.SYNC_CALL, {\n            channel_id: this.id\n        });\n    }\n\n    /**\n    * Leave the channel\n    * @returns {Promise}\n    */\n    leave() {\n        return this._client.deleteChannel.call(this._client, this.id);\n    }\n}\n\nmodule.exports = PrivateChannel;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Guild.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst CDN_URL = require(\"../rest/Endpoints\").CDN_URL;\nconst GuildChannel = require(\"./GuildChannel\");\nconst Collection = require(\"../util/Collection\");\nconst Member = require(\"./Member\");\nconst Role = require(\"./Role\");\nconst Constants = require(\"../Constants\");\n\n/**\n* Represents a guild\n* @prop {String} id The ID of the guild\n* @prop {Number} createdAt Timestamp of the guild's creation\n* @prop {String} name The name of the guild\n* @prop {Number} verificationLevel The guild verification level\n* @prop {String} region The region of the guild\n* @prop {GuildChannel} defaultChannel The default channel of the guild\n* @prop {String?} icon The hash of the guild icon, or null if no icon\n* @prop {String} afkChannelID The ID of the AFK voice channel\n* @prop {Number} afkTimeout The AFK timeout in seconds\n* @prop {Number} defaultNotifications The default notification settings for the guild. 0 is \"All Messages\", 1 is \"Only @mentions\"\n* @prop {Number} mfaLevel The admin 2FA level for the server. 0 is not required, 1 is required\n* @prop {Number} joinedAt Timestamp of when the bot account joined the guild\n* @prop {String} ownerID The ID of the user that is the guild owner\n* @prop {String?} splash The hash of the guild splash image, or null if no splash (VIP only)\n* @prop {Boolean} unavailable Whether the guild is unavailable or not\n* @prop {Boolean} large Whether the guild is \"large\" by \"some Discord standard\"\n* @prop {Number} maxPresences The maximum number of people that can be online in a guild at once (returned from REST API only)\n* @prop {Collection<GuildChannel>} channels Collection of Channels in the guild\n* @prop {Collection<Member>} members Collection of Members in the guild\n* @prop {Number} memberCount Number of members in the guild\n* @prop {Collection<Role>} roles Collection of Roles in the guild\n* @prop {Shard} shard The Shard that owns the guild\n* @prop {Object[]} features An array of guild feature objects\n* @prop {Object[]} emojis An array of guild emoji objects\n* @prop {String?} iconURL The URL of the guild's icon\n*/\nclass Guild extends Base {\n    constructor(data, client) {\n        super(data.id);\n        this.shard = client.shards.get(client.guildShardMap[this.id]);\n        this.unavailable = !!data.unavailable;\n        this.joinedAt = Date.parse(data.joined_at);\n        this.channels = new Collection(GuildChannel);\n        this.members = new Collection(Member);\n        this.memberCount = data.member_count;\n        this.roles = new Collection(Role);\n\n        for(var role of data.roles) {\n            this.roles.add(role, this);\n        }\n\n        if(data.channels) {\n            for(var channel of data.channels) {\n                channel = this.channels.add(channel, this);\n                client.channelGuildMap[channel.id] = this.id;\n            }\n\n            this.defaultChannel = this.channels.get(this.id);\n        }\n\n        if(data.members) {\n            for(var member of data.members) {\n                member.id = member.user.id;\n                this.members.add(member, this);\n            }\n        }\n\n        if(data.presences) {\n            for(var presence of data.presences) {\n                if(!this.members.get(presence.user.id)) {\n                    var userData = client.users.get(presence.user.id);\n                    if(userData) {\n                        userData = `{username: ${userData.username}, id: ${userData.id}, discriminator: ${userData.discriminator}}`;\n                    }\n                    client.emit(\"debug\", `Presence without member. ${presence.user.id}. In global user cache: ${userData}. ` + JSON.stringify(presence), this.shard.id);\n                    continue;\n                }\n                presence.id = presence.user.id;\n                this.members.update(presence);\n            }\n        }\n\n        if(data.voice_states) {\n            if(!client.bot) {\n                this.pendingVoiceStates = data.voice_states;\n            } else {\n                for(var voiceState of data.voice_states) {\n                    if(!this.members.get(voiceState.user_id)) {\n                        continue;\n                    }\n                    voiceState.id = voiceState.user_id;\n                    try {\n                        this.channels.get(voiceState.channel_id).voiceMembers.add(this.members.update(voiceState));\n                    } catch(err) {\n                        client.emit(\"error\", err, this.shard.id);\n                        continue;\n                    }\n                    if(client.options.seedVoiceConnections && voiceState.id === client.user.id && !client.voiceConnections.get(this.id)) {\n                        process.nextTick(() => this.shard.client.joinVoiceChannel(voiceState.channel_id, false));\n                    }\n                }\n            }\n        }\n        this.update(data);\n    }\n\n    update(data) {\n        this.name = data.name !== undefined ? data.name : this.name;\n        this.verificationLevel = data.verification_level !== undefined ? data.verification_level : this.verificationLevel;\n        this.splash = data.splash !== undefined ? data.splash : this.splash;\n        this.region = data.region !== undefined ? data.region : this.region;\n        this.ownerID = data.owner_id !== undefined ? data.owner_id : this.ownerID;\n        this.icon = data.icon !== undefined ? data.icon : this.icon;\n        this.features = data.features !== undefined ? data.features : this.features; // TODO parse features\n        this.emojis = data.emojis !== undefined ? data.emojis : this.emojis; // TODO parse emojis\n        this.afkChannelID = data.afk_channel_id !== undefined ? data.afk_channel_id : this.afkChannelID;\n        this.afkTimeout = data.afk_timeout !== undefined ? data.afk_timeout : this.afkTimeout;\n        this.defaultNotifications = data.default_message_notifications !== undefined ? data.default_message_notifications : this.defaultNotifications;\n        this.mfaLevel = data.mfa_level !== undefined ? data.mfa_level : this.mfaLevel;\n        this.large = data.large !== undefined ? data.large : this.large;\n        this.maxPresences = data.max_presences !== undefined ? data.max_presences : this.maxPresences;\n    }\n\n    /**\n    * Request all guild members from Discord\n    */\n    fetchAllMembers() {\n        this.shard.getGuildMembers(this.id, Math.ceil(this.memberCount / 1000)); // TODO Promise with chunk timeout\n    }\n\n    get iconURL() {\n        return this.icon ? `${CDN_URL}/icons/${this.id}/${this.icon}.${this.shard.client.options.defaultImageFormat}?size=${this.shard.client.options.defaultImageSize}` : null;\n    }\n\n    /**\n    * Get the guild's icon with the given format and size\n    * @arg {String} [format] The filetype of the icon (\"jpg\", \"png\", \"gif\", or \"webp\")\n    * @arg {Number} [size] The size of the icon (128, 256, 512, 1024, 2048)\n    */\n    dynamicIconURL(format, size) {\n        if(format === undefined || !~Constants.ImageFormats.indexOf(format.toLowerCase())) {\n            format = this._client.options.defaultImageFormat;\n        }\n        if(size === undefined || !~Constants.ImageSizes.indexOf(size)) {\n             size = this._client.options.defaultImageSize;\n        }\n        return this.icon ? `${CDN_URL}/icons/${this.id}/${this.icon}.${format}?size=${size}` : null;\n    }\n\n    get splashURL() {\n        return this.splash ? `${CDN_URL}/splashes/${this.id}/${this.splash}.jpg` : null;\n    }\n\n    /**\n    * Create a channel in the guild\n    * @arg {String} name The name of the channel\n    * @arg {String} [type=0] The type of the channel, either 0 or 2\n    * @returns {Promise<GuildChannel>}\n    */\n    createChannel(name, type) {\n        return this.shard.client.createChannel.call(this.shard.client, this.id, name, type);\n    }\n\n    /**\n    * Create a emoji in the guild (not for bot accounts)\n    * @arg {Object} options Emoji options\n    * @arg {String} options.name The name of emoji\n    * @arg {String} options.image The base 64 encoded string\n    * @arg {Array} [options.roles] An array containing authorized role IDs\n    * @returns {Promise<Object>} A guild emoji object\n    */\n    createEmoji(options) {\n        return this.shard.client.createGuildEmoji.call(this.shard.client, this.id, options);\n    }\n\n    /**\n    * Edit a emoji in the guild (not for bot accounts)\n    * @arg {String} emojiID The ID of the emoji you want to modify\n    * @arg {Object} options Emoji options\n    * @arg {String} [options.name] The name of emoji\n    * @arg {Array} [options.roles] An array containing authorized role IDs\n    * @returns {Promise<Object>} A guild emoji object\n    */\n    editEmoji(emojiID, options) {\n        return this.shard.client.editGuildEmoji.call(this.shard.client, this.id, emojiID, options);\n    }\n\n    /**\n    * Delete a emoji in the guild (not for bot accounts)\n    * @arg {String} emojiID The ID of the emoji\n    * @returns {Promise}\n    */\n    deleteEmoji(emojiID) {\n        return this.shard.client.deleteGuildEmoji.call(this.shard.client, this.id, emojiID);\n    }\n\n    /**\n    * Create a guild role\n    * @arg {Object} [options] The properties to set\n    * @arg {String} [options.name] The name of the role\n    * @arg {Number} [options.permissions] The role permissions number\n    * @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3d15b3 or 4040115)\n    * @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not\n    * @arg {Boolean} [options.mentionable] Whether the role is mentionable or not\n    * @returns {Promise<Role>}\n    */\n    createRole(options) {\n        return this.shard.client.createRole.call(this.shard.client, this.id, options);\n    }\n\n    /**\n    * Get the prune count for the guild\n    * @arg {Number} days The number of days of inactivity to prune for\n    * @returns {Promise<Number>} Resolves with the number of users that would be pruned\n    */\n    getPruneCount(days) {\n        return this.shard.client.getPruneCount.call(this.shard.client, this.id, days);\n    }\n\n    /**\n    * Begin pruning the guild\n    * @arg {Number} days The number of days of inactivity to prune for\n    * @returns {Promise<Number>} Resolves with the number of pruned users\n    */\n    pruneMembers(days) {\n        return this.shard.client.pruneMembers.call(this.shard.client, this.id, days);\n    }\n\n    /**\n    * Get a guild's channels via the REST API. REST mode is required to use this endpoint.\n    * @returns {Promise<GuildChannel[]>}\n    */\n    getRESTChannels() {\n        return this.shard.client.getRESTGuildChannels.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Get a guild's emojis via the REST API. REST mode is required to use this endpoint.\n    * @returns {Promise<Object[]>} An array of guild emoji objects\n    */\n    getRESTEmojis() {\n        return this.shard.client.getRESTGuildEmojis.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Get a guild emoji via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} emojiID The ID of the emoji\n    * @returns {Promise<Object>} An emoji object\n    */\n    getRESTEmoji(emojiID) {\n        return this.shard.client.getRESTGuildEmoji.call(this.shard.client, this.id, emojiID);\n    }\n\n    /**\n    * Get a guild's members via the REST API. REST mode is required to use this endpoint.\n    * @arg {Number} [limit=1] The max number of members to get (1 to 1000)\n    * @arg {String} [after] The highest user ID of the previous page\n    * @returns {Promise<Member[]>}\n    */\n    getRESTMembers(limit, after) {\n        return this.shard.client.getRESTGuildMembers.call(this.shard.client, this.id, limit, after);\n    }\n\n    /**\n    * Get a guild's members via the REST API. REST mode is required to use this endpoint.\n    * @arg {String} memberID The ID of the member\n    * @returns {Promise<Member>}\n    */\n    getRESTMember(memberID) {\n        return this.shard.client.getRESTGuildMember.call(this.shard.client, this.id, memberID);\n    }\n\n    /**\n    * Get a guild's roles via the REST API. REST mode is required to use this endpoint.\n    * @returns {Promise<Role[]>}\n    */\n    getRESTRoles() {\n        return this.shard.client.getRESTGuildRoles.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Get a guild's embed object\n    * @returns {Promise<Object>} A guild embed object\n    */\n    getEmbed() {\n        return this.shard.client.getGuildEmbed.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Get possible voice reigons for a guild\n    * @returns {Promise<Object[]>} Resolves with an array of voice region objects\n    */\n    getVoiceRegions() {\n        return this.shard.client.getVoiceRegions.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Edit the guild role\n    * @arg {String} roleID The ID of the role\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The name of the role\n    * @arg {Number} [options.permissions] The role permissions number\n    * @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3da5b3 or 4040115)\n    * @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not\n    * @arg {Boolean} [options.mentionable] Whether the role is mentionable or not\n    * @returns {Promise<Role>}\n    */\n    editRole(roleID, options) {\n        return this.shard.client.editRole.call(this.shard.client, this.id, roleID, options);\n    }\n\n    /**\n    * Delete a role\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    deleteRole(roleID) {\n        return this.shard.client.deleteRole.call(this.shard.client, this.id, roleID);\n    }\n\n    /**\n    * Get a list of integrations for the guild\n    * @returns {Promise<GuildIntegration[]>}\n    */\n    getIntegrations() {\n        return this.shard.client.getGuildIntegrations.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Edit a guild integration\n    * @arg {String} integrationID The ID of the integration\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.expireBehavior] What to do when a user's subscription runs out\n    * @arg {String} [options.expireGracePeriod] How long before the integration's role is removed from an unsubscribed user\n    * @arg {String} [options.enableEmoticons] Whether to enable integration emoticons or not\n    * @returns {Promise}\n    */\n    editIntegration(integrationID, options) {\n        return this.shard.client.editGuildIntegration.call(this.shard.client, this.id, integrationID, options);\n    }\n\n    /**\n    * Force a guild integration to sync\n    * @arg {String} integrationID The ID of the integration\n    * @returns {Promise}\n    */\n    syncIntegration(integrationID) {\n        return this.shard.client.syncGuildIntegration.call(this.shard.client, this.id, integrationID);\n    }\n\n    /**\n    * Delete a guild integration\n    * @arg {String} integrationID The ID of the integration\n    * @returns {Promise}\n    */\n    deleteIntegration(integrationID) {\n        return this.shard.client.deleteGuildIntegration.call(this.shard.client, this.id, integrationID);\n    }\n\n    /**\n    * Get all invites in the guild\n    * @returns {Promise<Invite[]>}\n    */\n    getInvites() {\n        return this.shard.client.getGuildInvites.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Edit a guild member\n    * @arg {String} memberID The ID of the member\n    * @arg {Object} options The properties to edit\n    * @arg {String[]} [options.roles] The array of role IDs the member should have\n    * @arg {String} [options.nick] Set the member's server nickname, \"\" to remove\n    * @arg {Boolean} [options.mute] Server mute the member\n    * @arg {Boolean} [options.deaf] Server deafen the member\n    * @arg {String} [options.channelID] The ID of the voice channel to move the member to (must be in voice)\n    * @returns {Promise}\n    */\n    editMember(memberID, options) {\n        return this.shard.client.editGuildMember.call(this.shard.client, this.id, memberID, options);\n    }\n\n    /**\n    * Add a role to a guild member\n    * @arg {String} memberID The ID of the member\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    addMemberRole(memberID, roleID) {\n        return this.shard.client.addGuildMemberRole.call(this.shard.client, this.id, memberID, roleID);\n    }\n\n    /**\n    * Remve a role from a guild member\n    * @arg {String} memberID The ID of the member\n    * @arg {String} roleID The ID of the role\n    * @returns {Promise}\n    */\n    removeMemberRole(memberID, roleID) {\n        return this.shard.client.removeGuildMemberRole.call(this.shard.client, this.id, memberID, roleID);\n    }\n\n    /**\n    * Kick a member from the guild\n    * @arg {String} userID The ID of the member\n    * @returns {Promise}\n    */\n    kickMember(userID) {\n        return this.shard.client.kickGuildMember.call(this.shard.client, this.id, userID);\n    }\n\n    /**\n    * Ban a user from the guild\n    * @arg {String} userID The ID of the member\n    * @arg {Number} [deleteMessageDays=0] Number of days to delete messages for\n    * @returns {Promise}\n    */\n    banMember(userID, deleteMessageDays) {\n        return this.shard.client.banGuildMember.call(this.shard.client, this.id, userID, deleteMessageDays);\n    }\n\n    /**\n    * Unban a user from the guild\n    * @arg {String} userID The ID of the member\n    * @returns {Promise}\n    */\n    unbanMember(userID) {\n        return this.shard.client.unbanGuildMember.call(this.shard.client, this.id, userID);\n    }\n\n    /**\n    * Edit the guild\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The ID of the guild\n    * @arg {String} [options.region] The region of the guild\n    * @arg {String} [options.icon] The guild icon as a base64 data URI. Note: base64 strings alone are not base64 data URI strings\n    * @arg {Number} [options.verificationLevel] The guild verification level\n    * @arg {Number} [options.defaultNotifications] The default notification settings for the guild. 0 is \"All Messages\", 1 is \"Only @mentions\".\n    * @arg {String} [options.afkChannelID] The ID of the AFK voice channel\n    * @arg {Number} [options.afkTimeout] The AFK timeout in seconds\n    * @arg {String} [options.ownerID] The ID of the member to transfer server ownership to (bot user must be owner)\n    * @arg {String} [options.splash] The guild splash image as a base64 data URI (VIP only). Note: base64 strings alone are not base64 data URI strings\n    * @returns {Promise<Guild>}\n    */\n    edit(options) {\n        return this.shard.client.editGuild.call(this.shard.client, this.id, options);\n    }\n\n    /**\n    * Delete the guild (bot user must be owner)\n    * @returns {Promise}\n    */\n    delete() {\n        return this.shard.client.deleteGuild.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Leave the guild\n    * @returns {Promise}\n    */\n    leave() {\n        return this.shard.client.leaveGuild.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Get the ban list of the guild\n    * @returns {Promise<User[]>}\n    */\n    getBans() {\n        return this.shard.client.getGuildBans.call(this.shard.client, this.id);\n    }\n\n    /**\n    * Edit the bot's nickname in the guild\n    * @arg {String} nick The nickname\n    * @returns {Promise}\n    */\n    editNickname(nick) {\n        return this.shard.client.editNickname.call(this.shard.client, this.id, nick);\n    }\n\n    /**\n    * Get all the webhooks in the guild\n    * @returns {Promise<Object[]>} Resolves with an array of webhook objects\n    */\n    getWebhooks() {\n        return this.shard.client.getGuildWebhooks.call(this.shard.client, this.id);\n    }\n}\n\nmodule.exports = Guild;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Role.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\nconst Permission = require(\"./Permission\");\n\n/**\n* Represents a role\n* @prop {String} id The ID of the role\n* @prop {Number} createdAt Timestamp of the role's creation\n* @prop {Guild} guild The guild that owns the role\n* @prop {String} mention A string that mentions the role\n* @prop {Number} createdAt Timestamp of role creation\n* @prop {String} name The name of the role\n* @prop {Boolean} mentionable Whether the role is mentionable or not\n* @prop {Boolean} managed Whether a guild integration manages this role or not\n* @prop {Boolean} hoist Whether users with this role are hoisted in the user list or not\n* @prop {Number} color The hex color of the role in base 10\n* @prop {Number} position The position of the role\n* @prop {Permission} permissions The permissions representation of the role\n*/\nclass Role extends Base {\n    constructor(data, guild) {\n        super(data.id);\n        this.guild = guild;\n        this.update(data);\n    }\n\n    update(data) {\n        this.name = data.name !== undefined ? data.name : this.name;\n        this.mentionable = data.mentionable !== undefined ? data.mentionable : this.mentionable;\n        this.managed = data.managed !== undefined ? data.managed : this.managed;\n        this.hoist = data.hoist !== undefined ? data.hoist : this.hoist;\n        this.color = data.color !== undefined ? data.color : this.color;\n        this.position = data.position !== undefined ? data.position : this.position;\n        this.permissions = data.permissions !== undefined ? new Permission(data.permissions) : this.permissions;\n    }\n\n    /**\n    * Generates a JSON representation of the role permissions\n    * @returns {Object}\n    */\n    get json() {\n        return this.permissions.json;\n    }\n\n    get mention() {\n        return `<@&${this.id}>`;\n    }\n\n    /**\n    * Edit the guild role\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.name] The name of the role\n    * @arg {Number} [options.permissions] The role permissions number\n    * @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3da5b3 or 4040115)\n    * @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not\n    * @arg {Boolean} [options.mentionable] Whether the role is mentionable or not\n    * @returns {Promise<Role>}\n    */\n    edit(options) {\n        return this.guild.shard.client.editRole.call(this.guild.shard.client, this.guild.id, this.id, options);\n    }\n\n    /**\n    * Edit the role's position. Note that role position numbers are highest on top and lowest at the bottom.\n    * @arg {Number} position The new position of the role\n    * @returns {Promise}\n    */\n    editPosition(position) {\n        return this.guild.shard.client.editRolePosition.call(this.guild.shard.client, this.guild.id, this.id, position);\n    }\n\n    /**\n    * Delete the role\n    * @returns {Promise}\n    */\n    delete() {\n        return this.guild.shard.client.deleteRole.call(this.guild.shard.client, this.guild.id, this.id);\n    }\n}\n\nmodule.exports = Role;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/GuildIntegration.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\n\n/**\n* Represents a guild integration\n* @prop {String} id The ID of the integration\n* @prop {Number} createdAt Timestamp of the guild integration's creation\n* @prop {String} name The name of the integration\n* @prop {String} type The type of the integration\n* @prop {String} roleID The ID of the role connected to the integration\n* @prop {User} user The user connected to the integration\n* @prop {Object} account Info on the integration account\n* @prop {String} account.id The ID of the integration account\n* @prop {String} account.name The name of the integration account\n* @prop {Boolean} enabled Whether the integration is enabled or not\n* @prop {Boolean} syncing Whether the integration is syncing or not\n* @prop {Number} expireBehavior behavior of expired subscriptions\n* @prop {Number} expireGracePeriod grace period for expired subscriptions\n* @prop {Boolean} enableEmoticons Whether integration emoticons are enabled or not\n* @prop {Number} subscriberCount number of subscribers\n* @prop {Number} syncedAt Unix timestamp of last integration sync\n*/\nclass GuildIntegration extends Base {\n    constructor(data, guild) {\n        super(data.id);\n        this.guild = guild;\n        this.name = data.name;\n        this.type = data.type;\n        this.roleID = data.role_id;\n        this.user = guild.shard.client.users.add(data.user, guild.shard.client);\n        this.account = data.account; // not worth making a class for\n        this.update(data);\n    }\n\n    update(data) {\n        this.enabled = data.enabled;\n        this.syncing = data.syncing;\n        this.expireBehavior = data.expire_behavior;\n        this.expireGracePeriod = data.expire_grace_period;\n        this.enableEmoticons = data.enable_emoticons;\n        this.subscriberCount = data.subscriber_count;\n        this.syncedAt = data.synced_at;\n    }\n\n    /**\n    * Edit the guild integration\n    * @arg {Object} options The properties to edit\n    * @arg {String} [options.expireBehavior] What to do when a user's subscription runs out\n    * @arg {String} [options.expireGracePeriod] How long before the integration's role is removed from an unsubscribed user\n    * @arg {String} [options.enableEmoticons] Whether to enable integration emoticons or not\n    * @returns {Promise}\n    */\n    edit(options) {\n        return this.guild.shard.client.editGuildIntegration.call(this.guild.shard.client, this.guild.id, this.id, options);\n    }\n\n    /**\n    * Delete the guild integration\n    * @returns {Promise}\n    */\n    delete() {\n        return this.guild.shard.client.deleteGuildIntegration.call(this.guild.shard.client, this.guild.id, this.id);\n    }\n\n    /**\n    * Force the guild integration to sync\n    * @returns {Promise}\n    */\n    sync() {\n        return this.guild.shard.client.syncGuildIntegration.call(this.guild.shard.client, this.guild.id, this.id);\n    }\n}\n\nmodule.exports = GuildIntegration;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Invite.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\n\n/**\n* Represents an invite. The nullable properties will be null if the bot user does not have manage channel or manage server permissions for the invite's channel/server.\n* @prop {String} code The invite code\n* @prop {Object} channel Info on the invite channel\n* @prop {String} channel.id The ID of the invite's channel\n* @prop {String} channel.name The name of the invite's channel\n* @prop {Object} guild Info on the invite guild\n* @prop {String} guild.id The ID of the invite's guild\n* @prop {String} guild.name The name of the invite's guild\n* @prop {String?} guild.splash The hash of the invite splash screen\n* @prop {String?} guild.icon The hash of the guild icon\n* @prop {User?} inviter The invite creator\n* @prop {Number?} uses The number of invite uses\n* @prop {Number?} maxUses The max number of invite uses\n* @prop {Number?} maxAge How long the invite lasts in seconds\n* @prop {Boolean?} temporary Whether the invite is temporary or not\n* @prop {Number?} createdAt Timestamp of invite creation\n* @prop {Boolean?} revoked Whether the invite was revoked or not\n*/\nclass Invite extends Base {\n    constructor(data, client) {\n        super();\n        this._client = client;\n        this.code = data.code;\n        this.channel = data.channel;\n        this.guild = {\n            splash: data.guild.splash,\n            icon: data.guild.icon,\n            id: data.guild.id,\n            name: data.guild.name\n        };\n        if(data.inviter) {\n            this.inviter = client.users.add(data.inviter, client);\n        }\n        this.uses = data.uses !== undefined ? data.uses : null;\n        this.maxUses = data.max_uses !== undefined ? data.max_uses : null;\n        this.maxAge = data.max_age !== undefined ? data.max_age : null;\n        this.temporary = data.temporary !== undefined ? data.temporary : null;\n        this._createdAt = data.created_at !== undefined ? data.created_at : null;\n        this.revoked = data.revoked !== undefined ? data.revoked : null;\n    }\n\n    get createdAt() {\n        return this._createdAt;\n    }\n\n    /**\n    * Delete the invite\n    * @returns {Promise}\n    */\n    delete() {\n        return this._client.deleteInvite.call(this._client, this.code);\n    }\n}\n\nmodule.exports = Invite;","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/Relationship.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\n\n/**\n* Represents a Relationship\n* @prop {User} user The other user in the relationship\n* @prop {Number} type The type of relationship. 1 is friend, 2 is block, 3 is incoming request, 4 is outgoing request\n* @prop {String} status The other user's status. Either \"online\", \"idle\", or \"offline\"\n* @prop {Object?} game The active game the other user is playing\n* @prop {String} game.name The name of the active game\n* @prop {Number} game.type The type of the active game (0 is default, 1 is Twitch, 2 is YouTube)\n* @prop {String?} game.url The url of the active game\n*/\n\nclass Relationship extends Base {\n    constructor(data, client) {\n        super(data.id);\n        this.user = client.users.add(data.user, client);\n        this.update(data);\n    }\n\n    update(data) {\n        this.type = data.type !== undefined ? data.type : this.type || 0;\n        this.status = data.status !== undefined ? data.status : this.status || \"offline\";\n        this.game = data.game !== undefined ? data.game : this.game || null;\n    }\n}\n\nmodule.exports = Relationship;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/rest/RequestHandler.js":"\"use strict\";\n\nconst Endpoints = require(\"./Endpoints\");\nconst HTTPS = require(\"https\");\nconst MultipartData = require(\"../util/MultipartData\");\nconst SequentialBucket = require(\"../util/SequentialBucket\");\n\n/**\n* Handles APi requests\n*/\nclass RequestHandler {\n    constructor(client, forceQueueing) {\n        this._client = client;\n        this.baseURL = Endpoints.BASE_URL;\n        this.userAgent = `DiscordBot (https://github.com/abalabahaha/eris, ${require(\"../../package.json\").version})`;\n        this.ratelimits = {};\n        this.latencyRef = {\n            latency: 500,\n            raw: [500, 500, 500, 500, 500, 500, 500, 500, 500, 500],\n            total: 5000,\n            timeOffset: 0,\n            lastTimeOffsetCheck: 0\n        };\n        this.globalBlock = false;\n        this.readyQueue = [];\n        if(forceQueueing) {\n            this.globalBlock = true;\n            this._client.once(\"shardPreReady\", () => this.globalUnblock());\n        }\n    }\n\n    globalUnblock() {\n        this.globalBlock = false;\n        while(this.readyQueue.length > 0) {\n            this.readyQueue.shift()();\n        }\n    }\n\n    routefy(url) {\n        return url.replace(/\\/([a-z-]+)\\/(?:[0-9]{17,})+?/g, function(match, p) {\n            return p === \"channels\" || p === \"guilds\" ? match : `/${p}/:id`;\n        }).replace(/\\/reactions\\/.+/g, \"/reactions/:id\");\n    }\n\n    /**\n    * Make an API request\n    * @arg {String} method Uppercase HTTP method\n    * @arg {String} url URL of the endpoint\n    * @arg {Boolean} auth Whether to add the Authorization header and token or not\n    * @arg {Object} [body] Request payload\n    * @arg {Object} [file] File object\n    * @arg {String} file.file A buffer containing file data\n    * @arg {String} file.name What to name the file\n    * @returns {Promise<Object>} Resolves with the returned JSON data\n    */\n    request(method, url, auth, body, file, _route, short) {\n        var route = _route || this.routefy(url);\n\n        return new Promise((resolve, reject) => {\n            var attempts = 0;\n\n            var actualCall = (cb) => {\n                var headers = {\n                    \"User-Agent\": this.userAgent\n                };\n                var data;\n\n                try {\n                    if(auth) {\n                        headers.Authorization = this._client.token;\n                    }\n                    if(file && file.file) {\n                        data = new MultipartData();\n                        headers[\"Content-Type\"] = \"multipart/form-data; boundary=\" + data.boundary;\n                        data.attach(\"file\", file.file, file.name);\n                        if(body) {\n                            data.attach(\"payload_json\", body);\n                        }\n                        data = data.finish();\n                    } else if(body) {\n                        if(method === \"GET\" || (method === \"PUT\" && url.includes(\"/bans/\"))) { // TODO remove PUT case when devs fix\n                            var qs = \"\";\n                            Object.keys(body).forEach(function(key) {\n                                if(body[key] != undefined) {\n                                     if(Array.isArray(body[key])) {\n                                        body[key].forEach(function(val) {\n                                            qs += `&${encodeURIComponent(key)}=${encodeURIComponent(val)}`;\n                                        });\n                                    } else {\n                                        qs += `&${encodeURIComponent(key)}=${encodeURIComponent(body[key])}`;\n                                    }\n                                }\n                            });\n                            url += \"?\" + qs.substring(1);\n                        } else {\n                            data = JSON.stringify(body);\n                            headers[\"Content-Type\"] = \"application/json\";\n                        }\n                    }\n                } catch(err) {\n                    cb();\n                    reject(err);\n                    return;\n                }\n\n                var req = HTTPS.request({\n                    method: method,\n                    host: \"discordapp.com\",\n                    path: this.baseURL + url,\n                    headers: headers\n                });\n\n                var reqError;\n\n                req.once(\"abort\", () => {\n                    cb();\n                    reqError = reqError || new Error(`Request aborted by client on ${method} ${url}`);\n                    reqError.req = req;\n                    reject(reqError);\n                });\n\n                req.once(\"aborted\", () => {\n                    cb();\n                    reqError = reqError || new Error(`Request aborted by server on ${method} ${url}`);\n                    reqError.req = req;\n                    reject(reqError);\n                });\n\n                req.once(\"error\", (err) => {\n                    reqError = err;\n                    req.abort();\n                });\n\n                var latency = Date.now();\n\n                req.once(\"response\", (resp) => {\n                    latency = Date.now() - latency;\n                    this.latencyRef.total = this.latencyRef.total - this.latencyRef.raw.shift() + latency;\n                    this.latencyRef.latency = ~~(this.latencyRef.total / this.latencyRef.raw.push(latency));\n\n                    var response = \"\";\n\n                    resp.on(\"data\", (chunk) => {\n                        response += chunk;\n                    });\n\n                    resp.once(\"end\", () => {\n                        var now = Date.now();\n                        if(this.latencyRef.lastTimeOffsetCheck < now - 60000) {\n                            var timeOffset = Date.parse(resp.headers[\"date\"]) - (this.latencyRef.lastTimeOffsetCheck = now);\n                            if(~~(this.latencyRef.timeOffset) - this.latencyRef.latency >= 5000 && ~~(timeOffset) - this.latencyRef.latency >= 5000) {\n                                this._client.emit(\"error\", new Error(`Your clock is ${this.latencyRef.timeOffset}ms behind Discord's server clock. Please check your connection and system time.`));\n                            }\n                            this.latencyRef.timeOffset = timeOffset;\n                        }\n\n                        if(resp.headers[\"x-ratelimit-limit\"]) {\n                            this.ratelimits[route].limit = +resp.headers[\"x-ratelimit-limit\"];\n                        }\n\n                        this.ratelimits[route].remaining = resp.headers[\"x-ratelimit-remaining\"] === undefined ? 1 : +resp.headers[\"x-ratelimit-remaining\"] || 0;\n\n                        if(resp.headers[\"retry-after\"]) {\n                            if(resp.headers[\"x-ratelimit-global\"]) {\n                                this.globalBlock = true;\n                                setTimeout(() => this.globalUnblock(), +resp.headers[\"retry-after\"] || 1);\n                            } else {\n                                this.ratelimits[route].reset = (+resp.headers[\"retry-after\"] || 1) + now;\n                            }\n                        } else if(resp.headers[\"x-ratelimit-reset\"]) {\n                            this.ratelimits[route].reset = Math.max(+resp.headers[\"x-ratelimit-reset\"] * (route.endsWith(\"/reactions/:id\") ? 250 : 1000) + this.latencyRef.timeOffset, now);\n                        }\n\n                        if(resp.statusCode !== 429) {\n                            this._client.emit(\"debug\", `${body && body.content} ${now} ${route} ${resp.statusCode}: ${latency}ms (${this.latencyRef.latency}ms avg) | ${this.ratelimits[route].remaining}/${this.ratelimits[route].limit} left | Reset ${this.ratelimits[route].reset} (${this.ratelimits[route].reset - now}ms left)`);\n                        }\n\n                        if(resp.statusCode >= 300) {\n                            if(resp.statusCode === 429) {\n                                this._client.emit(\"warn\", `${resp.headers[\"x-ratelimit-global\"] ? \"Global\" : \"Unexpected\"} 429 ( : ${response}\\n${body && body.content} ${now} ${route} ${resp.statusCode}: ${latency}ms (${this.latencyRef.latency}ms avg) | ${this.ratelimits[route].remaining}/${this.ratelimits[route].limit} left | Reset ${this.ratelimits[route].reset} (${this.ratelimits[route].reset - now}ms left)`);\n                                if(resp.headers[\"retry-after\"]) {\n                                    setTimeout(() => {\n                                        this.request(method, url, auth, body, file, route, true).then(resolve).catch(reject);\n                                        cb();\n                                    }, +resp.headers[\"retry-after\"]);\n                                    return;\n                                } else {\n                                    this.request(method, url, auth, body, file, route, true).then(resolve).catch(reject);\n                                    return cb();\n                                }\n                            } else if(resp.statusCode === 502 && ++attempts < 4) {\n                                this._client.emit(\"warn\", \"A wild 502 appeared! Thanks CloudFlare!\");\n                                setTimeout(() => {\n                                    this.request(method, url, auth, body, file, route, true).then(resolve).catch(reject);\n                                }, Math.floor(Math.random() * 1900 + 100));\n                                return cb();\n                            }\n                            var err = new Error(`${resp.statusCode} ${resp.statusMessage} on ${method} ${url}\\n\\n${response.substring(0, 200)}`);\n                            err.resp = resp;\n                            err.response = response;\n                            err.req = req;\n                            reject(err);\n                            return cb();\n                        }\n                        if(response.length > 0) {\n                            if(resp.headers[\"content-type\"] === \"application/json\") {\n                                try {\n                                    response = JSON.parse(response);\n                                } catch(err) {\n                                    cb();\n                                    reject(err);\n                                    return;\n                                }\n                            }\n                        }\n                        cb();\n                        resolve(response);\n                    });\n                });\n\n                req.setTimeout(15000, function() {\n                    reqError = new Error(`Request timed out (>15000ms) on ${method} ${url}`);\n                    req.abort();\n                });\n\n                req.end(data);\n            };\n\n            if(this.globalBlock && auth) {\n                this.readyQueue.push(() => {\n                    if(!this.ratelimits[route]) {\n                        this.ratelimits[route] = new SequentialBucket(1, this.latencyRef);\n                    }\n                    this.ratelimits[route].queue(actualCall, short);\n                });\n            } else {\n                if(!this.ratelimits[route]) {\n                    this.ratelimits[route] = new SequentialBucket(1, this.latencyRef);\n                }\n                this.ratelimits[route].queue(actualCall, short);\n            }\n        });\n    }\n}\n\nmodule.exports = RequestHandler;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/util/MultipartData.js":"\"use strict\";\n\nclass MultipartData {\n    constructor() {\n        this.boundary = \"----------------Eris\";\n        this.buf = new Buffer(0);\n    }\n\n    attach(fieldName, data, filename) {\n        if(data === undefined) {\n            return;\n        }\n        var str = \"\\r\\n--\" + this.boundary + \"\\r\\nContent-Disposition: form-data; name=\\\"\" + fieldName + \"\\\"\";\n        if(filename) {\n            str += \"; filename=\\\"\" + filename + \"\\\"\";\n        }\n        if(data instanceof Buffer) {\n            str +=\"\\r\\nContent-Type: application/octet-stream\";\n        } else if(typeof data === \"object\") {\n            str +=\"\\r\\nContent-Type: application/json\";\n            data = new Buffer(JSON.stringify(data));\n        } else {\n            data = new Buffer(\"\" + data);\n        }\n        this.buf = Buffer.concat([\n            this.buf,\n            new Buffer(str + \"\\r\\n\\r\\n\"),\n            data\n        ]);\n    }\n\n    finish() {\n        return this.buf = Buffer.concat([\n            this.buf,\n            new Buffer(\"\\r\\n--\" + this.boundary + \"--\")\n        ]);\n    }\n}\n\nmodule.exports = MultipartData;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/util/SequentialBucket.js":"\"use strict\";\n\n/**\n* Ratelimit requests and release in sequence\n* @prop {Number} limit How many tokens the bucket can consume in the current interval\n* @prop {Number} remaining How many tokens the bucket has left in the current interval\n* @prop {Number} reset Timestamp of next reset\n* @prop {Boolean} processing Whether the queue is being processed\n*/\nclass SequentialBucket {\n    /**\n    * Construct a SequentialBucket\n    * @arg {Number} tokenLimit The max number of tokens the bucket can consume per interval\n    * @arg {Object} [latencyRef] An object\n    * @arg {Number} latencyRef.latency Interval between consuming tokens\n    */\n    constructor(limit, latencyRef) {\n        this.limit = this.remaining = limit;\n        this.resetInterval = 0;\n        this.reset = 0;\n        this.processing = false;\n        this.latencyRef = latencyRef || {\n            latency: 0\n        };\n        this._queue = [];\n    }\n\n    /**\n    * Queue something in the SequentialBucket\n    * @arg {Function} func A function to call when a token can be consumed. The function will be passed a callback argument, which must be called to allow the bucket to continue to work\n    */\n    queue(func, short) {\n        if(short) {\n            this._queue.unshift(func);\n        } else {\n            this._queue.push(func);\n        }\n        this.check();\n    }\n\n    check(override) {\n        if((this.processing && !override) || this._queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n        if(this.reset && this.reset < Date.now() - this.latencyRef.latency) {\n            this.reset = this.resetInterval ? Date.now() - this.latencyRef.latency + this.resetInterval : 0;\n            this.remaining = this.limit;\n        }\n        this.last = Date.now();\n        if(this.remaining <= 0) {\n            return setTimeout(() => {\n                this.check(true);\n            }, Math.max(0, this.reset || 0 - Date.now()) + this.latencyRef.latency);\n        }\n        --this.remaining;\n        this._queue.shift()(() => {\n            if(this._queue.length > 0) {\n                this.check(true);\n            } else {\n                this.processing = false;\n            }\n        });\n    }\n}\n\nmodule.exports = SequentialBucket;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/gateway/ShardManager.js":"\"use strict\";\n\nconst Collection = require(\"../util/Collection\");\nconst Shard = require(\"./Shard\");\n\nclass ShardManager extends Collection {\n    constructor(client) {\n        super(Shard);\n        this.client = client;\n\n        this.connectQueue = [];\n        this.lastConnect = 0;\n        this.connectTimeout = null;\n    }\n\n    _readyPacketCB() {\n        this.lastConnect = Date.now();\n        this.tryConnect();\n    }\n\n    connect(shard) {\n        if(this.lastConnect <= Date.now() - 5000 && !this.find((shard) => shard.connecting)) {\n            shard.connect();\n            this.lastConnect = Date.now() + 7500;\n        } else {\n            this.connectQueue.push(shard);\n            this.tryConnect();\n        }\n    }\n\n    tryConnect() {\n        if(this.connectQueue.length > 0) {\n            if(this.lastConnect <= Date.now() - 5000) {\n                var shard = this.connectQueue.shift();\n                shard.connect();\n                this.lastConnect = Date.now() + 7500;\n            } else if(!this.connectTimeout) {\n                this.connectTimeout = setTimeout(() => {\n                    this.connectTimeout = null;\n                    this.tryConnect();\n                }, 1000);\n            }\n        }\n    }\n\n    spawn(id) {\n        var shard = this.get(id);\n        if(!shard) {\n            shard = this.add(new Shard(id, this.client));\n            shard.on(\"ready\", () => {\n                /**\n                * Fired when a shard turns ready\n                * @event Client#shardReady\n                * @prop {Number} id The ID of the shard\n                */\n                this.client.emit(\"shardReady\", shard.id);\n                if(this.client.ready) {\n                    return;\n                }\n                for(var other of this) {\n                    if(!other[1].ready) {\n                        return;\n                    }\n                }\n                this.client.ready = true;\n                this.client.startTime = Date.now();\n                /**\n                * Fired when all shards turn ready\n                * @event Client#ready\n                */\n                this.client.emit(\"ready\");\n            }).on(\"resume\", () => {\n                /**\n                * Fired when a shard resumes\n                * @event Client#shardResume\n                * @prop {Number} id The ID of the shard\n                */\n                this.client.emit(\"shardResume\", shard.id);\n                if(this.client.ready) {\n                    return;\n                }\n                for(var other of this) {\n                    if(!other[1].ready) {\n                        return;\n                    }\n                }\n                this.client.ready = true;\n                this.client.startTime = Date.now();\n                this.client.emit(\"ready\");\n            }).on(\"disconnect\", (error) => {\n                /**\n                * Fired when a shard disconnects\n                * @event Client#shardDisconnect\n                * @prop {Error?} error The error, if any\n                * @prop {Number} id The ID of the shard\n                */\n                this.client.emit(\"shardDisconnect\", error, shard.id);\n                if(!this.client.ready) {\n                    return;\n                }\n                for(var other of this) {\n                    if(other[1].ready) {\n                        return;\n                    }\n                }\n                this.client.ready = false;\n                this.client.startTime = 0;\n                /**\n                * Fired when all shards disconnect\n                * @event Client#disconnect\n                */\n                this.client.emit(\"disconnect\");\n            });\n        }\n        if(shard.status === \"disconnected\") {\n            this.connect(shard);\n        }\n    }\n}\n\nmodule.exports = ShardManager;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/gateway/Shard.js":"\"use strict\";\n\nconst Bucket = require(\"../util/Bucket\");\nconst Call = require(\"../structures/Call\");\nconst Constants = require(\"../Constants\");\nconst ExtendedUser = require(\"../structures/ExtendedUser\");\nconst OPCodes = Constants.GatewayOPCodes;\nconst User = require(\"../structures/User\");\nvar WebSocket = typeof window !== \"undefined\" ? window.WebSocket : require(\"ws\");\nconst Zlib = require(\"zlib\");\n\nvar EventEmitter;\ntry {\n    EventEmitter = require(\"eventemitter3\");\n} catch(err) {\n    EventEmitter = require(\"events\").EventEmitter;\n}\nvar Erlpack;\ntry {\n    Erlpack = require(\"erlpack\");\n} catch(err) { // eslint-disable no-empty\n}\nvar Pako;\ntry {\n    Pako = require(\"pako\");\n} catch(err) { // eslint-disable no-empty\n}\ntry {\n    WebSocket = require(\"uws\");\n} catch(err) { // eslint-disable no-empty\n}\n\n/**\n* Represents a shard\n* @extends EventEmitter\n* @prop {Number} id The ID of the shard\n* @prop {Boolean} connecting Whether the shard is connecting\n* @prop {Boolean} ready Whether the shard is ready\n* @prop {Array<String>?} discordServerTrace Debug trace of Discord servers\n* @prop {String} status The status of the shard. \"disconnected\"/\"connecting\"/\"handshaking\"/\"connected\"\n* @prop {Number} lastHeartbeatReceived Last time Discord acknowledged a heartbeat, null if shard has not sent heartbeat yet\n* @prop {Number} lastHeartbeatSent Last time shard sent a heartbeat, null if shard has not sent heartbeat yet\n* @prop {Number} latency Current latency between shard and Discord\n*/\nclass Shard extends EventEmitter {\n    constructor(id, client) {\n        super();\n\n        this.id = id;\n        this.client = client;\n\n        this.hardReset();\n    }\n\n    get latency() {\n        return this.lastHeartbeatSent && this.lastHeartbeatReceived ? this.lastHeartbeatReceived - this.lastHeartbeatSent : Infinity;\n    }\n\n    /**\n    * Tells the shard to connect\n    */\n    connect() {\n        if(this.ws && this.ws.readyState != WebSocket.CLOSED) {\n            this.client.emit(\"error\", new Error(\"Existing connection detected\"), this.id);\n            return;\n        }\n        ++this.connectAttempts;\n        this.connecting = true;\n        return this.initializeWS();\n    }\n\n    /**\n    * Disconnects the shard\n    * @arg {Object?} [options] Shard disconnect options\n    * @arg {String | Boolean} [options.reconnect] false means destroy everything, true means you want to reconnect in the future, \"auto\" will autoreconnect\n    */\n    disconnect(options, error) {\n        if(!this.ws) {\n            return;\n        }\n        options = options || {};\n        if(this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n        if(this.ws) {\n            this.ws.onclose = undefined;\n            try {\n                if(options.reconnect && this.sessionID) {\n                    this.ws.terminate();\n                } else {\n                    this.ws.close();\n                }\n            } catch(err) {\n                /**\n                * Fired when the shard encounters an error\n                * @event Client#error\n                * @prop {Error} err The error\n                * @prop {Number} id The ID of the shard\n                */\n                this.client.emit(\"error\", err, this.id);\n            }\n            /**\n            * Fired when the shard disconnects\n            * @event Shard#disconnect\n            * @prop {Error?} err The error, if any\n            */\n            this.emit(\"disconnect\", error || null);\n            this.ws = null;\n        }\n        this.status = \"disconnected\";\n        this.reset();\n        if(options.reconnect === \"auto\" && this.client.options.autoreconnect) {\n            /**\n            * Fired when stuff happens and gives more info\n            * @event Client#debug\n            * @prop {String} message The debug message\n            * @prop {Number} id The ID of the shard\n            */\n            this.client.emit(\"debug\", `Queueing reconnect in ${this.reconnectInterval}ms | Attempt ${this.connectAttempts}`, this.id);\n            setTimeout(() => {\n                this.client.shards.connect(this);\n            }, this.reconnectInterval);\n            this.reconnectInterval = Math.min(Math.round(this.reconnectInterval * (Math.random() * 2 + 1)), 30000);\n        } else if(!options.reconnect) {\n            this.hardReset();\n        }\n    }\n\n    reset() {\n        this.connecting = false;\n        this.ready = false;\n        this.preReady = false;\n        this.getAllUsersCount = {};\n        this.getAllUsersQueue = [];\n        this.getAllUsersLength = 1;\n        this.guildSyncQueue = [];\n        this.guildSyncQueueLength = 1;\n        this.unsyncedGuilds = 0;\n        this.lastHeartbeatAck = true;\n        this.lastHeartbeatReceived = null;\n        this.lastHeartbeatSent = null;\n        this.status = \"disconnected\";\n    }\n\n    hardReset() {\n        this.reset();\n        this.seq = 0;\n        this.sessionID = null;\n        this.reconnectInterval = 1000;\n        this.connectAttempts = 0;\n        this.ws = null;\n        this.heartbeatInterval = null;\n        this.guildCreateTimeout = null;\n        this.idleSince = null;\n        this.globalBucket = new Bucket(120, 60000, 0);\n        this.presenceUpdateBucket = new Bucket(5, 60000, 0);\n        this.presence = JSON.parse(JSON.stringify(this.client.presence)); // Fast copy\n    }\n\n    resume() {\n        this.sendWS(OPCodes.RESUME, {\n            token: this.client.token,\n            session_id: this.sessionID,\n            seq: this.seq\n        }, true);\n    }\n\n    identify() {\n        var identify = {\n            token: this.client.token,\n            v: Constants.GATEWAY_VERSION,\n            compress: !!this.client.options.compress,\n            large_threshold: this.client.options.largeThreshold,\n            properties: {\n                \"os\": process.platform,\n                \"browser\": \"Eris\",\n                \"device\": \"Eris\"\n            }\n        };\n        if(this.client.options.maxShards > 1) {\n            identify.shard = [this.id, this.client.options.maxShards];\n        }\n        if(this.presence.status) {\n            identify.presence = this.presence;\n        }\n        this.sendWS(OPCodes.IDENTIFY, identify, true);\n    }\n\n    wsEvent(packet) {\n        // var startTime = Date.now();\n        // var debugStr = \"\";\n        switch(packet.t) { /* eslint-disable no-redeclare */ // ( \n            case \"PRESENCE_UPDATE\": {\n                if(packet.d.user.username !== undefined) {\n                    var user = this.client.users.get(packet.d.user.id);\n                    var oldUser = null;\n                    if(user && (user.username !== packet.d.user.username || user.avatar !== packet.d.user.avatar)) {\n                        oldUser = {\n                            username: user.username,\n                            discriminator: user.discriminator,\n                            avatar: user.avatar\n                        };\n                    }\n                    if(!user || oldUser) {\n                        user = this.client.users.update(packet.d.user, this.client);\n                        /**\n                        * Fired when a user's username or avatar changes\n                        * @event Client#userUpdate\n                        * @prop {User} user The updated user\n                        * @prop {Object?} oldUser The old user data\n                        * @prop {String} oldUser.username The username of the user\n                        * @prop {String} oldUser.discriminator The discriminator of the user\n                        * @prop {String?} oldUser.avatar The hash of the user's avatar, or null if no avatar\n                        */\n                        this.client.emit(\"userUpdate\", user, oldUser);\n                    }\n                }\n                if(!packet.d.guild_id) {\n                    packet.d.id = packet.d.user.id;\n                    var relationship = this.client.relationships.get(packet.d.id);\n                    if(!relationship) { // Removing relationships\n                        return;\n                    }\n                    var oldPresence = {\n                        game: relationship.game,\n                        status: relationship.status\n                    };\n                    /**\n                    * Fired when a guild member or relationship's status or game changes\n                    * @event Client#presenceUpdate\n                    * @prop {Member | Relationship} other The updated member or relationship\n                    * @prop {Object?} oldPresence The old presence data. If the user was offline when the bot started and the client option getAllUsers is not true, this will be null\n                    * @prop {String} oldPresence.status The other user's old status. Either \"online\", \"idle\", or \"offline\"\n                    * @prop {Object?} oldPresence.game The old game the other user was playing\n                    * @prop {String} oldPresence.game.name The name of the active game\n                    * @prop {Number} oldPresence.game.type The type of the active game (0 is default, 1 is Twitch, 2 is YouTube)\n                    * @prop {String} oldPresence.game.url The url of the active game\n                    */\n                    this.client.emit(\"presenceUpdate\", this.client.relationships.update(packet.d), oldPresence);\n                    break;\n                }\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                if(!guild) {\n                    this.client.emit(\"warn\", \"Rogue presence update: \" + JSON.stringify(packet), this.id);\n                    break;\n                }\n                var member = guild.members.get(packet.d.id = packet.d.user.id);\n                var oldPresence = null;\n                if(member && (member.status !== packet.d.status || (member.game !== packet.d.game && (!member.game || !packet.d.game || member.game.name !== packet.d.game.name || member.game.type !== packet.d.game.type || member.game.url !== packet.d.game.url)))) {\n                    oldPresence = {\n                        game: member.game,\n                        status: member.status\n                    };\n                }\n                if((!member && packet.d.user.username) || oldPresence) {\n                    member = guild.members.update(packet.d, guild);\n                    this.client.emit(\"presenceUpdate\", member, oldPresence);\n                }\n                break;\n            }\n            case \"VOICE_STATE_UPDATE\": { // ( \n                if(packet.d.guild_id === undefined) {\n                    packet.d.id = packet.d.user_id;\n                    if(packet.d.channel_id === null) {\n                        var flag = false;\n                        for(var groupChannel of this.client.groupChannels) {\n                            var call = (groupChannel[1].call || groupChannel[1].lastCall);\n                            if(call && call.voiceStates.remove(packet.d)) {\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag) {\n                            for(var privateChannel of this.client.privateChannels) {\n                                var call = (privateChannel[1].call || privateChannel[1].lastCall);\n                                if(call && call.voiceStates.remove(packet.d)) {\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                            if(!flag) {\n                                this.client.emit(\"error\", new Error(\"VOICE_STATE_UPDATE for user leaving call not found\"));\n                                break;\n                            }\n                        }\n                    } else {\n                        var channel = this.client.getChannel(packet.d.channel_id);\n                        if(!channel.call && !channel.lastCall) {\n                            this.client.emit(\"error\", new Error(\"VOICE_STATE_UPDATE for untracked call\"));\n                            break;\n                        }\n                        (channel.call || channel.lastCall).voiceStates.update(packet.d);\n                    }\n                    break;\n                }\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                if(!guild) {\n                    break;\n                }\n                if(guild.pendingVoiceStates) {\n                    guild.pendingVoiceStates.push(packet.d);\n                    break;\n                }\n                var member = guild.members.get(packet.d.id = packet.d.user_id);\n                if(!member) {\n                    var channel = guild.channels.find((channel) => channel.type === 2 && channel.voiceMembers.get(packet.d.id));\n                    if(channel) {\n                        channel.voiceMembers.remove(packet.d);\n                        this.client.emit(\"warn\", \"VOICE_STATE_UPDATE member null but in channel: \" + packet.d.id, this.id);\n                        break;\n                    }\n                    break;\n                }\n                var oldState = {\n                    mute: member.voiceState.mute,\n                    deaf: member.voiceState.deaf,\n                    selfMute: member.voiceState.selfMute,\n                    selfDeaf: member.voiceState.selfDeaf\n                };\n                var oldChannelID = member.voiceState.channelID;\n                member.update(packet.d, this.client);\n                if(member.user.id === this.client.user.id) {\n                    var voiceConnection = this.client.voiceConnections.get(packet.d.guild_id);\n                    if(voiceConnection && voiceConnection.channelID !== packet.d.channel_id) {\n                        voiceConnection.switchChannel(packet.d.channel_id, true);\n                    }\n                }\n                if(oldChannelID != packet.d.channel_id) {\n                    var oldChannel, newChannel;\n                    if(oldChannelID) {\n                        oldChannel = guild.channels.get(oldChannelID);\n                    }\n                    if(packet.d.channel_id && (newChannel = guild.channels.get(packet.d.channel_id)) && newChannel.type === 2) { // Welcome to Discord, where one can \"join\" text channels\n                        if(oldChannel) {\n                            /**\n                            * Fired when a guild member switches voice channels\n                            * @event Client#voiceChannelSwitch\n                            * @prop {Member} member The member\n                            * @prop {GuildChannel} newChannel The new voice channel\n                            * @prop {GuildChannel} oldChannel The old voice channel\n                            */\n                            oldChannel.voiceMembers.remove(member);\n                            this.client.emit(\"voiceChannelSwitch\", newChannel.voiceMembers.add(member, guild), newChannel, oldChannel);\n                        } else {\n                            /**\n                            * Fired when a guild member joins a voice channel. This event is not fired when a member switches voice channels, see `voiceChannelSwitch`\n                            * @event Client#voiceChannelJoin\n                            * @prop {Member} member The member\n                            * @prop {GuildChannel} newChannel The voice channel\n                            */\n                            this.client.emit(\"voiceChannelJoin\", newChannel.voiceMembers.add(member, guild), newChannel);\n                        }\n                    } else if(oldChannel) {\n                        /**\n                        * Fired when a guild member leaves a voice channel. This event is not fired when a member switches voice channels, see `voiceChannelSwitch`\n                        * @event Client#voiceChannelLeave\n                        * @prop {Member} member The member\n                        * @prop {GuildChannel} oldChannel The voice channel\n                        */\n                        this.client.emit(\"voiceChannelLeave\", oldChannel.voiceMembers.remove(member), oldChannel);\n                    }\n                }\n                if(oldState.mute !== member.mute || oldState.deaf !== member.deaf || oldState.selfMute !== member.selfMute || oldState.selfDeaf !== member.selfDeaf) {\n                    /**\n                    * Fired when a guild member's voice state changes\n                    * @event Client#voiceStateUpdate\n                    * @prop {Member} member The member\n                    * @prop {Object} oldState The old voice state\n                    * @prop {Boolean} oldState.mute The previous server mute status\n                    * @prop {Boolean} oldState.deaf The previous server deaf status\n                    * @prop {Boolean} oldState.selfMute The previous self mute status\n                    * @prop {Boolean} oldState.selfDeaf The previous self deaf status\n                    */\n                    this.client.emit(\"voiceStateUpdate\", member, oldState);\n                }\n                break;\n            }\n            case \"TYPING_START\": {\n                if(this.client.listeners(\"typingStart\").length > 0) {\n                    /**\n                    * Fired when a user begins typing\n                    * @event Client#typingStart\n                    * @prop {Channel} channel The text channel the user is typing in\n                    * @prop {User} user The user\n                    */\n                    this.client.emit(\"typingStart\", this.client.getChannel(packet.d.channel_id), this.client.users.get(packet.d.user_id));\n                }\n                break;\n            }\n            case \"MESSAGE_CREATE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(channel) { // MESSAGE_CREATE just when deleting o.o\n                    channel.lastMessageID = packet.d.id;\n                    /**\n                    * Fired when a message is created\n                    * @event Client#messageCreate\n                    * @prop {Message} message The message\n                    */\n                    this.client.emit(\"messageCreate\", channel.messages.add(packet.d, this.client));\n                } else {\n                    this.client.emit(\"debug\", \"MESSAGE_CREATE but channel not found (OK if deleted channel)\", this.id);\n                }\n                break;\n            }\n            case \"MESSAGE_UPDATE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    break;\n                }\n                var message = channel.messages.get(packet.d.id);\n                var oldMessage = {\n                    id: packet.d.id\n                };\n                if(message) {\n                    oldMessage = {\n                        attachments: message.attachments,\n                        content: message.content,\n                        embeds: message.embeds,\n                        editedTimestamp: message.editedTimestamp,\n                        mentionedBy: message.mentionedBy,\n                        mentions: message.mentions,\n                        roleMentions: message.roleMentions,\n                        channelMentions: message.channelMentions,\n                        tts: message.tts\n                    };\n                }\n                /**\n                * Fired when a message is updated\n                * @event Client#messageUpdate\n                * @prop {Message} message The updated message. If oldMessage was undefined, it is not recommended to use this since it will be very incomplete\n                * @prop {Object?} oldMessage The old message data, if the message was cached\n                * @prop {Object[]} oldMessage.id The ID of the message\n                * @prop {Object[]?} oldMessage.attachments Array of attachments\n                * @prop {Object[]?} oldMessage.embeds Array of embeds\n                * @prop {String?} oldMessage.content Message content\n                * @prop {Number?} oldMessage.editedTimestamp Timestamp of latest message edit\n                * @prop {Object?} oldMessage.mentionedBy Object of if different things mention the bot user\n                * @prop {Boolean?} oldMessage.tts Whether to play the message using TTS or not\n                * @prop {String[]?} oldMessage.mentions Array of mentioned users' ids\n                * @prop {String[]?} oldMessage.roleMentions Array of mentioned roles' ids.\n                * @prop {String[]?} oldMessage.channelMentions Array of mentions channels' ids.\n                */\n                this.client.emit(\"messageUpdate\", channel.messages.update(packet.d, this.client), oldMessage);\n                break;\n            }\n            case \"MESSAGE_DELETE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    break;\n                }\n                /**\n                * Fired when a cached message is deleted\n                * @event Client#messageDelete\n                * @prop {Message | Object} message The message object. If the message is not cached, this will be an object with `id` and `channel` keys. No other property is guaranteed\n                */\n                this.client.emit(\"messageDelete\", channel.messages.remove(packet.d) || {\n                    id: packet.d.id,\n                    channel: channel\n                });\n                break;\n            }\n            case \"MESSAGE_DELETE_BULK\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    break;\n                }\n\n                /**\n                 * Fired when a bulk delete occurs\n                 * @event Client#messageDeleteBulk\n                * @prop {Message[] | Object[]} messages An array of (potentially partial) message objects. If a message is not cached, it will be an object with `id` and `channel` keys. No other property is guaranteed\n                 */\n                this.client.emit(\"messageDeleteBulk\", packet.d.ids.map((id) => (channel.messages.remove({\n                    id\n                }) || {\n                    id: id,\n                    channel: channel\n                })));\n                break;\n            }\n            case \"MESSAGE_REACTION_ADD\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    break;\n                }\n                var message = channel.messages.get(packet.d.message_id);\n                if(message) {\n                    var reaction = packet.d.emoji.id ? `${packet.d.emoji.name}:${packet.d.emoji.id}` : packet.d.emoji.name;\n                    if(message.reactions[reaction]) {\n                        ++message.reactions[reaction].count;\n                        if(packet.d.user_id === this.client.user.id) {\n                            message.reactions[reaction].me = true;\n                        }\n                    } else {\n                        message.reactions[reaction] = {\n                            count: 1,\n                            me: packet.d.user_id === this.client.user.id\n                        };\n                    }\n                }\n                /**\n                * Fired when someone adds a reaction to a message\n                * @event Client#messageReactionAdd\n                * @prop {Message | Object} message The message object. If the message is not cached, this will be an object with `id` and `channel` keys. No other property is guaranteed\n                * @prop {Object} emoji The reaction emoji object\n                * @prop {String?} emoji.id The emoji ID (null for non-custom emojis)\n                * @prop {String} emoji.name The emoji name\n                * @prop {String} userID The ID of the user that added the reaction\n                */\n                this.client.emit(\"messageReactionAdd\", message || {\n                    id: packet.d.message_id,\n                    channel: channel\n                }, packet.d.emoji, packet.d.user_id);\n                break;\n            }\n            case \"MESSAGE_REACTION_REMOVE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    break;\n                }\n                var message = channel.messages.get(packet.d.message_id);\n                if(message) {\n                    var reaction = packet.d.emoji.id ? `${packet.d.emoji.name}:${packet.d.emoji.id}` : packet.d.emoji.name;\n                    if(message.reactions[reaction]) {\n                        --message.reactions[reaction].count;\n                        if(packet.d.user_id === this.client.user.id) {\n                            message.reactions[reaction].me = false;\n                        }\n                    }\n                }\n                /**\n                * Fired when someone removes a reaction from a message\n                * @event Client#messageReactionRemove\n                * @prop {Message | Object} message The message object. If the message is not cached, this will be an object with `id` and `channel` keys. No other property is guaranteed\n                * @prop {Object} emoji The reaction emoji object\n                * @prop {String?} emoji.id The ID of the emoji (null for non-custom emojis)\n                * @prop {String} emoji.name The emoji name\n                * @prop {String} userID The ID of the user that removed the reaction\n                */\n                this.client.emit(\"messageReactionRemove\", message || {\n                    id: packet.d.message_id,\n                    channel: channel\n                }, packet.d.emoji, packet.d.user_id);\n                break;\n            }\n            case \"MESSAGE_REACTIONS_REMOVE_ALL\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    break;\n                }\n                /**\n                * Fired when someone removes a reaction from a message\n                * @event Client#messageReactionRemove\n                * @prop {Message | Object} message The message object. If the message is not cached, this will be an object with `id` and `channel` keys. No other property is guaranteed\n                * @prop {Object} emoji The reaction emoji object\n                * @prop {String?} emoji.id The ID of the emoji (null for non-custom emojis)\n                * @prop {String} emoji.name The emoji name\n                * @prop {String} userID The ID of the user that removed the reaction\n                */\n                this.client.emit(\"messageReactionRemoveAll\", channel.messages.get(packet.d.message_id) || {\n                    id: packet.d.message_id,\n                    channel: channel\n                });\n                break;\n            }\n            case \"GUILD_MEMBER_ADD\": {\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                packet.d.id = packet.d.user.id;\n                ++guild.memberCount;\n                /**\n                * Fired when a member joins a server\n                * @event Client#guildMemberAdd\n                * @prop {Guild} guild The guild\n                * @prop {Member} member The member\n                */\n                this.client.emit(\"guildMemberAdd\", guild, guild.members.add(packet.d, guild));\n                break;\n            }\n            case \"GUILD_MEMBER_UPDATE\": {\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                var member = guild.members.get(packet.d.id = packet.d.user.id);\n                var oldMember = null;\n                if(member) {\n                    oldMember = {\n                        roles: member.roles,\n                        nick: member.nick\n                    };\n                }\n                member = guild.members.update(packet.d, guild);\n                /**\n                * Fired when a member's roles or nickname are updated\n                * @event Client#guildMemberUpdate\n                * @prop {Guild} guild The guild\n                * @prop {Member} member The updated member\n                * @prop {Object?} oldMember The old member data\n                * @prop {String[]} oldMember.roles An array of role IDs this member is a part of\n                * @prop {String?} oldMember.nick The server nickname of the member\n                */\n                this.client.emit(\"guildMemberUpdate\", guild, member, oldMember);\n                break;\n            }\n            case \"GUILD_MEMBER_REMOVE\": {\n                if(packet.d.user.id === this.client.user.id) { // The bot is probably leaving\n                    break;\n                }\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                --guild.memberCount;\n                packet.d.id = packet.d.user.id;\n                /**\n                * Fired when a member leaves a server\n                * @event Client#guildMemberRemove\n                * @prop {Guild} guild The guild\n                * @prop {Member | Object} member The member. If the member is not cached, this will be an object with `id` and `user` key\n                */\n                this.client.emit(\"guildMemberRemove\", guild, guild.members.remove(packet.d) || {\n                    id: packet.d.id,\n                    user: new User(packet.d.user)\n                });\n                break;\n            }\n            case \"GUILD_CREATE\": {\n                if(!packet.d.unavailable) {\n                    var guild = this.createGuild(packet.d);\n                    if(this.ready) {\n                        if(this.client.unavailableGuilds.remove(packet.d)) {\n                            /**\n                            * Fired when an guild becomes available\n                            * @event Client#guildAvailable\n                            * @prop {Guild} guild The guild\n                            */\n                            this.client.emit(\"guildAvailable\", guild);\n                        } else {\n                            /**\n                            * Fired when an guild is created\n                            * @event Client#guildCreate\n                            * @prop {Guild} guild The guild\n                            */\n                            this.client.emit(\"guildCreate\", guild);\n                        }\n                    } else {\n                        this.client.unavailableGuilds.remove(packet.d);\n                        this.restartGuildCreateTimeout();\n                    }\n                } else {\n                    this.client.guilds.remove(packet.d);\n                    /**\n                    * Fired when an unavailable guild is created\n                    * @event Client#unavailableGuildCreate\n                    * @prop {UnavailableGuild} guild The unavailable guild\n                    */\n                    this.client.emit(\"unavailableGuildCreate\", this.client.unavailableGuilds.add(packet.d, this.client));\n                }\n                break;\n            }\n            case \"GUILD_UPDATE\": {\n                var guild = this.client.guilds.get(packet.d.id);\n                var oldGuild = null;\n                oldGuild = {\n                    name: guild.name,\n                    verificationLevel: guild.verification_level,\n                    splash: guild.splash,\n                    region: guild.region,\n                    ownerID: guild.owner_id,\n                    icon: guild.icon,\n                    features: guild.features,\n                    emojis: guild.emojis,\n                    afkChannelID: guild.afk_channel_id,\n                    afkTimeout: guild.afk_timeout\n                };\n                /**\n                * Fired when an guild is updated\n                * @event Client#guildUpdate\n                * @prop {Guild} guild The guild\n                * @prop {Object} oldGuild The old guild data\n                * @prop {String} oldGuild.name The name of the guild\n                * @prop {Number} oldGuild.verificationLevel The guild verification level\n                * @prop {String} oldGuild.region The region of the guild\n                * @prop {String?} oldGuild.icon The hash of the guild icon, or null if no icon\n                * @prop {String} oldGuild.afkChannelID The ID of the AFK voice channel\n                * @prop {Number} oldGuild.afkTimeout The AFK timeout in seconds\n                * @prop {String} oldGuild.ownerID The ID of the user that is the guild owner\n                * @prop {String?} oldGuild.splash The hash of the guild splash image, or null if no splash (VIP only)\n                * @prop {Object[]} oldGuild.features An array of guild features\n                * @prop {Object[]} oldGuild.emojis An array of guild emojis\n                */\n                this.client.emit(\"guildUpdate\", this.client.guilds.update(packet.d, this.client), oldGuild);\n                break;\n            }\n            case \"GUILD_DELETE\": {\n                delete this.client.guildShardMap[packet.d.id];\n                var guild = this.client.guilds.remove(packet.d);\n                if(guild) { // Discord sends GUILD_DELETE for guilds that were previously unavailable in READY\n                    guild.channels.forEach((channel) => {\n                        delete this.client.channelGuildMap[channel.id];\n                    });\n                }\n                if(packet.d.unavailable) {\n                    /**\n                    * Fired when an guild becomes unavailable\n                    * @event Client#guildUnavailable\n                    * @prop {Guild} guild The guild\n                    */\n                    this.client.emit(\"guildUnavailable\", this.client.unavailableGuilds.add(packet.d, this.client));\n                } else {\n                    /**\n                    * Fired when an guild is deleted\n                    * @event Client#guildDelete\n                    * @prop {Guild} guild The guild\n                    */\n                    this.client.emit(\"guildDelete\", guild || {\n                        id: packet.d.id\n                    });\n                }\n                break;\n            }\n            case \"GUILD_BAN_ADD\": {\n                /**\n                * Fired when a user is banned from a guild\n                * @event Client#guildBanAdd\n                * @prop {Guild} guild The guild\n                * @prop {User} user The banned user\n                */\n                this.client.emit(\"guildBanAdd\", this.client.guilds.get(packet.d.guild_id), this.client.users.add(packet.d.user, this.client));\n                break;\n            }\n            case \"GUILD_BAN_REMOVE\": {\n                /**\n                * Fired when a user is unbanned from a guild\n                * @event Client#guildBanRemove\n                * @prop {Guild} guild The guild\n                * @prop {User} user The banned user\n                */\n                this.client.emit(\"guildBanRemove\", this.client.guilds.get(packet.d.guild_id), this.client.users.add(packet.d.user, this.client));\n                break;\n            }\n            case \"GUILD_ROLE_CREATE\": {\n                /**\n                * Fired when a guild role is created\n                * @event Client#guildRoleCreate\n                * @prop {Guild} guild The guild\n                * @prop {Role} role The role\n                */\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                this.client.emit(\"guildRoleCreate\", guild, guild.roles.add(packet.d.role, guild));\n                break;\n            }\n            case \"GUILD_ROLE_UPDATE\": {\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                var role = guild.roles.add(packet.d.role, guild);\n                var oldRole = null;\n                if(role) {\n                    oldRole = {\n                        color: role.color,\n                        hoist: role.hoist,\n                        managed: role.managed,\n                        name: role.name,\n                        permissions: role.permissions,\n                        position: role.position\n                    };\n                }\n                /**\n                * Fired when a guild role is updated\n                * @event Client#guildRoleUpdate\n                * @prop {Guild} guild The guild\n                * @prop {Role} role The updated role\n                * @prop {Object} oldRole The old role data\n                * @prop {String} oldRole.name The name of the role\n                * @prop {Boolean} oldRole.managed Whether a guild integration manages this role or not\n                * @prop {Boolean} oldRole.hoist Whether users with this role are hoisted in the user list or not\n                * @prop {Number} oldRole.color The hex color of the role in base 10\n                * @prop {Number} oldRole.position The position of the role\n                * @prop {Permission} oldRole.permissions The permissions number of the role\n                */\n                this.client.emit(\"guildRoleUpdate\", guild, guild.roles.update(packet.d.role, guild), oldRole);\n                break;\n            }\n            case \"GUILD_ROLE_DELETE\": {\n                /**\n                * Fired when a guild role is deleted\n                * @event Client#guildRoleDelete\n                * @prop {Guild} guild The guild\n                * @prop {Role} role The role\n                */\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                if(guild) { // Eventual Consistency ( \n                    this.client.emit(\"guildRoleDelete\", guild, guild.roles.remove({id: packet.d.role_id}));\n                }\n                break;\n            }\n            case \"CHANNEL_CREATE\": {\n                if(packet.d.type === undefined || packet.d.type === 1) {\n                    if(this.id === 0) {\n                        /**\n                        * Fired when a channel is created\n                        * @event Client#channelCreate\n                        * @prop {Channel} channel The channel\n                        */\n                        this.client.privateChannelMap[packet.d.recipients[0].id] = packet.d.id;\n                        this.client.emit(\"channelCreate\", this.client.privateChannels.add(packet.d, this.client));\n                    }\n                } else if(packet.d.type === 0 || packet.d.type === 2) {\n                    var guild = this.client.guilds.get(packet.d.guild_id);\n                    if(!guild) {\n                        break;\n                    }\n                    var channel = guild.channels.add(packet.d, guild);\n                    this.client.channelGuildMap[packet.d.id] = packet.d.guild_id;\n                    this.client.emit(\"channelCreate\", channel);\n                } else if(packet.d.type === 3) {\n                    if(this.id === 0) {\n                        this.client.emit(\"channelCreate\", this.client.groupChannels.add(packet.d, this.client));\n                    }\n                } else {\n                    this.emit(\"error\", new Error(\"Unhandled CHANNEL_CREATE type: \" + JSON.stringify(packet, null, 2)));\n                }\n                break;\n            }\n            case \"CHANNEL_UPDATE\": {\n                var channel = this.client.getChannel(packet.d.id);\n                if(!channel) {\n                    return;\n                }\n                if(channel.type === 3) {\n                    if(this.id !== 0) {\n                        break;\n                    }\n                    var oldChannel = {\n                        name: channel.name,\n                        ownerID: channel.ownerID,\n                        icon: channel.icon\n                    };\n                }\n                if(channel.type === 0 || channel.type === 2) {\n                    var oldChannel = {\n                        name: channel.name,\n                        topic: channel.topic,\n                        position: channel.position,\n                        bitrate: channel.bitrate,\n                        permissionOverwrites: channel.permissionOverwrites\n                    };\n                }\n                channel.update(packet.d);\n                /**\n                * Fired when a channel is updated\n                * @event Client#channelUpdate\n                * @prop {Channel} channel The updated channel\n                * @prop {Object} oldChannel The old channel data\n                * @prop {String} oldChannel.name The name of the channel\n                * @prop {Number} oldChannel.position The position of the channel\n                * @prop {String?} oldChannel.topic The topic of the channel (text channels only)\n                * @prop {Number?} oldChannel.bitrate The bitrate of the channel (voice channels only)\n                * @prop {Collection} oldChannel.permissionOverwrites Collection of PermissionOverwrites in this channel\n                */\n                this.client.emit(\"channelUpdate\", channel, oldChannel);\n                break;\n            }\n            case \"CHANNEL_DELETE\": {\n                if(packet.d.type === 1 || packet.d.type === undefined) {\n                    if(this.id === 0) {\n                        var channel = this.client.privateChannels.remove(packet.d);\n                        if(channel) {\n                            delete this.client.privateChannelMap[channel.recipient.id];\n                            /**\n                            * Fired when a channel is deleted\n                            * @event Client#channelDelete\n                            * @prop {Channel} channel The channel\n                            */\n                            this.client.emit(\"channelDelete\", channel);\n                        }\n                    }\n                } else if(packet.d.type === 0 || packet.d.type === 2) {\n                    delete this.client.channelGuildMap[packet.d.id];\n                    var channel = this.client.guilds.get(packet.d.guild_id).channels.remove(packet.d);\n                    if(!channel) {\n                        return;\n                    }\n                    if(channel.type === 2) {\n                        channel.voiceMembers.forEach((member) => {\n                            this.client.emit(\"voiceChannelLeave\", channel.voiceMembers.remove(member), channel);\n                        });\n                    }\n                    this.client.emit(\"channelDelete\", channel);\n                } else if(packet.d.type === 3) {\n                    if(this.id === 0) {\n                        this.client.emit(\"channelDelete\", this.client.groupChannels.remove(packet.d));\n                    }\n                } else {\n                    this.emit(\"error\", new Error(\"Unhandled CHANNEL_DELETE type: \" + JSON.stringify(packet, null, 2)));\n                }\n                break;\n            }\n            case \"CALL_CREATE\": {\n                packet.d.id = packet.d.message_id;\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(channel.call) {\n                    channel.call.update(packet.d);\n                } else {\n                    channel.call = new Call(packet.d, channel);\n                    var incrementedID = \"\";\n                    var overflow = true;\n                    var chunks = packet.d.id.match(/\\d{1,9}/g).map((chunk) => parseInt(chunk));\n                    for(var i = chunks.length - 1; i >= 0; --i) {\n                        if(overflow) {\n                            ++chunks[i];\n                            overflow = false;\n                        }\n                        if(chunks[i] > 999999999) {\n                            overflow = true;\n                            incrementedID = \"000000000\" + incrementedID;\n                        } else {\n                            incrementedID = chunks[i] + incrementedID;\n                        }\n                    }\n                    if(overflow) {\n                        incrementedID = overflow + incrementedID;\n                    }\n                    this.client.getMessages(channel.id, 1, incrementedID);\n                }\n                /**\n                * Fired when a call is created\n                * @event Client#callCreate\n                * @prop {Call} call The call\n                */\n                this.client.emit(\"callCreate\", channel.call);\n                break;\n            }\n            case \"CALL_UPDATE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel.call) {\n                    throw new Error(\"CALL_UPDATE but channel has no call\");\n                }\n                var oldCall = {\n                    participants: channel.call.participants,\n                    ringing: channel.call.ringing,\n                    region: channel.call.region,\n                    endedTimestamp: channel.call.endedTimestamp,\n                    unavailable: channel.call.unavailable,\n                };\n                /**\n                * Fired when a call is updated\n                * @event Client#callUpdate\n                * @prop {Call} call The updated call\n                * @prop {Object} oldCall The old call data\n                * @prop {String[]} oldCall.participants The IDs of the call participants\n                * @prop {Number?} oldCall.endedTimestamp The timestamp of the call end\n                * @prop {String[]?} oldCall.ringing The IDs of people that were being rung\n                * @prop {String?} oldCall.region The region of the call server\n                * @prop {Boolean} oldCall.unavailable Whether the call was unavailable or not\n                */\n                this.client.emit(\"callUpdate\", channel.call.update(packet.d), oldCall);\n                break;\n            }\n            case \"CALL_DELETE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel.call) {\n                    throw new Error(\"CALL_DELETE but channel has no call\");\n                }\n                channel.lastCall = channel.call;\n                channel.call = null;\n                /**\n                * Fired when a call is deleted\n                * @event Client#callDelete\n                * @prop {Call} call The call\n                */\n                this.client.emit(\"callDelete\", channel.lastCall);\n                break;\n            }\n            case \"CHANNEL_RECIPIENT_ADD\": {\n                var channel = this.client.groupChannels.get(packet.d.channel_id);\n                    /**\n                    * Fired when a user joins a group channel\n                    * @event Client#channelRecipientAdd\n                    * @prop {GroupChannel} channel The channel\n                    * @prop {User} user The user\n                    */\n                this.client.emit(\"channelRecipientAdd\", channel, channel.recipients.add(this.client.users.add(packet.d.user, this.client)));\n                break;\n            }\n            case \"CHANNEL_RECIPIENT_REMOVE\": {\n                var channel = this.client.groupChannels.get(packet.d.channel_id);\n                    /**\n                    * Fired when a user leaves a group channel\n                    * @event Client#channelRecipientRemove\n                    * @prop {GroupChannel} channel The channel\n                    * @prop {User} user The user\n                    */\n                this.client.emit(\"channelRecipientRemove\", channel, channel.recipients.remove(packet.d.user));\n                break;\n            }\n            case \"FRIEND_SUGGESTION_CREATE\": {\n                /**\n                * Fired when a client receives a friend suggestion\n                * @event Client#friendSuggestionCreate\n                * @prop {User} user The suggested user\n                * @prop {String[]} reasons Array of reasons why this suggestion was made\n                * @prop {Number} reasons.type Type of reason?\n                * @prop {String} reasons.platform_type Platform you share with the user\n                * @prop {String} reasons.name Username of suggested user on that platform\n                */\n                this.client.emit(\"friendSuggestionCreate\",new User(packet.d.suggested_user), packet.d.reasons);\n                break;\n            }\n            case \"FRIEND_SUGGESTION_DELETE\": {\n                /**\n                * Fired when a client's friend suggestion is removed for any reason\n                * @event Client#friendSuggestionDelete\n                * @prop {User} user The suggested user\n                */\n                this.client.emit(\"friendSuggestionDelete\", this.client.users.get(packet.d.suggested_user_id));\n                break;\n            }\n            case \"GUILD_MEMBERS_CHUNK\": {\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                if(this.getAllUsersCount.hasOwnProperty(guild.id)) {\n                    if(this.getAllUsersCount[guild.id] <= 1) {\n                        delete this.getAllUsersCount[guild.id];\n                        this.checkReady();\n                    } else {\n                        --this.getAllUsersCount[guild.id];\n                    }\n                }\n\n                /**\n                 * Fired when Discord sends member chunks\n                 * @event Client#guildMemberChunk\n                 * @prop {Guild} guild The guild the chunked members are in\n                 * @prop {Array<Member>} members The members in the chunk\n                 */\n                this.client.emit(\"guildMemberChunk\", guild, packet.d.members.map((member) => {\n                    member.id = member.user.id;\n                    return guild.members.add(member, guild);\n                }));\n\n                this.lastHeartbeatAck = true;\n\n                // debugStr = \" | \" + packet.d.members.length + \" members | \" + guild.id;\n\n                break;\n            }\n            case \"GUILD_SYNC\": {// (  thx Discord devs\n                var guild = this.client.guilds.get(packet.d.id);\n                for(var member of packet.d.members) {\n                    member.id = member.user.id;\n                    guild.members.add(member, guild);\n                }\n                for(var presence of packet.d.presences) {\n                    if(!guild.members.get(presence.user.id)) {\n                        var userData = this.client.users.get(presence.user.id);\n                        if(userData) {\n                            userData = `{username: ${userData.username}, id: ${userData.id}, discriminator: ${userData.discriminator}}`;\n                        }\n                        this.client.emit(\"debug\", `Presence without member. ${presence.user.id}. In global user cache: ${userData}. ` + JSON.stringify(presence), this.id);\n                        continue;\n                    }\n                    presence.id = presence.user.id;\n                    guild.members.update(presence);\n                }\n                if(guild.pendingVoiceStates && guild.pendingVoiceStates.length > 0) {\n                    for(var voiceState of guild.pendingVoiceStates) {\n                        if(!guild.members.get(voiceState.user_id)) {\n                            continue;\n                        }\n                        voiceState.id = voiceState.user_id;\n                        var channel = guild.channels.get(voiceState.channel_id);\n                        if(channel) {\n                            channel.voiceMembers.add(guild.members.update(voiceState));\n                            if(this.client.options.seedVoiceConnections && voiceState.id === this.client.user.id && !this.client.voiceConnections.get(channel.guild ? channel.guild.id : \"call\")) {\n                                this.client.joinVoiceChannel(channel.id, false);\n                            }\n                        } else { // Phantom voice states from connected users in deleted channels ( \n                            this.client.emit(\"warn\", \"Phantom voice state received but channel not found | Guild: \" + guild.id + \" | Channel: \" + voiceState.channel_id);\n                        }\n                    }\n                }\n                guild.pendingVoiceStates = null;\n                --this.unsyncedGuilds;\n                this.checkReady();\n                break;\n            }\n            case \"RESUMED\":\n            case \"READY\": {\n                this.connectAttempts = 0;\n                this.reconnectInterval = 1000;\n\n                this.connecting = false;\n                this.status = \"connected\";\n                this.presence.status = \"online\";\n                this.client.shards._readyPacketCB();\n\n                if(packet.t === \"RESUMED\") {\n                    this.preReady = true;\n                    this.ready = true;\n\n                    /**\n                    * Fired when a shard finishes resuming\n                    * @event Shard#resume\n                    * @prop {Number} id The ID of the shard\n                    */\n                    this.emit(\"resume\");\n                    break;\n                }\n\n                this.client.user = this.client.users.add(new ExtendedUser(packet.d.user, this.client), this.client);\n                if(this.client.user.bot) {\n                    this.client.bot = true;\n                    if(!this.client.token.startsWith(\"Bot \")) {\n                        this.client.token = \"Bot \" + this.client.token;\n                    }\n                } else {\n                    this.client.bot = false;\n                    this.client.userGuildSettings = packet.d.user_guild_settings;\n                    this.client.userSettings = packet.d.user_settings;\n                }\n\n                if(packet.d._trace) {\n                    this.discordServerTrace = packet.d._trace;\n                }\n\n                this.sessionID = packet.d.session_id;\n\n                packet.d.guilds.forEach((guild) => {\n                    if(guild.unavailable) {\n                        this.client.guilds.remove(guild);\n                        this.client.unavailableGuilds.add(guild, this.client, true);\n                    } else {\n                        this.client.unavailableGuilds.remove(this.createGuild(guild));\n                    }\n                });\n\n                packet.d.private_channels.forEach((channel) => {\n                    if(channel.type === undefined || channel.type === 1) {\n                        this.client.privateChannelMap[channel.recipients[0].id] = channel.id;\n                        this.client.privateChannels.add(channel, this.client, true);\n                    } else if(channel.type === 3) {\n                        this.client.groupChannels.add(channel, this.client, true);\n                    } else {\n                        this.emit(\"error\", new Error(\"Unhandled READY private_channel type: \" + JSON.stringify(channel, null, 2)));\n                    }\n                });\n\n                if(packet.d.relationships) {\n                    packet.d.relationships.forEach((relationship) => {\n                        this.client.relationships.add(relationship, this.client, true);\n                    });\n                }\n\n                if(packet.d.presences) {\n                    packet.d.presences.forEach((presence) => {\n                        if(this.client.relationships.get(presence.user.id)) { // Avoid DM channel presences which are also in here\n                            presence.id = presence.user.id;\n                            this.client.relationships.update(presence, null, true);\n                        }\n                    });\n                }\n\n                if(packet.d.notes) {\n                    this.client.notes = packet.d.notes;\n                }\n\n                this.preReady = true;\n                /**\n                * Fired when a shard finishes processing the ready packet\n                * @event Client#shardPreReady\n                * @prop {Number} id The ID of the shard\n                */\n                this.client.emit(\"shardPreReady\", this.id);\n\n                if(this.client.unavailableGuilds.size > 0 && packet.d.guilds.length > 0) {\n                    this.restartGuildCreateTimeout();\n                } else {\n                    this.checkReady();\n                }\n\n                // debugStr = \" | \" + packet.d.guilds.length + \" guilds\";\n\n                break;\n            }\n            case \"VOICE_SERVER_UPDATE\": {\n                packet.d.session_id = this.sessionID;\n                packet.d.user_id = this.client.user.id;\n                packet.d.shard = this;\n                this.client.voiceConnections.voiceServerUpdate(packet.d);\n                break;\n            }\n            case \"USER_UPDATE\": {\n                this.client.users.update(packet.d, this.client);\n                break;\n            }\n            case \"RELATIONSHIP_ADD\": {\n                if(this.client.bot) {\n                    break;\n                }\n                var relationship = this.client.relationships.get(packet.d.id);\n                if(relationship) {\n                    var oldRelationship = {\n                        type: relationship.type\n                    };\n                    /**\n                    * Fired when a relationship is updated\n                    * @event Client#relationshipUpdate\n                    * @prop {Relationship} relationship The relationship\n                    * @prop {Object} oldRelationship The old relationship data\n                    * @prop {Number} oldRelationship.type The old type of the relationship\n                    */\n                    this.client.emit(\"relationshipUpdate\", this.client.relationships.update(packet.d), oldRelationship);\n                } else {\n                    /**\n                    * Fired when a relationship is added\n                    * @event Client#relationshipAdd\n                    * @prop {Relationship} relationship The relationship\n                    */\n                    this.client.emit(\"relationshipAdd\", this.client.relationships.add(packet.d, this.client));\n                }\n                break;\n            }\n            case \"RELATIONSHIP_REMOVE\": {\n                if(this.client.bot) {\n                    break;\n                }\n                /**\n                * Fired when a relationship is removed\n                * @event Client#relationshipRemove\n                * @prop {Relationship} relationship The relationship\n                */\n                this.client.emit(\"relationshipRemove\", this.client.relationships.remove(packet.d));\n                break;\n            }\n            case \"GUILD_EMOJIS_UPDATE\": {\n                var guild = this.client.guilds.get(packet.d.guild_id);\n                var oldEmojis = guild.emojis;\n                guild.update(packet.d);\n                /**\n                * Fired when a guild's emojis are updated\n                * @event Client#guildEmojisUpdate\n                * @prop {Guild} guild The guild\n                * @prop {Array} emojis The updated emojis of the guild\n                * @prop {Array} oldEmojis The old emojis of the guild\n                */\n                this.client.emit(\"guildEmojisUpdate\", guild, guild.emojis, oldEmojis);\n                break;\n            }\n            case \"CHANNEL_PINS_UPDATE\": {\n                var channel = this.client.getChannel(packet.d.channel_id);\n                if(!channel) {\n                    this.client.emit(\"debug\", `CHANNEL_PINS_UPDATE target channel ${packet.d.channel_id} not found`);\n                    break;\n                }\n                var oldTimestamp = channel.lastPinTimestamp;\n                channel.lastPinTimestamp = Date.parse(packet.d.timestamp);\n                /**\n                * Fired when a channel pin timestamp is updated\n                * @event Client#channelPinUpdate\n                * @prop {Channel} channel The channel\n                * @prop {Number} timestamp The new timestamp\n                * @prop {Number} oldTimestamp The old timestamp\n                */\n                this.client.emit(\"channelPinUpdate\", channel, channel.lastPinTimestamp, oldTimestamp);\n                break;\n            }\n            case \"PRESENCES_REPLACE\": {\n                for(var presence of packet.d) {\n                    var guild = this.client.guilds.get(presence.guild_id);\n                    if(!guild) {\n                        this.client.emit(\"warn\", \"Rogue presences replace: \" + JSON.stringify(presence), this.id);\n                        continue;\n                    }\n                    var member = guild.members.get(presence.user.id);\n                    if(!member && presence.user.username) {\n                        presence.id = presence.user.id;\n                        member.update(presence);\n                    }\n                }\n                break;\n            }\n            case \"USER_NOTE_UPDATE\": {\n                if(packet.d.note) {\n                    this.client.notes[packet.d.id] = packet.d.note;\n                } else {\n                    this.client.notes[packet.d.id];\n                }\n                break;\n            }\n            case \"MESSAGE_ACK\": // Ignore these\n            case \"GUILD_INTEGRATIONS_UPDATE\":\n            case \"USER_SETTINGS_UPDATE\":\n            case \"CHANNEL_PINS_ACK\": {\n                break;\n            }\n            default: {\n                /**\n                * Fired when the shard encounters an unknown packet\n                * @event Client#unknown\n                * @prop {Object} packet The unknown packet\n                * @prop {Number} id The ID of the shard\n                */\n                this.client.emit(\"unknown\", packet, this.id);\n                break;\n            }\n        } /* eslint-enable no-redeclare */\n        // this.client.emit(\"debug\", packet.t + \": \" + (Date.now() - startTime) + \"ms\" + debugStr, this.id);\n    }\n\n    syncGuild(guildID) {\n        if(this.guildSyncQueueLength + 3 + guildID.length > 4081) { // 4096 - \"{\\\"op\\\":12,\\\"d\\\":[]}\".length + 1 for lazy comma offset\n            this.requestGuildSync(this.guildSyncQueue);\n            this.guildSyncQueue = [guildID];\n            this.guildSyncQueueLength = 1 + guildID.length + 3;\n        } else if(this.ready) {\n            this.requestGuildSync([guildID]);\n        } else {\n            this.guildSyncQueue.push(guildID);\n            this.guildSyncQueueLength += guildID.length + 3;\n        }\n    }\n\n    requestGuildSync(guildID) {\n        this.sendWS(OPCodes.SYNC_GUILD, guildID);\n    }\n\n    createGuild(_guild) {\n        this.client.guildShardMap[_guild.id] = this.id;\n        var guild = this.client.guilds.add(_guild, this.client, true);\n        if(this.client.bot === false) {\n            ++this.unsyncedGuilds;\n            this.syncGuild(guild.id);\n        }\n        if(this.client.options.getAllUsers && guild.members.size < guild.memberCount) {\n            guild.fetchAllMembers();\n        }\n        return guild;\n    }\n\n    restartGuildCreateTimeout() {\n        if(this.guildCreateTimeout) {\n            clearTimeout(this.guildCreateTimeout);\n            this.guildCreateTimeout = null;\n        }\n        if(!this.ready) {\n            if(this.client.unavailableGuilds.size === 0 && this.unsyncedGuilds === 0) {\n                return this.checkReady();\n            }\n            this.guildCreateTimeout = setTimeout(() => {\n                this.checkReady();\n            }, this.client.options.guildCreateTimeout);\n        }\n    }\n\n    getGuildMembers(guildID, chunkCount) {\n        this.getAllUsersCount[guildID] = chunkCount;\n        if(this.getAllUsersLength + 3 + guildID.length > 4048) { // 4096 - \"{\\\"op\\\":8,\\\"d\\\":{\\\"guild_id\\\":[],\\\"query\\\":\\\"\\\",\\\"limit\\\":0}}\".length + 1 for lazy comma offset\n            this.requestGuildMembers(this.getAllUsersQueue);\n            this.getAllUsersQueue = [guildID];\n            this.getAllUsersLength = 1 + guildID.length + 3;\n        } else if(this.ready) {\n            this.requestGuildMembers([guildID]);\n        } else {\n            this.getAllUsersQueue.push(guildID);\n            this.getAllUsersLength += guildID.length + 3;\n        }\n    }\n\n    requestGuildMembers(guildID, query, limit) {\n        this.sendWS(OPCodes.GET_GUILD_MEMBERS, {\n            guild_id: guildID,\n            query: query || \"\",\n            limit: limit || 0\n        });\n    }\n\n    checkReady() {\n        if(!this.ready) {\n            if(this.guildSyncQueue.length > 0) {\n                this.requestGuildSync(this.guildSyncQueue);\n                this.guildSyncQueue = [];\n                this.guildSyncQueueLength = 1;\n                return;\n            }\n            if(this.unsyncedGuilds > 0) {\n                return;\n            }\n            if(this.getAllUsersQueue.length > 0) {\n                this.requestGuildMembers(this.getAllUsersQueue);\n                this.getAllUsersQueue = [];\n                this.getAllUsersLength = 1;\n                return;\n            }\n            if(Object.keys(this.getAllUsersCount).length === 0) {\n                this.ready = true;\n                /**\n                * Fired when the shard turns ready\n                * @event Shard#ready\n                */\n                this.emit(\"ready\");\n            }\n        }\n    }\n\n    initializeWS() {\n        this.status = \"connecting\";\n        this.ws = new WebSocket(this.client.gatewayURL);\n        this.ws.onopen = () => {\n            if(!this.client.token) {\n                return this.disconnect(null, new Error(\"Token not specified\"));\n            }\n            this.status = \"handshaking\";\n            /**\n            * Fired when the shard establishes a connection\n            * @event Client#connect\n            * @prop {Number} id The ID of the shard\n            */\n            this.client.emit(\"connect\", this.id);\n            this.lastHeartbeatAck = true;\n        };\n        this.ws.onmessage = (m) => {\n            try {\n                var packet = this.parse(m);\n\n                if(this.client.listeners(\"rawWS\").length > 0) {\n                    /**\n                    * Fired when the shard receives a websocket packet\n                    * @event Client#rawWS\n                    * @prop {Object} packet The packet\n                    * @prop {Number} id The ID of the shard\n                    */\n                    this.client.emit(\"rawWS\", packet, this.id);\n                }\n\n                if(packet.s) {\n                    if(packet.s > this.seq + 1 && this.ws) {\n                        /**\n                        * Fired to warn of something weird but non-breaking happening\n                        * @event Client#warn\n                        * @prop {String} message The warning message\n                        * @prop {Number} id The ID of the shard\n                        */\n                        this.client.emit(\"warn\", \"Non-consecutive sequence, requesting resume\", this.id);\n                        this.seq = packet.s;\n                        this.resume();\n                    }\n                    this.seq = packet.s;\n                }\n\n                switch(packet.op) {\n                    case OPCodes.EVENT: {\n                        if(!this.client.options.disableEvents[packet.t]) {\n                            this.wsEvent(packet);\n                        }\n                        break;\n                    }\n                    case OPCodes.HEARTBEAT: {\n                        this.heartbeat();\n                        break;\n                    }\n                    case OPCodes.INVALID_SESSION: {\n                        this.seq = 0;\n                        this.sessionID = null;\n                        this.client.emit(\"warn\", \"Invalid session, reidentifying!\", this.id);\n                        this.identify();\n                        break;\n                    }\n                    case OPCodes.RECONNECT: {\n                        this.disconnect({\n                            reconnect: \"auto\"\n                        });\n                        break;\n                    }\n                    case OPCodes.HELLO: {\n                        if(packet.d.heartbeat_interval > 0) {\n                            if(this.heartbeatInterval) {\n                                clearInterval(this.heartbeatInterval);\n                            }\n                            this.heartbeatInterval = setInterval(() => this.heartbeat(true), packet.d.heartbeat_interval);\n                        }\n\n                        this.discordServerTrace = packet.d._trace;\n                        this.connecting = false;\n\n                        if(this.sessionID) {\n                            this.resume();\n                        } else {\n                            this.identify();\n                        }\n                        this.heartbeat();\n                        break; /* eslint-enable no-unreachable */\n                    }\n                    case OPCodes.HEARTBEAT_ACK: {\n                        this.lastHeartbeatAck = true;\n                        this.lastHeartbeatReceived = new Date().getTime();\n                        break;\n                    }\n                    default: {\n                        this.client.emit(\"unknown\", packet, this.id);\n                        break;\n                    }\n                }\n            } catch(err) {\n                this.client.emit(\"error\", err, this.id);\n            }\n        };\n        this.ws.onerror = (event) => {\n            this.client.emit(\"error\", event, this.id);\n        };\n        this.ws.onclose = (event) => {\n            var err = event.code === 1000 ? null : new Error(event.code + \": \" + event.reason);\n            if(event.code) {\n                this.client.emit(\"warn\", `${event.code === 1000 ? \"Clean\" : \"Unclean\"} WS close: ${event.code}: ${event.reason}`, this.id);\n                if(event.code === 4001) {\n                    err = new Error(\"Gateway received invalid OP code\");\n                } else if(event.code === 4002) {\n                    err = new Error(\"Gateway received invalid message\");\n                } else if(event.code === 4003) {\n                    err = new Error(\"Not authenticated\");\n                } else if(event.code === 4004) {\n                    err = new Error(\"Authentication failed\");\n                } else if(event.code === 4005) {\n                    err = new Error(\"Already authenticated\");\n                } else if(event.code === 4006 || event.code === 4009) {\n                    this.sessionID = null;\n                    err = new Error(\"Invalid session\");\n                } else if(event.code === 4007) {\n                    err = new Error(\"Invalid sequence number: \" + this.seq);\n                    this.seq = 0;\n                } else if(event.code === 4008) {\n                    err = new Error(\"Gateway connection was ratelimited\");\n                } else if(event.code === 4010) {\n                    err = new Error(\"Invalid shard key\");\n                } else if(event.code === 4011) {\n                    err = new Error(\"Shard has too many guilds (>2500)\");\n                } else if(event.code === 1006) {\n                    err = new Error(\"Connection reset by peer\");\n                } else if(!event.wasClean && event.reason) {\n                    err = new Error(event.code + \": \" + event.reason);\n                }\n            } else {\n                this.client.emit(\"warn\", event, this.id);\n            }\n            this.disconnect({\n                reconnect: \"auto\"\n            }, err);\n        };\n\n        setTimeout(() => {\n            if(this.connecting) {\n                this.disconnect({\n                    reconnect: \"auto\"\n                }, new Error(\"Connection timeout\"));\n            }\n        }, this.client.options.connectionTimeout);\n    }\n\n    parse(message) {\n        var data = message.data;\n        if(Erlpack) {\n            if(data instanceof ArrayBuffer) {\n                data = new Buffer(data);\n            }\n            return Erlpack.unpack(data);\n        } else {\n            if(data instanceof ArrayBuffer) {\n                data = Pako.inflate(data, {\n                    to: \"string\"\n                });\n            } else if(data instanceof Buffer) {\n                data = Zlib.inflateSync(data).toString();\n            }\n            return JSON.parse(data);\n        }\n    }\n\n    heartbeat(normal) {\n        if(normal && !this.lastHeartbeatAck) {\n            return this.disconnect({\n                reconnect: \"auto\"\n            }, new Error(\"Server didn't acknowledge previous heartbeat, possible lost connection\"));\n        }\n        this.lastHeartbeatAck = false;\n        this.lastHeartbeatSent = new Date().getTime();\n        this.sendWS(OPCodes.HEARTBEAT, this.seq, true);\n    }\n\n    sendWS(op, _data) {\n        if(this.ws && this.ws.readyState === WebSocket.OPEN) {\n            var i = 0;\n            var waitFor = 1;\n            var func = () => {\n                if(++i >= waitFor && this.ws && this.ws.readyState === WebSocket.OPEN) {\n                    var data = Erlpack ? Erlpack.pack({op: op, d: _data}) : JSON.stringify({op: op, d: _data});\n                    this.ws.send(data);\n                    this.client.emit(\"debug\", JSON.stringify({op: op, d: _data}), this.id);\n                }\n            };\n            if(op === OPCodes.STATUS_UPDATE) {\n                ++waitFor;\n                this.presenceUpdateBucket.queue(func);\n            }\n            this.globalBucket.queue(func);\n        }\n    }\n\n    /**\n    * Updates the bot's status on all guilds the shard is in\n    * @arg {String} [status] Sets the bot's status, either \"online\", \"idle\", \"dnd\", or \"invisible\"\n    * @arg {Object} [game] Sets the bot's active game, null to clear\n    * @arg {String} game.name Sets the name of the bot's active game\n    * @arg {Number} [game.type] The type of game. 0 is default, 1 is streaming (Twitch only)\n    * @arg {String} [game.url] Sets the url of the shard's active game\n    */\n    editStatus(status, game) {\n        if(game === undefined && typeof status === \"object\") {\n            game = status;\n            status = undefined;\n        }\n        if(status) {\n            this.presence.status = status;\n        }\n        if(game !== undefined) {\n            this.presence.game = game;\n        }\n\n        this.sendWS(OPCodes.STATUS_UPDATE, {\n            afk: this.presence.status === \"idle\", // TODO: what's this AFK field?\n            game: this.presence.game,\n            since: this.presence.status === \"idle\" ? Date.now() : 0,\n            status: this.presence.status\n        });\n\n        this.client.guilds.forEach((guild) => {\n            if(guild.shard.id === this.id) {\n                guild.members.get(this.client.user.id).update(this.presence);\n            }\n        });\n    }\n}\n\nmodule.exports = Shard;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/util/Bucket.js":"\"use strict\";\n\n/**\n* Handle ratelimiting something\n* @prop {Number} tokens How many tokens the bucket has consumed in this interval\n* @prop {Number} lastReset Timestamp of last token clearing\n* @prop {Number} lastSend Timestamp of last token consumption\n* @prop {Number} tokenLimit The max number tokens the bucket can consume per interval\n* @prop {Number} interval How long (in ms) to wait between clearing used tokens\n*/\nclass Bucket {\n    /**\n    * Construct a Bucket\n    * @arg {Number} tokenLimit The max number of tokens the bucket can consume per interval\n    * @arg {Number} interval How long (in ms) to wait between clearing used tokens\n    * @arg {Object} [latencyRef] An object\n    * @arg {Number} latencyRef.latency Interval between consuming tokens\n    */\n    constructor(tokenLimit, interval, latencyRef) {\n        this.tokenLimit = tokenLimit;\n        this.interval = interval;\n        this.latencyRef = latencyRef || {\n            latency: 0\n        };\n        this.lastReset = this.tokens = this.lastSend = 0;\n        this._queue = [];\n    }\n\n    /**\n    * Queue something in the Bucket\n    * @arg {Function} func A callback to call when a token can be consumed\n    */\n    queue(func) {\n        this._queue.push(func);\n        this.check();\n    }\n\n    check() {\n        if(this.timeout || this._queue.length === 0) {\n            return;\n        }\n        if(this.lastReset + this.interval + this.tokenLimit * this.latencyRef.latency < Date.now()) {\n            this.lastReset = Date.now();\n            this.tokens = Math.max(0, this.tokens - this.tokenLimit);\n        }\n\n        var val;\n        while(this._queue.length > 0 && this.tokens < this.tokenLimit) {\n            this.tokens++;\n            let item = this._queue.shift();\n            val = this.latencyRef.latency - Date.now() + this.lastSend;\n            if(this.latencyRef.latency === 0 || val <= 0) {\n                item();\n                this.lastSend = Date.now();\n            } else {\n                setTimeout(() => {\n                    item();\n                }, val);\n                this.lastSend = Date.now() + val;\n            }\n        }\n\n        if(this._queue.length > 0 && !this.timeout) {\n            this.timeout = setTimeout(() => {\n                this.timeout = null;\n                this.check();\n            }, this.tokens < this.tokenLimit ? this.latencyRef.latency : Math.max(0, this.lastReset + this.interval + this.tokenLimit * this.latencyRef.latency - Date.now()));\n        }\n    }\n}\n\nmodule.exports = Bucket;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/structures/UnavailableGuild.js":"\"use strict\";\n\nconst Base = require(\"./Base\");\n\n/**\n* Represents a guild\n* @prop {String} id The ID of the guild\n* @prop {Boolean} unavailable Whether the guild is unavailable or not\n* @prop {Shard} shard The Shard that owns the guild\n*/\nclass UnavailableGuild extends Base {\n    constructor(data, client) {\n        super(data.id);\n        this.shard = client.shards.get(client.guildShardMap[this.id]);\n        this.unavailable = !!data.unavailable;\n    }\n}\n\nmodule.exports = UnavailableGuild;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/VoiceConnectionManager.js":"\"use strict\";\n\nconst Collection = require(\"../util/Collection\");\n\nclass VoiceConnectionManager extends Collection {\n    constructor(vcObject) {\n        super(vcObject || require(\"./VoiceConnection\"));\n        this.pendingGuilds = {};\n    }\n\n    join(guildID, channelID, options) {\n        var connection = this.get(guildID);\n        if(connection) {\n            connection.switchChannel(channelID);\n            return Promise.resolve(connection);\n        }\n        return new Promise((res, rej) => {\n            this.pendingGuilds[guildID] = {\n                channelID: channelID,\n                options: options || {},\n                res: res,\n                rej: rej,\n                timeout: setTimeout(() => {\n                    delete this.pendingGuilds[guildID];\n                    rej(new Error(\"Voice connection timeout\"));\n                }, 10000)\n            };\n        });\n    }\n\n    voiceServerUpdate(data) {\n        if(this.pendingGuilds[data.guild_id] && this.pendingGuilds[data.guild_id].timeout) {\n            clearTimeout(this.pendingGuilds[data.guild_id].timeout);\n            this.pendingGuilds[data.guild_id].timeout = null;\n        }\n        var connection = this.get(data.guild_id);\n        if(!connection) {\n            if(!this.pendingGuilds[data.guild_id]) {\n                return;\n            }\n            connection = this.add(new this.baseObject(data.guild_id, {\n                shard: data.shard,\n                opusOnly: this.pendingGuilds[data.guild_id].options.opusOnly,\n                shared: this.pendingGuilds[data.guild_id].options.shared\n            }));\n        }\n        connection.connect({\n            channel_id: (this.pendingGuilds[data.guild_id] || connection).channelID,\n            endpoint: data.endpoint,\n            token: data.token,\n            session_id: data.session_id,\n            user_id: data.user_id\n        });\n        if(!this.pendingGuilds[data.guild_id] || this.pendingGuilds[data.guild_id].waiting) {\n            return;\n        }\n        this.pendingGuilds[data.guild_id].waiting = true;\n        var disconnectHandler = () => {\n            connection = this.get(data.guild_id);\n            if(!this.pendingGuilds[data.guild_id]) {\n                if(connection) {\n                    connection.removeListener(\"ready\", readyHandler);\n                }\n                return;\n            }\n            this.pendingGuilds[data.guild_id].rej(new Error(\"Disconnected\"));\n            delete this.pendingGuilds[data.guild_id];\n            connection.removeListener(\"ready\", readyHandler);\n        };\n        var readyHandler = () => {\n            connection = this.get(data.guild_id);\n            if(!this.pendingGuilds[data.guild_id]) {\n                if(connection) {\n                    connection.removeListener(\"disconnect\", disconnectHandler);\n                }\n                return;\n            }\n            this.pendingGuilds[data.guild_id].res(connection);\n            delete this.pendingGuilds[data.guild_id];\n            connection.removeListener(\"disconnect\", disconnectHandler);\n        };\n        connection.once(\"ready\", readyHandler).once(\"disconnect\", disconnectHandler);\n    }\n\n    leave(guildID) {\n        var connection = this.get(guildID);\n        if(!connection) {\n            return;\n        }\n        connection.disconnect();\n        connection._destroy();\n        this.remove(connection);\n    }\n\n    switch(guildID, channelID) {\n        var connection = this.get(guildID);\n        if(!connection) {\n            return;\n        }\n        connection.switch(channelID);\n    }\n}\n\nmodule.exports = VoiceConnectionManager;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/command/Command.js":"\"use strict\";\n\n/**\n* Represents an command framework command\n* @prop {Object} subcommands Object mapping subcommand labels to Command objects\n*/\nclass Command {\n    /**\n    * Register a command\n    * @arg {String} label The command label\n    * @arg {Function | String | Array<Function | String>} generator A response string, array of functions or strings, or function that generates a string or array of strings when called.\n    * If a function is passed, the function will be passed a Message object and an array of command arguments. The Message object will have an additional property `prefix`, which is the prefix used in the command.\n    * `generator(msg, args)`\n    * @arg {Object} [options] Command options\n    * @arg {Array<String>} [options.aliases] An array of command aliases\n    * @arg {Boolean} [options.caseInsensitive=false] Whether the command label (and aliases) is case insensitive or not\n    * @arg {Boolean} [options.deleteCommand=false] Whether to delete the user command message or not\n    * @arg {Boolean} [options.argsRequired=false] If arguments are required or not\n    * @arg {Boolean} [options.guildOnly=false] Whether to prevent the command from being used in Direct Messages or not\n    * @arg {Boolean} [options.dmOnly=false] Whether to prevent the command from being used in guilds or not\n    * @arg {String} [options.description=\"No description\"] A short description of the command to show in the default help command\n    * @arg {String} [options.fullDescription=\"No full description\"] A detailed description of the command to show in the default help command\n    * @arg {String} [options.usage] Details on how to call the command to show in the default help command\n    * @arg {Object} [options.requirements] A set of factors that limit who can call the command\n    * @arg {Array<String>} [options.requirements.userIDs] An array of user IDs representing users that can call the command\n    * @arg {Object} [options.requirements.permissions] An object containing permission keys the user must match to use the command\n    * i.e.:\n    * ```\n    * {\n    *   \"administrator\": false,\n    *   \"manageMessages\": true\n    * }\n    * ```\n    * In the above example, the user must not have administrator permissions, but must have manageMessages to use the command\n    * @arg {Array<String>} [options.requirements.roleIDs] An array of role IDs that would allow a user to use the command\n    * @arg {Array<String>} [options.requirements.roleNames] An array of role names that would allow a user to use the command\n    * @arg {Number} [options.cooldown] The cooldown between command usage in milliseconds\n    * @arg {String} [options.cooldownMessage] A message to show when the command is on cooldown\n    * @arg {String} [options.permissionMessage] A message to show when the user doesn't have permissions to use the command\n    * @arg {String} [options.errorMessage] A message to show if the execution of the command handler somehow fails.\n    */\n    constructor(label, generator, options) {\n        this.label = label;\n        this.description = options.description || \"No description\";\n        this.fullDescription = options.fullDescription || \"No full description\";\n        this.usage = options.usage || \"\";\n        this.aliases = options.aliases || [];\n        this.caseInsensitive = !!options.caseInsensitive;\n        this.requirements = options.requirements || {};\n        if(!this.requirements.userIDs) {\n            this.requirements.userIDs = [];\n        }\n        if(!this.requirements.permissions) {\n            this.requirements.permissions = {};\n        }\n        if(!this.requirements.roleIDs) {\n            this.requirements.roleIDs = [];\n        }\n        if(!this.requirements.roleNames) {\n            this.requirements.roleNames = [];\n        }\n        this.deleteCommand = !!options.deleteCommand;\n        this.argsRequired = !!options.argsRequired;\n        this.guildOnly = !!options.guildOnly;\n        this.dmOnly = !!options.dmOnly;\n        this.cooldown = options.cooldown || 0;\n        this.cooldownMessage = options.cooldownMessage || false;\n        this.permissionMessage = options.permissionMessage || false;\n        this.errorMessage = options.errorMessage || \"\";\n        if(this.cooldown !== 0) {\n            this.usersOnCooldown = new Set();\n        }\n        if(typeof generator === \"string\") {\n            this.response = generator;\n            this.execute = () => this.response;\n        } else if(Array.isArray(generator)) {\n            this.responses = generator.map((item, index) => {\n                if(typeof item === \"string\") {\n                    return () => item;\n                } else if(typeof item === \"function\") {\n                    return item;\n                } else {\n                    throw new Error(\"Invalid command response generator (index \" + index + \")\");\n                }\n            });\n            this.execute = () => this.responses[Math.floor(Math.random() * this.responses.length)];\n        } else if(typeof generator === \"function\") {\n            this.execute = generator;\n        } else {\n            throw new Error(\"Invalid command response generator\");\n        }\n\n        this.subcommands = {};\n        this.subcommandAliases = {};\n    }\n\n    permissionCheck(msg) {\n        var req = false;\n        if(this.requirements.userIDs.length > 0) {\n            req = true;\n            if(~this.requirements.userIDs.indexOf(msg.author.id)) {\n                return true;\n            }\n        }\n        if(!msg.channel.guild) {\n            return !this.guildOnly && !req;\n        } else if(this.dmOnly) {\n            return false;\n        }\n        var keys = Object.keys(this.requirements.permissions);\n        if(keys.length > 0) {\n            req = true;\n            var permissions = msg.channel.permissionsOf(msg.author.id).json;\n            for(var key of keys) {\n                if(this.requirements.permissions[key] !== permissions[key]) {\n                    req = false;\n                    break;\n                }\n            }\n            if(req) {\n                return true;\n            }\n            req = true;\n        }\n        if(msg.member) {\n            var roles = msg.member.roles || [];\n            if(this.requirements.roleIDs.length > 0) {\n                req = true;\n                for(var roleID of this.requirements.roleIDs) {\n                    if(~roles.indexOf(roleID)) {\n                        return true;\n                    }\n                }\n            }\n            if(this.requirements.roleNames.length > 0) {\n                req = true;\n                roles = roles.map((roleID) => msg.channel.guild.roles.get(roleID).name);\n                for(var roleName of this.requirements.roleNames) {\n                    if(~roles.indexOf(roleName)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return !req;\n    }\n\n    cooldownCheck(userID) {\n        if(this.usersOnCooldown.has(userID)) {\n            return false;\n        }\n        this.usersOnCooldown.add(userID);\n        setTimeout(() => {\n            this.usersOnCooldown.delete(userID);\n        }, this.cooldown);\n        return true;\n    }\n\n    process(args, msg) {\n        if(!this.permissionCheck(msg)) {\n            if(this.permissionMessage) {\n                msg.channel.createMessage(this.permissionMessage);\n            }\n            return;\n        }\n        var shouldDelete = this.deleteCommand && msg.channel.guild && msg.channel.permissionsOf(msg._client.user.id).has(\"manageMessages\");\n        if(args.length === 0) {\n            if(this.argsRequired) {\n                msg.channel.createMessage(`Invalid usage. Do \\`${msg.prefix}help ${this.label}\\` to view proper usage.`);\n                return;\n            }\n            if(this.cooldown !== 0 && !this.cooldownCheck(msg.author.id)) {\n                if(this.cooldownMessage) {\n                    msg.channel.createMessage(this.cooldownMessage);\n                }\n                return;\n            }\n            if(shouldDelete) {\n                msg.delete();\n            }\n            return this.execute(msg, args);\n        }\n        var label = this.subcommandAliases[args[0]] || args[0];\n        var subcommand;\n        if((subcommand = this.subcommands[label]) !== undefined || ((subcommand = this.subcommands[label.toLowerCase()]) !== undefined && subcommand.caseInsensitive)) {\n            return subcommand.process(args.slice(1), msg);\n        } else {\n            if(this.cooldown !== 0 && !this.cooldownCheck(msg.author.id)) {\n                if(this.cooldownMessage) {\n                    msg.channel.createMessage(this.cooldownMessage);\n                }\n                return;\n            }\n            if(shouldDelete) {\n                msg.delete();\n            }\n            return this.execute(msg, args);\n        }\n    }\n\n    /**\n    * Register an alias for a subcommand\n    * @arg {String} alias The alias\n    * @arg {String} label The original subcommand label\n    */\n    registerSubcommandAlias(alias, label) {\n        if(!this.subcommands[label]) {\n            throw new Error(\"No subcommand registered for \" + label);\n        }\n        if(this.subcommandAliases[alias]) {\n            throw new Error(`Alias ${label} already registered`);\n        }\n        this.subcommandAliases[alias] = label;\n        this.subcommands[label].aliases.push(alias);\n    }\n\n    /**\n    * Register a subcommand\n    * @arg {String} label The subcommand label\n    * @arg {Function | String | Array<Function | String>} generator A response string, array of functions or strings, or function that generates a string or array of strings when called.\n    * If a function is passed, the function will be passed a Message object and an array of subcommand arguments. The Message object will have an additional property `prefix`, which is the prefix used in the subcommand.\n    * `generator(msg, args)`\n    * @arg {Object} [options] Command options\n    * @arg {Array<String>} [options.aliases] An array of subcommand aliases\n    * @arg {Boolean} [options.caseInsensitive=false] Whether the subcommand label (and aliases) is case insensitive or not\n    * @arg {Boolean} [options.deleteCommand=false] Whether to delete the user subcommand message or not\n    * @arg {Boolean} [options.argsRequired=false] If arguments are required or not\n    * @arg {Boolean} [options.guildOnly=false] Whether to prevent the subcommand from being used in Direct Messages or not\n    * @arg {Boolean} [options.dmOnly=false] Whether to prevent the subcommand from being used in guilds or not\n    * @arg {String} [options.description=\"No description\"] A short description of the subcommand to show in the default help subcommand\n    * @arg {String} [options.fullDescription=\"No full description\"] A detailed description of the subcommand to show in the default help subcommand\n    * @arg {String} [options.usage] Details on how to call the subcommand to show in the default help subcommand\n    * @arg {Object} [options.requirements] A set of factors that limit who can call the subcommand\n    * @arg {Array<String>} [options.requirements.userIDs] An array of user IDs representing users that can call the subcommand\n    * @arg {Object} [options.requirements.permissions] An object containing permission keys the user must match to use the subcommand\n    * i.e.:\n    * ```\n    * {\n    *   \"administrator\": false,\n    *   \"manageMessages\": true\n    * }```\n    * In the above example, the user must not have administrator permissions, but must have manageMessages to use the subcommand\n    * @arg {Array<String>} [options.requirements.roleIDs] An array of role IDs that would allow a user to use the subcommand\n    * @arg {Array<String>} [options.requirements.roleNames] An array of role names that would allow a user to use the subcommand\n    * @arg {Number} [options.cooldown] The cooldown between subcommand usage in milliseconds\n    * @arg {String} [options.cooldownMessage] A message to show when the subcommand is on cooldown\n    * @arg {String} [options.permissionMessage] A message to show when the user doesn't have permissions to use the command\n    * @returns {Command}\n    */\n    registerSubcommand(label, generator, options) {\n        if(label.includes(\" \")) {\n            throw new Error(\"Subcommand label may not have spaces\");\n        }\n        if(this.subcommands[label]) {\n            throw new Error(\"You have already registered a subcommand for \" + label);\n        }\n        options = options || {};\n        this.subcommands[label] = new Command(label, generator, options);\n        if(options.aliases) {\n            options.aliases.forEach((alias) => {\n                this.subcommandAliases[alias] = label;\n            });\n        }\n        return this.subcommands[label];\n    }\n\n    /**\n    * Unregister a subcommand\n    * @arg {String} label The subcommand label\n    */\n    unregisterSubcommand(label) {\n        var original = this.subcommandAliases[label];\n        if(original) {\n            this.subcommands[original].aliases.splice(this.subcommands[original].aliases.indexOf(label), 1);\n            delete this.subcommandAliases[label];\n        } else {\n            delete this.subcommands[label];\n        }\n    }\n}\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/command/CommandClient.js":"\"use strict\";\n\nconst Client = require(\"../Client\");\nconst Command = require(\"./Command\");\n\n/**\n* Represents an Eris client with the command framework\n* @extends Client\n* @prop {Object} commands Object mapping command labels to Command objects\n*/\nclass CommandClient extends Client {\n    /**\n    * Create a CommandClient\n    * @arg {String} token bot token\n    * @arg {Object} [options] Eris options (same as Client)\n    * @arg {Object} [commandOptions] Command options\n    * @arg {Boolean} [commandOptions.defaultHelpCommand=true] Whether to register the default help command or not\n    * @arg {String} [commandOptions.description=\"An Eris-based Discord bot\"] The description to show in the default help command\n    * @arg {Boolean} [commandOptions.ignoreBots=true] Whether to ignore bot accounts or not\n    * @arg {Boolean} [commandOptions.ignoreSelf=true] Whether to ignore the bot's own account or not\n    * @arg {String} [commandOptions.name=\"<Bot username>\"] The bot name to show in the default help command\n    * @arg {String} [commandOptions.owner=\"an unknown user\"] The owner to show in the default help command\n    * @arg {String|Array} [commandOptions.prefix=\"@mention \"] The bot prefix. Can be either an array of prefixes or a single prefix. \"@mention\" will be automatically replaced with the bot's actual mention\n    * @arg {Object} [commandOptions.defaultCommandOptions={}] Default command options. This object takes the same options as a normal Command\n    */\n    constructor(token, options, commandOptions) {\n        super(token, options);\n        this.commandOptions = {\n            defaultHelpCommand: true,\n            description: \"An Eris-based Discord bot\",\n            ignoreBots: true,\n            ignoreSelf: true,\n            name: null,\n            owner: \"an unknown user\",\n            prefix: \"@mention \",\n            defaultCommandOptions: {}\n        };\n        if(typeof commandOptions === \"object\") {\n            for(var property of Object.keys(commandOptions)) {\n                this.commandOptions[property] = commandOptions[property];\n            }\n        }\n        this.guildPrefixes = {};\n        this.commands = {};\n        this.commandAliases = {};\n\n        this.once(\"shardPreReady\", () => {\n            this.preReady = true;\n            if(!this.commandOptions.name) {\n                this.commandOptions.name = `**${this.user.username}**`;\n            }\n            if(Array.isArray(this.commandOptions.prefix)){\n                for(let i in this.commandOptions.prefix){\n                    this.commandOptions.prefix[i] = this.commandOptions.prefix[i].replace(/@mention/g, this.user.mention);\n                }\n            } else {\n                this.commandOptions.prefix = this.commandOptions.prefix.replace(/@mention/g, this.user.mention);\n            }\n            for(var key in this.guildPrefixes) {\n                if(Array.isArray(this.guildPrefixes[key])){\n                    for(let i in this.guildPrefixes[key]){\n                        this.guildPrefixes[key][i] = this.guildPrefixes[key][i].replace(/@mention/g, this.user.mention);\n                    }\n                } else {\n                    this.guildPrefixes[key] = this.guildPrefixes[key].replace(/@mention/g, this.user.mention);\n                }\n            }\n        });\n\n        this.on(\"messageCreate\", this.onMessageCreate);\n\n        if(this.commandOptions.defaultHelpCommand) {\n            this.registerCommand(\"help\", (msg, args) => {\n                var result = \"\";\n                if(args.length > 0) {\n                    var cur = this.commands[this.commandAliases[args[0]] || args[0]];\n                    if(!cur) {\n                        return \"Command not found\";\n                    }\n                    var label = cur.label;\n                    for(var i = 1; i < args.length; ++i) {\n                        cur = cur.subcommands[cur.subcommandAliases[args[i]] || args[i]];\n                        if(!cur) {\n                            return \"Command not found\";\n                        }\n                        label += \" \" + cur.label;\n                    }\n                    result += `**${msg.prefix}${label}** ${cur.usage}\\n${cur.fullDescription}`;\n                    if(Object.keys(cur.aliases).length > 0) {\n                        result += `\\n\\n**Aliases:** ${cur.aliases.join(\", \")}`;\n                    }\n                    if(Object.keys(cur.subcommands).length > 0) {\n                        result += \"\\n\\n**Subcommands:**\";\n                        for(var subLabel in cur.subcommands) {\n                            if(cur.subcommands[subLabel].permissionCheck(msg)) {\n                                result += `\\n  **${subLabel}** - ${cur.subcommands[subLabel].description}`;\n                            }\n                        }\n                    }\n                } else {\n                    result += `${this.commandOptions.name} - ${this.commandOptions.description}\\n`;\n                    if(this.commandOptions.owner) {\n                        result += `by ${this.commandOptions.owner}\\n`;\n                    }\n                    result += \"\\n\";\n                    result += \"**Commands:**\\n\";\n                    for(label in this.commands) {\n                        if(this.commands[label] && this.commands[label].permissionCheck(msg)) {\n                            result += `  **${msg.prefix}${label}** - ${this.commands[label].description}\\n`;\n                        }\n                    }\n                    result += `\\nType ${msg.prefix}help <command> for more info on a command.`;\n                }\n                return result;\n            }, {\n                description: \"This help text\",\n                fullDescription: \"This command is used to view information of different bot commands, including this one.\"\n            });\n        }\n    }\n\n    /**\n     * Checks the command client for a command based on the provided message\n     * @arg {Message} msg The message object from the message create event\n     */\n    onMessageCreate(msg) {\n        if(!this.ready) {\n            return;\n        }\n\n        msg.command = false;\n        if((!this.commandOptions.ignoreSelf || msg.author.id !== this.user.id) && (!this.commandOptions.ignoreBots || !msg.author.bot) && (msg.prefix = this.checkPrefix(msg))) {\n            var args = msg.content.replace(/<@!/g, \"<@\").substring(msg.prefix.length).split(\" \");\n            var label = args.shift();\n            label = this.commandAliases[label] || label;\n            var command;\n            if((command = this.commands[label]) !== undefined || ((command = this.commands[label.toLowerCase()]) !== undefined && command.caseInsensitive)) {\n                msg.command = command;\n                Promise.resolve(command.process(args, msg)).then((resp) => {\n                    if(resp != null) {\n                        this.createMessage(msg.channel.id, resp);\n                    }\n                }).catch((err) => {\n                    this.emit(\"warn\", err);\n                    if(command.errorMessage) {\n                        this.createMessage(msg.channel.id, command.errorMessage);\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n    * Register a prefix override for a specific guild\n    * @arg {String} guildID The ID of the guild to override prefixes for\n    * @arg {String|Array} prefix The bot prefix. Can be either an array of prefixes or a single prefix. \"@mention\" will be automatically replaced with the bot's actual mention\n    */\n    registerGuildPrefix(guildID, prefix) {\n        if(this.preReady){\n            this.guildPrefixes[guildID] = prefix;\n        } else {\n            if(Array.isArray(prefix)){\n                for(var i in prefix){\n                    prefix[i] = prefix[i].replace(/@mention/g, this.user.mention);\n                }\n                this.guildPrefixes[guildID] = prefix;\n            } else {\n                this.guildPrefixes[guildID] = prefix.replace(/@mention/g, this.user.mention);\n            }\n        }\n    }\n\n    checkPrefix(msg) {\n        var prefixes = this.commandOptions.prefix;\n        if(msg.channel.guild !== undefined && this.guildPrefixes[msg.channel.guild.id] !== undefined){\n            prefixes = this.guildPrefixes[msg.channel.guild.id];\n        }\n        if(typeof prefixes === \"string\") {\n            return msg.content.replace(/<@!/g, \"<@\").startsWith(prefixes) && prefixes;\n        } else if(Array.isArray(prefixes)) {\n            return prefixes.find((prefix) => msg.content.replace(/<@!/g, \"<@\").startsWith(prefix));\n        }\n        throw new Error(\"Unsupported prefix format | \" + prefixes);\n    }\n\n    /**\n    * Register an alias for a command\n    * @arg {String} alias The alias\n    * @arg {String} label The original command label\n    */\n    registerCommandAlias(alias, label) {\n        var caseInsensitiveLabel = false;\n        if(!this.commands[label] && !(this.commands[(label = label.toLowerCase())] && (caseInsensitiveLabel = this.commands[label.toLowerCase()].caseInsensitive))) {\n            throw new Error(\"No command registered for \" + label);\n        }\n        alias = caseInsensitiveLabel === true ? alias.toLowerCase() : alias;\n        if(this.commandAliases[alias]) {\n            throw new Error(`Alias ${alias} already registered`);\n        }\n        this.commandAliases[alias] = label;\n        this.commands[label].aliases.push(alias);\n    }\n\n    /**\n    * Register a command\n    * @arg {String} label The command label\n    * @arg {Function | String | Array<Function | String>} generator A response string, array of functions or strings, or function that generates a string or array of strings when called.\n    * If a function is passed, the function will be passed a Message object and an array of command arguments. The Message object will have an additional property `prefix`, which is the prefix used in the command.\n    * `generator(msg, args)`\n    * @arg {Object} [options] Command options\n    * @arg {Array<String>} [options.aliases] An array of command aliases\n    * @arg {Boolean} [options.caseInsensitive=false] Whether the command label (and aliases) is case insensitive or not\n    * @arg {Boolean} [options.deleteCommand=false] Whether to delete the user command message or not\n    * @arg {Boolean} [options.argsRequired=false] If arguments are required or not\n    * @arg {Boolean} [options.guildOnly=false] Whether to prevent the command from being used in Direct Messages or not\n    * @arg {Boolean} [options.dmOnly=false] Whether to prevent the command from being used in guilds or not\n    * @arg {String} [options.description=\"No description\"] A short description of the command to show in the default help command\n    * @arg {String} [options.fullDescription=\"No full description\"] A detailed description of the command to show in the default help command\n    * @arg {String} [options.usage] Details on how to call the command to show in the default help command\n    * @arg {Object} [options.requirements] A set of factors that limit who can call the command\n    * @arg {Array<String>} [options.requirements.userIDs] An array of user IDs representing users that can call the command\n    * @arg {Object} [options.requirements.permissions] An object containing permission keys the user must match to use the command\n    * i.e.:\n    * ```\n    * {\n    *   \"administrator\": false,\n    *   \"manageMessages\": true\n    * }```\n    * In the above example, the user must not have administrator permissions, but must have manageMessages to use the command\n    * @arg {Array<String>} [options.requirements.roleIDs] An array of role IDs that would allow a user to use the command\n    * @arg {Array<String>} [options.requirements.roleNames] An array of role names that would allow a user to use the command\n    * @arg {Number} [options.cooldown] The cooldown between command usage in milliseconds\n    * @arg {String} [options.cooldownMessage] A message to show when the command is on cooldown\n    * @arg {String} [options.permissionMessage] A message to show when the user doesn't have permissions to use the command\n    * @arg {String} [options.errorMessage] A message to show if the execution of the command handler somehow fails.\n    * @returns {Command}\n    */\n    registerCommand(label, generator, options) {\n        if(label.includes(\" \")) {\n            throw new Error(\"Command label may not have spaces\");\n        }\n        if(this.commands[label]) {\n            throw new Error(\"You have already registered a command for \" + label);\n        }\n        options = options || {};\n        label = options.caseInsensitive === true ? label.toLowerCase() : label;\n        for(var key in this.commandOptions.defaultCommandOptions) {\n            if(options[key] === undefined) {\n                options[key] = this.commandOptions.defaultCommandOptions[key];\n            }\n        }\n        this.commands[label] = new Command(label, generator, options);\n        if(options.aliases) {\n            options.aliases.forEach((alias) => {\n                this.commandAliases[alias] = label;\n            });\n        }\n        return this.commands[label];\n    }\n\n    /**\n    * Unregister a command\n    * @arg {String} label The command label\n    */\n    unregisterCommand(label) {\n        var original = this.commandAliases[label];\n        if(original) {\n            this.commands[original].aliases.splice(this.commands[original].aliases.indexOf(label), 1);\n            delete this.commandAliases[label];\n        } else {\n            delete this.commands[label];\n        }\n    }\n}\n\nmodule.exports = CommandClient;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/SharedStream.js":"\"use strict\";\n\nconst ChildProcess = require(\"child_process\");\nconst Piper = require(\"./Piper\");\nconst VoiceConnection = require(\"./VoiceConnection\");\nconst Collection = require(\"../util/Collection\");\n\nvar EventEmitter;\ntry {\n    EventEmitter = require(\"eventemitter3\");\n} catch(err) {\n    EventEmitter = require(\"events\").EventEmitter;\n}\nvar NodeOpus;\ntry {\n    NodeOpus = require(\"node-opus\");\n} catch(err) { // eslint-disable no-empty\n}\nvar OpusScript;\ntry {\n    OpusScript = require(\"opusscript\");\n} catch(err) { // eslint-disable no-empty\n}\n\n/**\n* Represents a collection of VoiceConnections sharing an input stream\n* @extends EventEmitter\n*/\nclass SharedStream extends EventEmitter {\n    constructor() {\n        super();\n\n        this.samplingRate = 48000;\n        this.frameDuration = 60;\n        this.channels = 2;\n\n        this.voiceConnections = new Collection(VoiceConnection);\n\n        this.converterCommand = null;\n        var pick = this.pickCommand();\n        if(pick instanceof Error) {\n            this.emit(\"error\", pick);\n        }\n\n        if(NodeOpus) {\n            this.opus = new NodeOpus.OpusEncoder(this.samplingRate, this.channels);\n        } else if(OpusScript) {\n            this.emit(\"debug\", \"node-opus not found, falling back to opusscript\");\n            this.opus = new OpusScript(this.samplingRate, this.channels, OpusScript.Application.AUDIO);\n            this.opus.setBitrate(this.bitrate);\n        } else {\n            this.emit(\"warn\", new Error(\"No opus encoder found, playing non-opus audio will not work.\"));\n        }\n\n        this.piper = new Piper(this.converterCommand, this.opus);\n        this.piper.on(\"error\", (e) => this.emit(\"error\", e));\n\n        if(pick && this.converterCommand) {\n            this.piper.libopus = false;\n        }\n\n        this.speaking = false;\n\n        this._send = this._send.bind(this);\n    }\n\n    /**\n    * Add a voice connection to the shared stream\n    * @arg {VoiceConnection} connection The voice connection to add\n    */\n    add(_connection) {\n        var connection = this.voiceConnections.add(_connection);\n        if(connection.ready) {\n            connection.setSpeaking(this.speaking);\n        } else {\n            connection.once(\"ready\", () => {\n                connection.setSpeaking(this.speaking);\n            });\n        }\n        return connection;\n    }\n\n    /**\n    * Remove a voice connection from the shared stream\n    * @arg {VoiceConnection} connection The voice connection to remove\n    */\n    remove(_connection) {\n        return this.voiceConnections.remove(_connection);\n    }\n\n    /**\n    * Play an audio or video resource. If playing from a non-opus resource, FFMPEG should be compiled with --enable-libopus for best performance. If playing from HTTPS, FFMPEG must be compiled with --enable-openssl\n    * @arg {ReadableStream | String} resource The audio or video resource, either a ReadableStream, URL, or file path\n    * @arg {Object} [options] Music options\n    * @arg {Boolean} [options.inlineVolume=false] Whether to enable on-the-fly volume changing. Note that enabling this leads to increased CPU usage\n    * @arg {Number} [options.voiceDataTimeout=2000] Timeout when waiting for voice data (-1 for no timeout)\n    * @arg {Array<String>} [options.inputArgs] Additional input parameters to pass to ffmpeg/avconv (before -i)\n    * @arg {Array<String>} [options.encoderArgs] Additional encoder parameters to pass to ffmpeg/avconv (after -i)\n    * @arg {String} [options.format] The format of the resource. If null, FFmpeg will attempt to guess and play the format. Available options: \"dca\", \"ogg\", \"pcm\", null\n    * @arg {Number} [options.frameDuration=60] The resource opus frame duration (required for DCA/Ogg)\n    * @arg {Number} [options.frameSize=2880] The resource opus frame size\n    * @arg {Number} [options.sampleRate=48000] The resource audio sampling rate\n    */\n    play(source, options) {\n        options = options || {};\n        options.format = options.format || null;\n        options.voiceDataTimeout = !isNaN(options.voiceDataTimeout) ? options.voiceDataTimeout : 2000;\n        options.inlineVolume = !!options.inlineVolume;\n        options.inputArgs = options.inputArgs || [];\n        options.encoderArgs = options.encoderArgs || [];\n\n        options.samplingRate = options.samplingRate || this.samplingRate;\n        options.frameDuration = options.frameDuration || this.frameDuration;\n        options.frameSize = options.frameSize || options.samplingRate * options.frameDuration / 1000;\n        options.pcmSize = options.pcmSize || options.frameSize * 2 * this.channels;\n\n        if(!this.piper.encode(source, options)) {\n            this.emit(\"error\", new Error(\"Unable to encode source\"));\n            return;\n        }\n\n        this.ended = false;\n        this.current = {\n            startTime: 0, // later\n            playTime: 0,\n            pausedTimestamp: 0,\n            pausedTime: 0,\n            bufferingTicks: 0,\n            options: options,\n            timeout: null,\n            buffer: null\n        };\n\n        this.playing = true;\n\n        /**\n        * Fired when the shared stream starts playing a stream\n        * @event SharedStream#start\n        */\n        this.emit(\"start\");\n\n        this._send();\n    }\n\n    _send() {\n        if(!this.piper.encoding && this.piper.dataPacketCount === 0) {\n            return this.stopPlaying();\n        }\n\n        this._incrementTimestamps(this.current.options.frameSize);\n\n        this._incrementSequences();\n\n        if((this.current.buffer = this.piper.getDataPacket())) {\n            if(this.current.startTime === 0) {\n                this.current.startTime = Date.now();\n            }\n            if(this.current.bufferingTicks > 0) {\n                this.current.bufferingTicks = 0;\n                this.setSpeaking(true);\n            }\n        } else if(this.current.options.voiceDataTimeout === -1 || this.current.bufferingTicks < this.current.options.voiceDataTimeout / this.current.options.frameDuration) { // wait for data\n            if(++this.current.bufferingTicks <= 0) {\n                this.setSpeaking(false);\n            } else {\n                this.current.pausedTime += 4 * this.current.options.frameDuration;\n                this._incrementTimestamps(3 * this.current.options.frameSize);\n                this.current.timeout = setTimeout(this._send, 4 * this.current.options.frameDuration);\n                return;\n            }\n        } else {\n            return this.stopPlaying();\n        }\n\n        this.voiceConnections.forEach((connection) => {\n            if(connection.ready) {\n                connection._sendPacket(connection._createPacket(this.current.buffer));\n            }\n        });\n        this.current.playTime += this.current.options.frameDuration;\n        this.current.timeout = setTimeout(this._send, this.current.startTime + this.current.pausedTime + this.current.playTime - Date.now());\n    }\n\n    /**\n    * Stop the bot from sending audio\n    */\n    stopPlaying() {\n        if(this.ended) {\n            return;\n        }\n        this.ended = true;\n        if(this.current && this.current.timeout) {\n            clearTimeout(this.current.timeout);\n            this.current.timeout = null;\n        }\n        this.current = null;\n        this.piper.stop();\n        this.piper.resetPackets();\n\n        this.setSpeaking(this.playing = false);\n\n        /**\n        * Fired when the shared stream finishes playing a stream\n        * @event SharedStream#end\n        */\n        this.emit(\"end\");\n    }\n\n    _incrementTimestamps(val) {\n        for(var vc of this.voiceConnections.values()) {\n            vc.timestamp += val;\n            if(vc.timestamp >= 4294967295) {\n                vc.timestamp -= 4294967295;\n            }\n        }\n    }\n\n    _incrementSequences() {\n        for(var vc of this.voiceConnections.values()) {\n            vc.sequence++;\n            if(vc.sequence >= 65536) {\n                vc.sequence -= 65536;\n            }\n        }\n    }\n\n    setSpeaking(value) {\n        if((value = !!value) != this.speaking) {\n            this.speaking = value;\n            for(var vc of this.voiceConnections.values()) {\n                vc.setSpeaking(value);\n            }\n        }\n    }\n\n    pickCommand() {\n        var tenative;\n        for(var command of [\"./ffmpeg\", \"./avconv\", \"ffmpeg\", \"avconv\"]) {\n            var res = ChildProcess.spawnSync(command, [\"-encoders\"]);\n            if(!res.error) {\n                if(!res.stdout.toString().includes(\"libopus\")) {\n                    tenative = command;\n                    continue;\n                }\n                this.converterCommand = command;\n                return;\n            }\n        }\n        if(tenative) {\n            return (this.converterCommand = tenative) + \" does not have libopus support. Non-opus playback may be laggy\";\n        }\n        throw new Error(\"Neither ffmpeg nor avconv was found. Make sure you installed either one, and check that it is in your PATH\");\n    }\n}\n\nmodule.exports = SharedStream;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/Piper.js":"\"use strict\";\n\nconst DCAOpusTransformer = require(\"./streams/DCAOpusTransformer\");\nconst FFmpegOggTransformer = require(\"./streams/FFmpegOggTransformer\");\nconst FFmpegPCMTransformer = require(\"./streams/FFmpegPCMTransformer\");\nconst FS = require(\"fs\");\nconst HTTP = require(\"http\");\nconst HTTPS = require(\"https\");\nconst OggOpusTransformer = require(\"./streams/OggOpusTransformer\");\nconst PassThroughStream = require(\"stream\").PassThrough;\nconst PCMOpusTransformer = require(\"./streams/PCMOpusTransformer\");\nconst Stream = require(\"stream\").Stream;\nconst VolumeTransformer = require(\"./streams/VolumeTransformer\");\nconst WebmOpusTransformer = require(\"./streams/WebmOpusTransformer\");\n\nvar EventEmitter;\ntry {\n    EventEmitter = require(\"eventemitter3\");\n} catch(err) {\n    EventEmitter = require(\"events\").EventEmitter;\n}\n\nclass Piper extends EventEmitter {\n    constructor(converterCommand, opus) {\n        super();\n\n        this.reset();\n\n        this.converterCommand = converterCommand;\n        this._dataPackets = [];\n        this._dataPacketMax = 30;\n        this._dataPacketMin = 15;\n        this.encoding = false;\n        this.libopus = true;\n        this.opus = opus;\n        this.volumeLevel = 1;\n\n        this._retransformer = [];\n\n        // setInterval(() => console.log(this._dataPackets.length), 500);\n    }\n\n    encode(source, options) {\n        if(this.encoding || this.streams.length) {\n            this.emit(\"error\", new Error(\"Already encoding\"));\n            return false;\n        }\n\n        if(typeof source === \"string\") {\n            if(options.format === \"dca\" || options.format === \"ogg\" || options.format === \"webm\" || options.format === \"pcm\") {\n                if(source.startsWith(\"http://\") || source.startsWith(\"https://\")) {\n                    var passThrough = new PassThroughStream();\n                    if(source.startsWith(\"http://\")) {\n                        HTTP.get(source, (res) => res.pipe(passThrough)).once(\"error\", (e) => this.stop(e));\n                    } else {\n                        HTTPS.get(source, (res) => res.pipe(passThrough)).once(\"error\", (e) => this.stop(e));\n                    }\n                    source = passThrough;\n                } else {\n                    try {\n                        FS.statSync(source);\n                    } catch(err) {\n                        if(err.code === \"ENOENT\") {\n                            this.emit(\"error\", new Error(\"That file does not exist.\"));\n                        } else {\n                            this.emit(\"error\", new Error(\"An error occured trying to access that file.\"));\n                        }\n                        return false;\n                    }\n                    source = FS.createReadStream(source);\n                }\n            }\n        } else if(!(source instanceof Stream) || !source.pipe) {\n            this.emit(\"error\", new Error(\"Invalid source type\"));\n            return false;\n        }\n\n        if(typeof source !== \"string\") {\n            this.streams.push(source.once(\"error\", (e) => this.stop(e)));\n        }\n\n        this._dataPacketMax = 30;\n        this._dataPacketMin = 15;\n\n        if(options.format === \"dca\") {\n            this.streams.push(source.pipe(new DCAOpusTransformer()).once(\"error\", (e) => this.stop(e)));\n        } else if(options.format === \"ogg\") {\n            this.streams.push(source.pipe(new OggOpusTransformer()).once(\"error\", (e) => this.stop(e)));\n        } else if(options.format === \"webm\") {\n            this.streams.push(source.pipe(new WebmOpusTransformer()).once(\"error\", (e) => this.stop(e)));\n        } else if(!options.format || options.format === \"pcm\") {\n            if(options.inlineVolume) {\n                if(!options.format) {\n                    if(!this.converterCommand) {\n                        this.emit(\"error\", new Error(\"FFmpeg/avconv was not found on this system. Playback of this audio format is impossible\"));\n                        return false;\n                    }\n                    if(typeof source === \"string\") {\n                        this.streams.push(source = new FFmpegPCMTransformer({\n                            command: this.converterCommand,\n                            input: source,\n                            encoderArgs: options.encoderArgs,\n                            inputArgs: options.inputArgs\n                        }).once(\"error\", (e) => this.stop(e)));\n                    } else {\n                        this.streams.push(source = source.pipe(new FFmpegPCMTransformer({\n                            command: this.converterCommand,\n                            encoderArgs: options.encoderArgs,\n                            inputArgs: options.inputArgs\n                        })).once(\"error\", (e) => this.stop(e)));\n                    }\n                }\n                this.streams.push(this.volume = source = source.pipe(new VolumeTransformer()).once(\"error\", (e) => this.stop(e)));\n                this.volume.setVolume(this.volumeLevel);\n                this.streams.push(this.volume.pipe(new PCMOpusTransformer({\n                    opus: this.opus,\n                    frameSize: options.frameSize,\n                    pcmSize: options.pcmSize\n                })).once(\"error\", (e) => this.stop(e)));\n                this._dataPacketMax = 1; // Live volume updating\n                this._dataPacketMin = 4;\n            } else {\n                if(this.libopus) {\n                    if(typeof source === \"string\") {\n                        this.streams.push(source = new FFmpegOggTransformer({\n                            command: this.converterCommand,\n                            input: source,\n                            encoderArgs: options.encoderArgs,\n                            inputArgs: options.inputArgs,\n                            format: options.format,\n                            frameDuration: options.frameDuration\n                        }).once(\"error\", (e) => this.stop(e)));\n                    } else {\n                        this.streams.push(source = source.pipe(new FFmpegOggTransformer({\n                            command: this.converterCommand,\n                            encoderArgs: options.encoderArgs,\n                            inputArgs: options.inputArgs,\n                            format: options.format,\n                            frameDuration: options.frameDuration\n                        })).once(\"error\", (e) => this.stop(e)));\n                    }\n                    this.streams.push(source.pipe(new OggOpusTransformer()).once(\"error\", (e) => this.stop(e)));\n                } else {\n                    if(typeof source === \"string\") {\n                        this.streams.push(source = new FFmpegPCMTransformer({\n                            command: this.converterCommand,\n                            input: source,\n                            encoderArgs: options.encoderArgs,\n                            inputArgs: options.inputArgs\n                        }).once(\"error\", (e) => this.stop(e)));\n                    } else {\n                        this.streams.push(source = source.pipe(new FFmpegPCMTransformer({\n                            command: this.converterCommand,\n                            encoderArgs: options.encoderArgs,\n                            inputArgs: options.inputArgs\n                        })).once(\"error\", (e) => this.stop(e)));\n                    }\n                    this.streams.push(source.pipe(new PCMOpusTransformer({\n                        opus: this.opus,\n                        frameSize: options.frameSize,\n                        pcmSize: options.pcmSize\n                    })).once(\"error\", (e) => this.stop(e)));\n                }\n            }\n        } else {\n            this.emit(\"error\", new Error(\"Unrecognized format\"));\n            return false;\n        }\n\n        this._endStream = this.streams[this.streams.length - 1];\n        this._endStream.manualCB = true;\n\n        this._endStream.on(\"data\", this.addDataPacket.bind(this));\n        this._endStream.once(\"finish\", () => this.stop(null, source));\n\n        this.emit(\"start\");\n\n        return (this.encoding = true);\n    }\n\n    stop(e, source) {\n        if(source && !~this.streams.indexOf(source)) {\n            return;\n        }\n\n        if(e) {\n            this.emit(\"error\", e);\n        }\n\n        if(this.throttleTimeout) {\n            clearTimeout(this.throttleTimeout);\n            this.throttleTimeout = null;\n        }\n\n        if(this.streams.length === 0) {\n            return;\n        }\n\n        if(this._endStream) {\n            this._endStream.removeAllListeners(\"data\");\n        }\n\n        for(var stream of this.streams) {\n            if(typeof stream.destroy === \"function\") {\n                stream.destroy();\n            } else {\n                stream.unpipe();\n            }\n        }\n\n        this.reset();\n        if(this.encoding) {\n            this.encoding = false;\n            this.emit(\"stop\");\n        }\n    }\n\n    reset() {\n        this.streams = [];\n        this._endStream = null;\n        this.volume = null;\n    }\n\n    resetPackets() {\n        this._dataPackets = [];\n    }\n\n    addDataPacket(packet) {\n        if(!this.encoding) {\n            return;\n        }\n        if(this._dataPackets.push(packet) < this._dataPacketMax && this._endStream) {\n            process.nextTick(() => this._endStream && this._endStream.transformCB());\n        }\n    }\n\n    setVolume(volume) {\n        this.volumeLevel = volume;\n        if(!this.volume) {\n            return;\n        }\n        // var oldDB = this.volume.db;\n        this.volume.setVolume(volume);\n        // var newDBFactor = 10 * Math.log(1 + volume) / 6.931471805599453 / oldDB;\n        // for(var i = 0; i < this._dataPackets.length; i++) {\n        //     this._retransformer[i] = newDBFactor * (this._retransformer[i] || 1);\n        // }\n    }\n\n    getDataPacket() {\n        if(this._dataPackets.length < this._dataPacketMin && this._endStream) {\n            this._endStream.transformCB();\n        }\n        if(this._retransformer.length === 0) {\n            return this._dataPackets.shift();\n        } else {\n            var packet = this.opus.decode(this._dataPackets.shift());\n            for(var i = 0, num; i < packet.length - 1; i += 2) {\n                num = ~~(this._retransformer.shift() * packet.readInt16LE(i));\n                packet.writeInt16LE(num >= 32767 ? 32767 : num <= -32767 ? -32767 : num, i);\n            }\n            return this.opus.encode(packet, 3840 / 2 / 2);\n        }\n    }\n\n    get dataPacketCount() {\n        return this._dataPackets.length;\n    }\n}\n\nmodule.exports = Piper;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/DCAOpusTransformer.js":"\"use strict\";\n\nconst BaseTransformer = require(\"./BaseTransformer\");\n\nclass DCAOpusTransformer extends BaseTransformer {\n    constructor(options) {\n        options = options || {};\n        super(options);\n\n        this._remainder = null;\n    }\n\n    process(buffer) {\n        if(buffer.length - buffer._index < 2) {\n            return true;\n        }\n\n        var opusLen = buffer.readUInt16LE(buffer._index);\n        buffer._index += 2;\n\n        if(buffer.length - buffer._index < opusLen) {\n            return false;\n        }\n\n        buffer._index += opusLen;\n        this.push(buffer.slice(buffer._index - opusLen, buffer._index));\n    }\n\n    _transform(chunk, enc, cb) {\n        if(this._remainder)  {\n            chunk = Buffer.concat([this._remainder, chunk]);\n            this._remainder = null;\n        }\n\n        if(!this.head) {\n            if(chunk.length < 4) {\n                this._remainder = chunk;\n                return cb();\n            } else {\n                var dcaVersion = chunk.slice(0, 4);\n                if(dcaVersion[0] !== 68 || dcaVersion[1] !== 67 || dcaVersion[2] !== 65) { // DCA0 or invalid\n                    this.emit(\"error\", new Error(\"Not a DCA file\"));\n                } else if(dcaVersion[3] === 49) { // DCA1\n                    if(chunk.length < 8) {\n                        this._remainder = chunk;\n                        return cb();\n                    }\n                    var jsonLength = chunk.slice(4, 8).readInt32LE(0);\n                    if(chunk.length < 8 + jsonLength) {\n                        this._remainder = chunk;\n                        return cb();\n                    }\n                    var jsonMetadata = chunk.slice(8, 8 + jsonLength);\n                    this.emit(\"debug\", jsonMetadata);\n                    chunk = chunk.slice(8 + jsonLength);\n                } else {\n                    this.emit(\"error\", new Error(\"Unsupported DCA version: \" + dcaVersion.toString()));\n                }\n            }\n        }\n\n        chunk._index = 0;\n\n        while(chunk._index < chunk.length) {\n            var offset = chunk._index;\n            var ret = this.process(chunk);\n            if(ret) {\n                this._remainder = chunk.slice(offset);\n                cb();\n                return;\n            }\n        }\n\n        this.setTransformCB(cb);\n    }\n}\n\nmodule.exports = DCAOpusTransformer;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/BaseTransformer.js":"\"use strict\";\n\nconst TransformStream = require(\"stream\").Transform;\n\nclass BaseTransformer extends TransformStream {\n    constructor(options) {\n        options = options || {};\n        if(options.allowHalfOpen === undefined) {\n            options.allowHalfOpen = true;\n        }\n        if(options.highWaterMark === undefined) {\n            options.highWaterMark = 0;\n        }\n        super(options);\n        this.manualCB = false;\n    }\n\n    setTransformCB(cb) {\n        if(this.manualCB) {\n            this.transformCB();\n            this._transformCB = cb;\n        } else {\n            cb();\n        }\n    }\n\n    transformCB() {\n        if(this._transformCB) {\n            this._transformCB();\n            this._transformCB = null;\n        }\n    }\n}\n\nmodule.exports = BaseTransformer;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/FFmpegOggTransformer.js":"\"use strict\";\n\nconst FFmpegDuplex = require(\"./FFmpegDuplex\");\n\nmodule.exports = function(options) {\n    options = options || {};\n    if(!options.command) {\n        throw new Error(\"Invalid converter command\");\n    }\n    if(options.frameDuration === undefined) {\n        options.frameDuration = 60;\n    }\n    var inputArgs = [\n        \"-analyzeduration\", \"0\",\n        \"-loglevel\", \"24\"\n    ].concat(options.inputArgs || []);\n    if(options.format === \"pcm\") {\n        inputArgs = inputArgs.concat(\n            \"-f\", \"s16le\",\n            \"-ar\", \"48000\",\n            \"-ac\", \"2\"\n        );\n    }\n    inputArgs = inputArgs.concat(\n        \"-i\", options.input || \"-\",\n        \"-vn\"\n    );\n    var outputArgs = [\n        \"-c:a\", \"libopus\",\n        \"-vbr\", \"on\",\n        \"-frame_duration\", \"\" + options.frameDuration,\n        \"-f\", \"ogg\",\n        \"-\"\n    ];\n    return FFmpegDuplex.spawn(options.command, inputArgs.concat(options.encoderArgs || [], outputArgs));\n};\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/FFmpegDuplex.js":"\"use strict\";\n\nconst ChildProcess = require(\"child_process\");\nconst DuplexStream = require(\"stream\").Duplex;\nconst PassThroughStream = require(\"stream\").PassThrough;\n\nclass FFmpegDuplex extends DuplexStream {\n    constructor(command, options) {\n        options = options || {};\n        if(options.highWaterMark === undefined) {\n            options.highWaterMark = 0;\n        }\n        super(options);\n\n        this.command = command;\n        this._reader = new PassThroughStream(options);\n        this._writer = new PassThroughStream(options);\n\n        this._onError = this.emit.bind(this, \"error\");\n\n        this._reader.on(\"error\", this._onError);\n        this._writer.on(\"error\", this._onError);\n\n        this._readableState = this._reader._readableState;\n        this._writableState = this._writer._writableState;\n\n        [\"on\", \"once\", \"removeListener\", \"removeListeners\", \"listeners\"].forEach((method) => {\n            var og = DuplexStream.prototype[method];\n\n            this[method] = function(ev, fn) {\n                var substream = delegateEvents[ev];\n                if (substream) {\n                    return this[substream][method](ev, fn);\n                } else {\n                    return og.call(this, ev, fn);\n                }\n            };\n        });\n    }\n\n    spawn(args, options) {\n        options = options || {};\n        var ex, exited, killed, ended;\n        var stderr = [];\n\n        var onStdoutEnd = () => {\n            if (exited && !ended) {\n                ended = true;\n                this._reader.end();\n                setImmediate(this.emit.bind(this, \"close\"));\n            }\n        };\n\n        var onStderrData = (chunk) => {\n            stderr.push(chunk);\n        };\n\n        var onExit = (code, signal) => {\n            if(exited) {\n                return;\n            }\n            exited = true;\n\n            if (killed) {\n                if (ex) {\n                    this.emit(\"error\", ex);\n                }\n                this.emit(\"close\");\n            } else if (code === 0 && signal == null) {\n                // All is well\n                onStdoutEnd();\n            } else {\n                // Everything else\n                ex = new Error(\"Command failed: \" + Buffer.concat(stderr).toString(\"utf8\"));\n                ex.killed = this._process.killed || killed;\n                ex.code = code;\n                ex.signal = signal;\n                this.emit(\"error\", ex);\n                this.emit(\"close\");\n            }\n\n            cleanup();\n        };\n\n        var onError = (err) => {\n            ex = err;\n            this._stdout.destroy();\n            this._stderr.destroy();\n            onExit();\n        };\n\n        var kill = () => {\n            if(killed) {\n                return;\n            }\n            this._stdout.destroy();\n            this._stderr.destroy();\n\n            killed = true;\n\n            try {\n                this._process.kill(options.killSignal || \"SIGTERM\");\n                setTimeout(() => this._process && this._process.kill(\"SIGKILL\"), 2000);\n            } catch (e) {\n                ex = e;\n                onExit();\n            }\n        };\n\n        var cleanup = () => {\n            this._process =\n            this._stderr =\n            this._stdout =\n            this._stdin =\n            stderr =\n            ex =\n            killed = null;\n\n            this.kill =\n            this.destroy = this.noop;\n        };\n\n        this._process = ChildProcess.spawn(this.command, args, options);\n        this._stdin = this._process.stdin;\n        this._stdout = this._process.stdout;\n        this._stderr = this._process.stderr;\n        this._writer.pipe(this._stdin);\n        this._stdout.pipe(this._reader, {\n            end: false\n        });\n        this.kill = this.destroy = kill;\n\n        // this._stderr.pipe(process.stderr);\n        this._stderr.on(\"data\", onStderrData);\n\n        // In some cases ECONNRESET can be emitted by stdin because the process is not interested in any\n        // more data but the _writer is still piping. Forget about errors emitted on stdin and stdout\n        this._stdin.on(\"error\", this.noop);\n        this._stdout.on(\"error\", this.noop);\n\n        this._stdout.on(\"end\", onStdoutEnd);\n\n        this._process.once(\"close\", onExit);\n        this._process.once(\"error\", onError);\n\n        return this;\n    }\n\n    pipe(dest, opts) {\n        return this._reader.pipe(dest, opts);\n    }\n\n    unpipe(dest) {\n        return this._reader.unpipe(dest) || this.kill();\n    }\n\n    setEncoding(enc) {\n        return this._reader.setEncoding(enc);\n    }\n\n    read(size) {\n        return this._reader.read(size);\n    }\n\n    end(chunk, enc, cb) {\n        return this._writer.end(chunk, enc, cb);\n    }\n\n    write(chunk, enc, cb) {\n        return this._writer.write(chunk, enc, cb);\n    }\n\n    destroy() {\n    }\n\n    kill() {\n    }\n\n    noop() {\n    }\n}\n\nFFmpegDuplex.prototype.addListener = FFmpegDuplex.prototype.on;\n\nFFmpegDuplex.spawn = function(connection, args, options) {\n    return new FFmpegDuplex(connection, options).spawn(args, options);\n};\n\nvar delegateEvents = {\n    readable: \"_reader\",\n    data: \"_reader\",\n    end: \"_reader\",\n    drain: \"_writer\",\n    finish: \"_writer\"\n};\n\nmodule.exports = FFmpegDuplex;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/FFmpegPCMTransformer.js":"\"use strict\";\n\nconst FFmpegDuplex = require(\"./FFmpegDuplex\");\n\nmodule.exports = function(options) {\n    options = options || {};\n    if(!options.command) {\n        throw new Error(\"Invalid converter command\");\n    }\n    if(options.samplingRate === undefined) {\n        options.samplingRate = 48000;\n    }\n    var inputArgs = [\n        \"-analyzeduration\", \"0\",\n        \"-loglevel\", \"24\"\n    ].concat(options.inputArgs || [],\n        \"-i\", options.input || \"-\",\n        \"-vn\"\n    );\n    var outputArgs = [\n        \"-f\", \"s16le\",\n        \"-ar\", \"\" + options.samplingRate,\n        \"-ac\", \"2\",\n        \"-\"\n    ];\n    return FFmpegDuplex.spawn(options.command, inputArgs.concat(options.encoderArgs || [], outputArgs));\n};\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/OggOpusTransformer.js":"\"use strict\";\n\nconst BaseTransformer = require(\"./BaseTransformer\");\n\nclass OggOpusTransformer extends BaseTransformer {\n    constructor(options) {\n        options = options || {};\n        super(options);\n\n        this._remainder = null;\n    }\n\n    process(buffer) {\n        if(buffer.length - buffer._index <= 26) {\n            return true;\n        }\n\n        if(buffer.toString(\"utf8\", buffer._index, buffer._index + 4) !== \"OggS\") {\n            return new Error(\"Invalid OGG magic string: \" + buffer.toString(\"utf8\", buffer._index, buffer._index + 4));\n        }\n\n        var typeFlag = buffer.readUInt8(buffer._index + 5);\n        if(typeFlag === 1) {\n            return new Error(\"OGG continued page not supported\");\n        }\n\n        buffer._index += 26;\n\n        var segmentCount = buffer.readUInt8(buffer._index);\n        if(buffer.length - buffer._index - 1 < segmentCount) {\n            return true;\n        }\n\n        var segments = [];\n        var size = 0;\n        var byte = 0;\n        var total = 0;\n        var i = 0;\n        for(; i < segmentCount; i++) {\n            byte = buffer.readUInt8(++buffer._index);\n            if(byte < 255) {\n                segments.push(size + byte);\n                size = 0;\n            } else {\n                size += byte;\n            }\n            total += byte;\n        }\n\n        ++buffer._index;\n\n        if(buffer.length - buffer._index < total) {\n            return true;\n        }\n\n        for(var segment of segments) {\n            buffer._index += segment;\n            byte = (segment = buffer.slice(buffer._index - segment, buffer._index)).toString(\"utf8\", 0, 8);\n            if(this.head) {\n                if(byte === \"OpusTags\") {\n                    this.emit(\"debug\", segment.toString());\n                } else {\n                    this.push(segment);\n                }\n            } else if(byte === \"OpusHead\") {\n                this.emit(\"debug\", (this.head = segment.toString()));\n            } else {\n                this.emit(\"error\", new Error(\"Invalid codec: \" + byte));\n            }\n        }\n    }\n\n    _transform(chunk, enc, cb) {\n        if(this._remainder)  {\n            chunk = Buffer.concat([this._remainder, chunk]);\n            this._remainder = null;\n        }\n\n        chunk._index = 0;\n\n        while(chunk._index < chunk.length) {\n            var offset = chunk._index;\n            var ret = this.process(chunk);\n            if(ret) {\n                this._remainder = chunk.slice(offset);\n                if(ret instanceof Error) {\n                    this.emit(\"error\", ret);\n                }\n                cb();\n                return;\n            }\n        }\n\n        this.setTransformCB(cb);\n    }\n}\n\nmodule.exports = OggOpusTransformer;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/PCMOpusTransformer.js":"\"use strict\";\n\nconst BaseTransformer = require(\"./BaseTransformer\");\n\nclass PCMOpusTransformer extends BaseTransformer {\n    constructor(options) {\n        options = options || {};\n        if(!options.opus) {\n            throw new Error(\"Supported opus encoder not found\");\n        }\n        super(options);\n\n        this.opus = options.opus;\n        this.frameSize = options.frameSize || 2880;\n        this.pcmSize = options.pcmSize || 11520;\n\n        this._remainder = null;\n    }\n\n    _transform(chunk, enc, cb) {\n        if(this._remainder) {\n            chunk = Buffer.concat([this._remainder, chunk]);\n            this._remainder = null;\n        }\n\n        if(chunk.length < this.pcmSize) {\n            this._remainder = chunk;\n            return cb();\n        }\n\n        chunk._index = 0;\n\n        while(chunk._index + this.pcmSize < chunk.length) {\n            chunk._index += this.pcmSize;\n            this.push(this.opus.encode(chunk.slice(chunk._index - this.pcmSize, chunk._index), this.frameSize));\n        }\n\n        if(chunk._index < chunk.length) {\n            this._remainder = chunk.slice(chunk._index);\n        }\n\n        this.setTransformCB(cb);\n    }\n\n    _flush(cb) {\n        if(this._remainder) {\n            var buf = new Buffer(this.pcmSize);\n            this._remainder.copy(buf);\n            buf.fill(0, this._remainder.length);\n            this.push(this.opus.encode(buf, this.frameSize));\n            this._remainder = null;\n        }\n        cb();\n    }\n}\n\nmodule.exports = PCMOpusTransformer;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/VolumeTransformer.js":"\"use strict\";\n\nconst BaseTransformer = require(\"./BaseTransformer\");\n\nclass VolumeTransformer extends BaseTransformer {\n    constructor(options) {\n        options = options || {};\n        super(options);\n\n        this._remainder = null;\n        this.setVolume(1.0);\n    }\n\n    setVolume(volume) {\n        if(isNaN(volume) || (volume = +volume) < 0) {\n            throw new Error(\"Invalid volume level: \" + volume);\n        }\n        this.volume = volume;\n        this.db = 10 * Math.log(1 + this.volume) / 6.931471805599453;\n    }\n\n    _transform(chunk, enc, cb) {\n        if(this._remainder)  {\n            chunk = Buffer.concat([this._remainder, chunk]);\n            this._remainder = null;\n        }\n\n        if(chunk.length < 2) {\n            return cb();\n        }\n\n        var buf;\n        if(chunk.length & 1) {\n            this._remainder = chunk.slice(chunk.length - 1);\n            buf = new Buffer(chunk.length - 1);\n        } else {\n            buf = new Buffer(chunk.length);\n        }\n\n        for(var i = 0, num; i < buf.length - 1; i += 2) {\n            // Bind transformed chunk to to 16 bit\n            num = ~~(this.db * chunk.readInt16LE(i));\n            buf.writeInt16LE(num >= 32767 ? 32767 : num <= -32767 ? -32767 : num, i);\n        }\n\n        this.push(buf);\n        this.setTransformCB(cb);\n    }\n}\n\nmodule.exports = VolumeTransformer;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/streams/WebmOpusTransformer.js":"\"use strict\";\n\nconst BaseTransformer = require(\"./BaseTransformer\");\n\n// EBML VInt max value is (2 ^ 56 - 2), but JS only supports 2^53\n// 45 = 53 - 8 - check before last 8 bytes\nconst MAX_SHIFTED_VINT = Math.pow(2, 45);\n\nconst STATE_CONTENT = 0;\nconst STATE_TAG = 1;\n\nconst TAG_TYPE_END = 0;\nconst TAG_TYPE_START = 1;\nconst TAG_TYPE_TAG = 2;\n\nconst TRACKTYPE_AUDIO = 2; // EBML spec: https://www.matroska.org/technical/specs/index.html#TrackType\n\nclass WebmOpusTransformer extends BaseTransformer {\n    constructor(options) {\n        options = options || {};\n        super(options);\n\n        this._tag_stack = [];\n        this._state = STATE_TAG;\n        this._total = 0;\n    }\n\n    process(type, info) {\n        if(type === TAG_TYPE_TAG) {\n            if(info.name === \"SimpleBlock\" && (info.data.readUInt8(0) & 0xF) === this.firstAudioTrack.TrackNumber) {\n                this.push(info.data.slice(4));\n                return;\n            }\n            if(info.name === \"CodecPrivate\") {\n                var head = info.data.toString(\"utf8\", 0, 8);\n                if(head !== \"OpusHead\") {\n                    this.emit(\"error\", new Error(\"Invalid codec: \" + head));\n                    return;\n                }\n\n                this.codecData = {\n                    version: info.data.readUInt8(8),\n                    channelCount: info.data.readUInt8(9),\n                    preSkip: info.data.readUInt16LE(10),\n                    inputSampleRate: info.data.readUInt32LE(12),\n                    outputGain: info.data.readUInt16LE(16),\n                    mappingFamily: info.data.readUInt8(18)\n                };\n                return;\n            }\n        }\n\n        if(!this.firstAudioTrack) {\n            if(info.name === \"TrackEntry\") {\n                if(type === TAG_TYPE_START) {\n                    this.parsingTrack = {};\n                } else if(type === TAG_TYPE_END) {\n                    if(this.parsingTrack.TrackNumber && this.parsingTrack.TrackType === TRACKTYPE_AUDIO) {\n                        this.firstAudioTrack = this.parsingTrack;\n                    }\n                    delete this.parsingTrack;\n                }\n                return;\n            }\n            if(this.parsingTrack) {\n                if(info.name === \"TrackNumber\") {\n                    this.parsingTrack.TrackNumber = info.data[0];\n                    return;\n                }\n                if(info.name === \"TrackType\") {\n                    this.parsingTrack.TrackType = info.data[0];\n                    return;\n                }\n            }\n            if(type === TAG_TYPE_END && info.name === \"Tracks\") {\n                this.emit(\"error\", new Error(\"No audio track\"));\n                return;\n            }\n            return;\n        }\n    }\n\n    getVIntLength(buffer, index) {\n        for(var length = 1; length <= 8; ++length) {\n            if(buffer[index] & (1 << (8 - length))) {\n                break;\n            }\n        }\n        if(length > 8) {\n            this.emit(\"debug\", new Error(`VInt length ${length} | ${buffer.toString(\"hex\", index, index + length)}`));\n            return null;\n        }\n        if(index + length > buffer.length) {\n            return null;\n        }\n        return length;\n    }\n\n    readTag(buffer) {\n        var tagSize = this.getVIntLength(buffer, buffer._index);\n        if(tagSize === null) {\n            return false;\n        }\n\n        var size = this.getVIntLength(buffer, buffer._index + tagSize);\n        if(size === null) {\n            return false;\n        }\n\n        var tagStr = buffer.toString(\"hex\", buffer._index, buffer._index + tagSize);\n\n        var tagObj = {\n            type: \"unknown\",\n            name: \"unknown\",\n            end: this._total + tagSize\n        };\n        if(schema[tagStr]) {\n            tagObj.type = schema[tagStr].type;\n            tagObj.name = schema[tagStr].name;\n        }\n\n        buffer._index += tagSize;\n\n        var value = buffer[buffer._index] & (1 << (8 - size)) - 1;\n        for(var i = 1; i < size; ++i) {\n            if(i === 7 && value >= MAX_SHIFTED_VINT && buffer[buffer._index + 7] > 0) {\n                tagObj.end = -1; // Special livestreaming int 0x1FFFFFFFFFFFFFF\n                break;\n            }\n            value = (value << 8) + buffer[buffer._index + i];\n        }\n        if(tagObj.end !== -1) {\n            tagObj.end += value + size;\n        }\n        tagObj.size = value;\n\n        buffer._index += size;\n        this._total += tagSize + size;\n        this._state = STATE_CONTENT;\n\n        this._tag_stack.push(tagObj);\n\n        return true;\n    }\n\n    readContent(buffer) {\n        var tagObj = this._tag_stack[this._tag_stack.length - 1];\n\n        if(tagObj.type === \"m\") {\n            this.process(TAG_TYPE_START, tagObj);\n            this._state = STATE_TAG;\n            return true;\n        }\n\n        if(buffer.length < buffer._index + tagObj.size) {\n            return false;\n        }\n\n        tagObj.data = buffer.slice(buffer._index, buffer._index + tagObj.size);\n        buffer._index += tagObj.size;\n        this._total += tagObj.size;\n        this._state = STATE_TAG;\n\n        this._tag_stack.pop();\n\n        this.process(TAG_TYPE_TAG, tagObj);\n\n        while(this._tag_stack.length > 0) {\n            if(this._total < this._tag_stack[this._tag_stack.length - 1].end) {\n                break;\n            }\n            this.process(TAG_TYPE_END, this._tag_stack.pop());\n        }\n\n        return true;\n    }\n\n    _transform(chunk, enc, cb) {\n        if(this._remainder)  {\n            chunk = Buffer.concat([this._remainder, chunk]);\n            this._remainder = null;\n        }\n\n        chunk._index = 0;\n\n        while(chunk._index < chunk.length) {\n            if(this._state === STATE_TAG && !this.readTag(chunk)) {\n                break;\n            }\n            if(this._state === STATE_CONTENT && !this.readContent(chunk)) {\n                break;\n            }\n        }\n\n        if(chunk._index < chunk.length) {\n            this._remainder = chunk.slice(chunk._index);\n        }\n\n        this.setTransformCB(cb);\n    }\n}\n\nmodule.exports = WebmOpusTransformer;\n\nconst schema = {\n    ae: {\n        name: \"TrackEntry\",\n        type: \"m\"\n    },\n    d7: {\n        name: \"TrackNumber\",\n        type: \"u\"\n    },\n    \"86\": {\n        name: \"CodecID\",\n        type: \"s\"\n    },\n    \"83\": {\n        name: \"TrackType\",\n        type: \"u\"\n    },\n    \"1654ae6b\": {\n        name: \"Tracks\",\n        type: \"m\"\n    },\n    \"63a2\": {\n        name: \"CodecPrivate\",\n        type: \"b\"\n    },\n    a3: {\n        name: \"SimpleBlock\",\n        type: \"b\"\n    },\n    \"1a45dfa3\": {\n        name: \"EBML\",\n        type: \"m\"\n    },\n    \"18538067\": {\n        name: \"Segment\",\n        type: \"m\"\n    },\n    \"114d9b74\": {\n        name: \"SeekHead\",\n        type: \"m\"\n    },\n    \"1549a966\": {\n        name: \"Info\",\n        type: \"m\"\n    },\n    e1: {\n        name: \"Audio\",\n        type: \"m\"\n    },\n    \"1f43b675\": {\n        name: \"Cluster\",\n        type: \"m\"\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/VoiceConnection.js":"\"use strict\";\n\nconst ChildProcess = require(\"child_process\");\nconst Constants = require(\"../Constants\");\nconst Dgram = require(\"dgram\");\nconst DNS = require(\"dns\");\nconst OPCodes = Constants.VoiceOPCodes;\nconst Piper = require(\"./Piper\");\nconst VoiceDataStream = require(\"./VoiceDataStream\");\nvar WebSocket = typeof window !== \"undefined\" ? window.WebSocket : require(\"ws\");\n\nvar EventEmitter;\ntry {\n    EventEmitter = require(\"eventemitter3\");\n} catch(err) {\n    EventEmitter = require(\"events\").EventEmitter;\n}\nvar NodeOpus;\ntry {\n    NodeOpus = require(\"node-opus\");\n} catch(err) { // eslint-disable no-empty\n}\nvar OpusScript;\ntry {\n    OpusScript = require(\"opusscript\");\n} catch(err) { // eslint-disable no-empty\n}\nvar Sodium = false;\nvar NaCl = false;\ntry {\n    Sodium = require(\"sodium-native\");\n} catch(err) {\n    try {\n        NaCl = require(\"tweetnacl\");\n    } catch(err) { // eslint-disable no-empty\n    }\n}\ntry {\n    WebSocket = require(\"uws\");\n} catch(err) { // eslint-disable no-empty\n}\n\nconst MAX_FRAME_SIZE = 1276 * 3;\nconst ENCRYPTION_MODE = \"xsalsa20_poly1305\";\n\n/**\n* Represents a voice connection\n* @extends EventEmitter\n* @prop {String} id The ID of the voice connection (guild ID)\n* @prop {String} channelID The ID of the voice connection's current channel\n* @prop {Boolean} connecting Whether the voice connection is connecting\n* @prop {Boolean} ready Whether the voice connection is ready\n* @prop {Boolean} playing Whether the voice connection is playing something\n* @prop {Boolean} paused Whether the voice connection is paused\n* @prop {Number} volume The current volume level of the connection\n* @prop {Object?} current The state of the currently playing stream\n* @prop {Number} current.startTime The timestamp of the start of the current stream\n* @prop {Number} current.playTime How long the current stream has been playing for, in milliseconds\n* @prop {Number} current.pausedTimestamp The timestamp of the most recent pause\n* @prop {Number} current.pausedTime How long the current stream has been paused for, in milliseconds\n* @prop {Options} current.options The custom options for the current stream\n*/\nclass VoiceConnection extends EventEmitter {\n    constructor(id, options) {\n        super();\n        options = options || {};\n\n        if(typeof window !== \"undefined\") {\n            throw new Error(\"Voice is not supported in browsers at this time\");\n        }\n\n        if(!Sodium && !NaCl) {\n            throw new Error(\"Error loading tweetnacl/libsodium, voice not available\");\n        }\n\n        this.id = id;\n        this.samplingRate = 48000;\n        this.channels = 2;\n        this.frameDuration = 20;\n        this.frameSize = this.samplingRate * this.frameDuration / 1000;\n        this.pcmSize = this.frameSize * this.channels * 2;\n        this.bitrate = 64000;\n        this.shared = !!options.shared;\n        this.shard = options.shard || {};\n        this.opusOnly = !!options.opusOnly;\n\n        if(!this.opusOnly && !this.shared) {\n            if(NodeOpus) {\n                this.opus = new NodeOpus.OpusEncoder(this.samplingRate, this.channels);\n            } else if(OpusScript) {\n                this.emit(\"debug\", \"node-opus not found, falling back to opusscript\");\n                this.opus = new OpusScript(this.samplingRate, this.channels, OpusScript.Application.AUDIO);\n                this.opus.setBitrate(this.bitrate);\n            } else {\n                throw new Error(\"No opus encoder found, playing non-opus audio will not work.\");\n            }\n        }\n\n        this.channelID = null;\n        this.paused = true;\n        this.speaking = false;\n        this.sequence = 0;\n        this.timestamp = 0;\n        this.ssrcUserMap = {};\n        this.converterCommand = null;\n\n        this.nonce = new Buffer(24);\n        this.nonce.fill(0);\n\n        this.packetBuffer = new Buffer(12 + 16 + MAX_FRAME_SIZE);\n        this.packetBuffer.fill(0);\n        this.packetBuffer[0] = 0x80;\n        this.packetBuffer[1] = 0x78;\n\n        if(!options.shared) {\n            var pick = this.pickCommand();\n            if(pick instanceof Error) {\n                /**\n                * Fired when the voice connection encounters an error. This event should be handled by users\n                * @event VoiceConnection#error\n                * @prop {Error} err The error object\n                */\n                this.emit(\"error\", pick);\n            }\n\n            this.piper = new Piper(this.converterCommand, this.opus);\n            this.piper.on(\"error\", (e) => this.emit(\"error\", e));\n\n            if(pick && this.converterCommand) {\n                this.piper.libopus = false;\n            }\n        }\n\n        this._send = this._send.bind(this);\n    }\n\n    _destroy() {\n        if(this.opus && this.opus.delete) {\n            this.opus.delete();\n            delete this.opus;\n        }\n        delete this.piper;\n        if(this.receiveStreamOpus) {\n            this.receiveStreamOpus.destroy();\n        }\n        if(this.receiveStreamPCM) {\n            this.receiveStreamPCM.destroy();\n        }\n    }\n\n    connect(data) {\n        if(this.ws && this.ws.readyState !== WebSocket.CLOSED) {\n            this.disconnect(undefined, true);\n            return setTimeout(() => this.connect(data), 500);\n        }\n        if(!data.endpoint || !data.token || !data.session_id || !data.user_id) {\n            this.disconnect(new Error(\"Malformed voice server update: \" + JSON.stringify(data)), false);\n            return;\n        }\n        this.channelID = data.channel_id;\n        this.endpoint = data.endpoint.split(\":\")[0];\n        this.ws = new WebSocket(\"wss://\" + this.endpoint);\n        /**\n        * Fired when stuff happens and gives more info\n        * @event VoiceConnection#debug\n        * @prop {String} message The debug message\n        */\n        this.emit(\"debug\", \"Connecting to WS: wss://\" + this.endpoint);\n        this.ws.on(\"open\", () => {\n            /**\n            * Fired when the voice connection connects\n            * @event VoiceConnection#connect\n            */\n            this.emit(\"connect\");\n            this.sendWS(OPCodes.IDENTIFY, {\n                server_id: this.id === \"call\" ? data.channel_id : this.id,\n                user_id: data.user_id,\n                session_id: data.session_id,\n                token: data.token\n            });\n        });\n        this.ws.on(\"message\", (m) => {\n            var packet = JSON.parse(m);\n            this.emit(\"debug\", \"Rec: \" + JSON.stringify(packet));\n            switch(packet.op) {\n                case OPCodes.HELLO: {\n                    if(packet.d.heartbeat_interval > 0) {\n                        if(this.heartbeatInterval) {\n                            clearInterval(this.heartbeatInterval);\n                        }\n                        this.heartbeatInterval = setInterval(() => {\n                            this.heartbeat();\n                        }, packet.d.heartbeat_interval);\n                        this.heartbeat();\n                    }\n                    this.emit(\"debug\", JSON.stringify(packet));\n                    this.ssrc = packet.d.ssrc;\n                    this.packetBuffer.writeUIntBE(this.ssrc, 8, 4);\n                    if(!~packet.d.modes.indexOf(ENCRYPTION_MODE)) {\n                        throw new Error(\"No supported voice mode found\");\n                    }\n                    this.modes = packet.d.modes;\n                    this.udpPort = packet.d.port;\n                    DNS.lookup(this.endpoint, (err, address) => { // RIP DNS\n                        if(err) {\n                            this.emit(\"error\", err);\n                            return;\n                        }\n\n                        this.udpIP = address;\n\n                        this.emit(\"debug\", \"Connecting to UDP: \" + this.udpIP + \":\" + this.udpPort);\n\n                        this.udpSocket = Dgram.createSocket(\"udp4\");\n                        this.udpSocket.once(\"message\", (packet) => {\n                            this.emit(\"debug\", packet.toString());\n                            var localIP = \"\";\n                            var i = 3;\n                            while(++i < packet.indexOf(0, i)) {\n                                localIP += String.fromCharCode(packet[i]);\n                            }\n                            var localPort = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10));\n\n                            this.sendWS(OPCodes.SELECT_PROTOCOL, {\n                                protocol: \"udp\",\n                                data: {\n                                    address: localIP,\n                                    port: localPort,\n                                    mode: ENCRYPTION_MODE\n                                }\n                            });\n                        });\n                        this.udpSocket.on(\"error\", (err, msg) => {\n                            this.emit(\"error\", err);\n                            if(msg) {\n                                this.emit(\"debug\", \"Voice UDP error: \" + msg);\n                            }\n                            if(this.ready) {\n                                this.disconnect(err);\n                            }\n                        });\n                        this.udpSocket.on(\"close\", (err) => {\n                            if(err) {\n                                this.emit(\"warn\", \"Voice UDP close: \" + err);\n                            }\n                            if(this.ready) {\n                                this.disconnect(err);\n                            }\n                        });\n                        var udpMessage = new Buffer(70);\n                        udpMessage.fill(0);\n                        udpMessage.writeUIntBE(this.ssrc, 0, 4);\n                        this._sendPacket(udpMessage);\n                    });\n                    break;\n                }\n                case OPCodes.SESSION_DESCRIPTION: {\n                    this.mode = packet.d.mode;\n                    this.secret = new Uint8Array(new ArrayBuffer(packet.d.secret_key.length));\n                    for (var i = 0; i < packet.d.secret_key.length; ++i) {\n                        this.secret[i] = packet.d.secret_key[i];\n                    }\n                    this.ready = true;\n                    /**\n                    * Fired when the voice connection turns ready\n                    * @event VoiceConnection#ready\n                    */\n                    this.emit(\"ready\");\n                    this.paused = false;\n                    this.timestamp = 0;\n                    this.sequence = 0;\n                    break;\n                }\n                case OPCodes.HEARTBEAT: {\n                    /**\n                    * Fired when the voice connection receives a pong\n                    * @event VoiceConnection#pong\n                    * @prop {Number} latency The current latency in milliseconds\n                    */\n                    this.emit(\"pong\", Date.now() - packet.d);\n                    break;\n                }\n                case OPCodes.SPEAKING: {\n                    this.ssrcUserMap[packet.d.ssrc] = packet.d.user_id;\n                    /**\n                    * Fired when a user begins speaking\n                    * @event VoiceConnection#speakingStart\n                    * @prop {String} userID The ID of the user that began speaking\n                    */\n                    /**\n                    * Fired when a user stops speaking\n                    * @event VoiceConnection#speakingStop\n                    * @prop {String} userID The ID of the user that stopped speaking\n                    */\n                    this.emit(packet.d.speaking ? \"speakingStart\" : \"speakingStop\", packet.d.user_id);\n                    break;\n                }\n                default: {\n                    this.emit(\"unknown\", packet);\n                    break;\n                }\n            }\n        });\n        this.ws.on(\"close\", (code, err) => {\n            this.emit(\"warn\", `Voice WS close ${code}` + (err && \" | \" + err));\n            if(this.ready) {\n                this.disconnect(err);\n            }\n        });\n        setTimeout(() => {\n            if(this.connecting) {\n                this.disconnect(new Error(\"Voice connection timeout\"));\n            }\n        }, this.shard.client ? this.shard.client.options.connectionTimeout : 30000);\n    }\n\n    /**\n    * Tells the voice connection to disconnect\n    * @arg {Error} [err] The error, if any\n    * @arg {Boolean} [reconnecting] Whether the voice connection is reconnecting or not\n    */\n    disconnect(error, reconnecting) {\n        this.ready = false;\n        this.speaking = false;\n        this.timestamp = 0;\n        this.sequence = 0;\n\n        this.stopPlaying();\n\n        if(reconnecting) {\n            this.paused = true;\n        } else {\n            this.playing = false;\n        }\n        if(this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n        if(this.udpSocket) {\n            try {\n                this.udpSocket.close();\n            } catch(err) {\n                if(err.message !== \"Not running\") {\n                    this.emit(\"error\", err);\n                }\n            }\n            this.udpSocket = null;\n        }\n        if(this.ws) {\n            try {\n                this.ws.close();\n            } catch(err) {\n                this.emit(\"error\", err);\n            }\n            this.ws = null;\n        }\n        if(reconnecting) {\n            this.emit(\"error\", error);\n        } else {\n            this.channelID = null;\n            this.updateVoiceState();\n            /**\n            * Fired when the voice connection disconnects\n            * @event VoiceConnection#disconnect\n            * @prop {Error?} err The error, if any\n            */\n            this.emit(\"disconnect\", error);\n        }\n    }\n\n    heartbeat() {\n        this.sendWS(OPCodes.HEARTBEAT, Date.now());\n    }\n\n    /**\n    * Play an audio or video resource. If playing from a non-opus resource, FFMPEG should be compiled with --enable-libopus for best performance. If playing from HTTPS, FFMPEG must be compiled with --enable-openssl\n    * @arg {ReadableStream | String} resource The audio or video resource, either a ReadableStream, URL, or file path\n    * @arg {Object} [options] Music options\n    * @arg {Boolean} [options.inlineVolume=false] Whether to enable on-the-fly volume changing. Note that enabling this leads to increased CPU usage\n    * @arg {Number} [options.voiceDataTimeout=2000] Timeout when waiting for voice data (-1 for no timeout)\n    * @arg {Array<String>} [options.inputArgs] Additional input parameters to pass to ffmpeg/avconv (before -i)\n    * @arg {Array<String>} [options.encoderArgs] Additional encoder parameters to pass to ffmpeg/avconv (after -i)\n    * @arg {String} [options.format] The format of the resource. If null, FFmpeg will attempt to guess and play the format. Available options: \"dca\", \"ogg\", \"pcm\", null\n    * @arg {Number} [options.frameDuration=20] The resource opus frame duration (required for DCA/Ogg)\n    * @arg {Number} [options.frameSize=2880] The resource opus frame size\n    * @arg {Number} [options.sampleRate=48000] The resource audio sampling rate\n    */\n    play(source, options) {\n        if(this.shared) {\n            throw new Error(\"Cannot play stream on shared voice connection\");\n        }\n        if(!this.ready) {\n            throw new Error(\"Not ready yet\");\n        }\n\n        options = options || {};\n        options.format = options.format || null;\n        options.voiceDataTimeout = !isNaN(options.voiceDataTimeout) ? options.voiceDataTimeout : 2000;\n        options.inlineVolume = !!options.inlineVolume;\n        options.inputArgs = options.inputArgs || [];\n        options.encoderArgs = options.encoderArgs || [];\n\n        options.samplingRate = options.samplingRate || this.samplingRate;\n        options.frameDuration = options.frameDuration || this.frameDuration;\n        options.frameSize = options.frameSize || options.samplingRate * options.frameDuration / 1000;\n        options.pcmSize = options.pcmSize || options.frameSize * 2 * this.channels;\n\n        if(!this.piper.encode(source, options)) {\n            this.emit(\"error\", new Error(\"Unable to encode source\"));\n            return;\n        }\n\n        this.ended = false;\n        this.current = {\n            startTime: 0, // later\n            playTime: 0,\n            pausedTimestamp: 0,\n            pausedTime: 0,\n            bufferingTicks: 0,\n            options: options,\n            timeout: null,\n            buffer: null\n        };\n\n        this.playing = true;\n\n        /**\n        * Fired when the voice connection starts playing a stream\n        * @event SharedStream#start\n        */\n        this.emit(\"start\");\n\n        this._send();\n    }\n\n    _send() {\n        if(!this.piper.encoding && this.piper.dataPacketCount === 0) {\n            return this.stopPlaying();\n        }\n\n        this.timestamp += this.current.options.frameSize;\n        if(this.timestamp >= 4294967295) {\n            this.timestamp -= 4294967295;\n        }\n\n        if(++this.sequence >= 65536) {\n            this.sequence -= 65536;\n        }\n\n        if((this.current.buffer = this.piper.getDataPacket())) {\n            if(this.current.startTime === 0) {\n                this.current.startTime = Date.now();\n            }\n            if(this.current.bufferingTicks > 0) {\n                this.current.bufferingTicks = 0;\n                this.setSpeaking(true);\n            }\n        } else if(this.current.options.voiceDataTimeout === -1 || this.current.bufferingTicks < this.current.options.voiceDataTimeout / this.current.options.frameDuration) { // wait for data\n            if(++this.current.bufferingTicks <= 0) {\n                this.setSpeaking(false);\n            }\n            this.current.pausedTime += 4 * this.current.options.frameDuration;\n            this.timestamp += 3 * this.current.options.frameSize;\n            if(this.timestamp >= 4294967295) {\n                this.timestamp -= 4294967295;\n            }\n            this.current.timeout = setTimeout(this._send, 4 * this.current.options.frameDuration);\n            return;\n        } else {\n            return this.stopPlaying();\n        }\n\n        this._sendPacket(this._createPacket(this.current.buffer));\n        this.current.playTime += this.current.options.frameDuration;\n        this.current.timeout = setTimeout(this._send, this.current.startTime + this.current.pausedTime + this.current.playTime - Date.now());\n    }\n\n    /**\n    * Stop the bot from sending audio\n    */\n    stopPlaying() {\n        if(this.ended) {\n            return;\n        }\n        this.ended = true;\n        if(this.current && this.current.timeout) {\n            clearTimeout(this.current.timeout);\n            this.current.timeout = null;\n        }\n        this.current = null;\n        this.piper.stop();\n        this.piper.resetPackets();\n\n        if(this.secret) {\n            for(var i = 0; i < 5; i++) {\n                this.timestamp += this.frameSize;\n                if(this.timestamp >= 4294967295) {\n                    this.timestamp -= 4294967295;\n                }\n\n                if(++this.sequence >= 65536) {\n                    this.sequence -= 65536;\n                }\n\n                this._sendPacket(this._createPacket(new Buffer([0xF8, 0xFF, 0xFE])));\n            }\n        }\n        this.setSpeaking(this.playing = false);\n\n        /**\n        * Fired when the voice connection finishes playing a stream\n        * @event VoiceConnection#end\n        */\n        this.emit(\"end\");\n    }\n\n    _createPacket(_buffer) {\n        this.packetBuffer.writeUIntBE(this.sequence, 2, 2);\n        this.packetBuffer.writeUIntBE(this.timestamp, 4, 4);\n\n        this.packetBuffer.copy(this.nonce, 0, 0, 12);\n\n        var len = _buffer.length;\n        if(!NaCl) {\n            Sodium.crypto_secretbox_easy(this.packetBuffer.slice(12), _buffer, this.nonce, this.secret);\n            len += Sodium.crypto_secretbox_MACBYTES;\n        } else {\n            var buffer = NaCl.secretbox(_buffer, this.nonce, this.secret);\n            len += NaCl.lowlevel.crypto_secretbox_BOXZEROBYTES;\n            this.packetBuffer.fill(0, 12, 12 + len);\n            for (var i = 0; i < len; ++i) {\n                this.packetBuffer[12 + i] = buffer[i];\n            }\n        }\n\n        return this.packetBuffer.slice(0, 12 + len);\n    }\n\n    _sendPacket(packet) {\n        try {\n            this.udpSocket.send(packet, 0, packet.length, this.udpPort, this.udpIP);\n        } catch(e) {\n            if(this.udpSocket) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n\n    /**\n    * Generate a receive stream for the voice connection.\n    * @arg {String} [type=\"pcm\"] The desired vocie data type, either \"opus\" or \"pcm\"\n    * @returns {VoiceDataStream}\n    */\n    receive(type) {\n        if(type === \"pcm\") {\n            if(!this.receiveStreamPCM) {\n                this.receiveStreamPCM = new VoiceDataStream(type);\n                if(!this.receiveStreamOpus) {\n                    this.registerReceiveEventHandler();\n                }\n            }\n        } else if(type === \"opus\") {\n            if(!this.receiveStreamOpus) {\n                this.receiveStreamOpus = new VoiceDataStream(type);\n                if(!this.receiveStreamPCM) {\n                    this.registerReceiveEventHandler();\n                }\n            }\n        } else {\n            throw new Error(`Unsupported voice data type: ${type}`);\n        }\n        return type === \"pcm\" ? this.receiveStreamPCM : this.receiveStreamOpus;\n    }\n\n    registerReceiveEventHandler() {\n        this.udpSocket.on(\"message\", (msg) => {\n            var nonce = new Buffer(24);\n            nonce.fill(0);\n            msg.copy(nonce, 0, 0, 12);\n            var data;\n            if(!NaCl) {\n                data = new Buffer(msg.length - 12 - Sodium.crypto_secretbox_MACBYTES);\n                Sodium.crypto_secretbox_open_easy(data, msg.slice(12), this.nonce, this.secret);\n            } else {\n                if(!(data = NaCl.secretbox_open(msg.slice(12), nonce, this.secret))) {\n                    /**\n                    * Fired to warn of something weird but non-breaking happening\n                    * @event VoiceConnection#warn\n                    * @prop {String} message The warning message\n                    */\n                    this.emit(\"warn\", \"Failed to decrypt received packet\");\n                    return;\n                }\n            }\n            if(this.receiveStreamOpus) {\n                /**\n                * Fired when a voice data packet is received\n                * @event VoiceDataStream#data\n                * @prop {Buffer} data The voice data\n                * @prop {String} userID The user who sent the voice packet\n                * @prop {Number} timestamp The intended timestamp of the packet\n                * @prop {Number} sequence The intended sequence number of the packet\n                */\n                this.receiveStreamOpus.emit(\"data\", data, this.ssrcUserMap[nonce.readUIntBE(8, 4)], nonce.readUIntBE(4, 4), nonce.readUIntBE(2, 2));\n            }\n            if(this.receiveStreamPCM) {\n                data = this.opus.decode(data, this.frameSize);\n                if(!data) {\n                    return this.emit(\"warn\", \"Failed to decode received packet\");\n                }\n                this.receiveStreamPCM.emit(\"data\", data, this.ssrcUserMap[nonce.readUIntBE(8, 4)], nonce.readUIntBE(4, 4), nonce.readUIntBE(2, 2));\n            }\n        });\n    }\n\n    pickCommand() {\n        var tenative;\n        for(var command of [\"./ffmpeg\", \"./avconv\", \"ffmpeg\", \"avconv\"]) {\n            var res = ChildProcess.spawnSync(command, [\"-encoders\"]);\n            if(!res.error) {\n                if(!res.stdout.toString().includes(\"libopus\")) {\n                    tenative = command;\n                    continue;\n                }\n                this.converterCommand = command;\n                return;\n            }\n        }\n        if(tenative) {\n            return (this.converterCommand = tenative) + \" does not have libopus support. Non-opus playback may be laggy\";\n        }\n        throw new Error(\"Neither ffmpeg nor avconv was found. Make sure you installed either one, and check that it is in your PATH\");\n    }\n\n    setSpeaking(value) {\n        if((value = !!value) != this.speaking) {\n            this.speaking = value;\n            this.sendWS(OPCodes.SPEAKING, {\n                speaking: value,\n                delay: 0\n            });\n        }\n    }\n\n    /**\n    * Switch the voice channel the bot is in. The channel to switch to must be in the same guild as the current voice channel\n    * @arg {String} channelID The ID of the voice channel\n    */\n    switchChannel(channelID, reactive) {\n        if(this.channelID === channelID) {\n            return;\n        }\n\n        this.channelID = channelID;\n        if(!reactive) {\n            this.updateVoiceState();\n        }\n    }\n\n    /**\n    * Update the bot's voice state\n    * @arg {Boolean} selfMute Whether the bot muted itself or not (audio sending is unaffected)\n    * @arg {Boolean} selfDeaf Whether the bot deafened itself or not (audio receiving is unaffected)\n    */\n    updateVoiceState(selfMute, selfDeaf) {\n        if(this.shard.sendWS) {\n            this.shard.sendWS(Constants.GatewayOPCodes.VOICE_STATE_UPDATE, {\n                guild_id: this.id === \"call\" ? null : this.id,\n                channel_id: this.channelID || null,\n                self_mute: !!selfMute,\n                self_deaf: !!selfDeaf\n            });\n        }\n    }\n\n    sendWS(op, data) {\n        if(this.ws && this.ws.readyState === WebSocket.OPEN) {\n            data = JSON.stringify({op: op, d: data});\n            this.ws.send(data);\n            this.emit(\"debug\", data);\n        }\n    }\n\n    get volume() {\n        return this.piper.volumeLevel;\n    }\n\n    /**\n    * Modify the output volume of the current stream (if inlineVolume is enabled for the current stream)\n    * @arg {Number} [volume=1.0] The desired volume. 0.0 is 0%, 1.0 is 100%, 2.0 is 200%, etc. It is not recommended to go above 2.0\n    */\n    setVolume(volume) {\n        this.piper.setVolume(volume);\n    }\n\n    /**\n    * Pause sending audio (if playing)\n    */\n    pause() {\n        this.paused = true;\n        if(this.current) {\n            if(!this.current.pausedTimestamp) {\n                this.current.pausedTimestamp = Date.now();\n            }\n            if(this.current.timeout) {\n                clearTimeout(this.current.timeout);\n                this.current.timeout = null;\n            }\n        }\n    }\n\n    /**\n    * Resume sending audio (if paused)\n    */\n    resume() {\n        this.paused = false;\n        if(this.current) {\n            if(this.current.pausedTimestamp) {\n                this.current.pausedTime += Date.now() - this.current.pausedTimestamp;\n                this.current.pausedTimestamp = 0;\n            }\n            this._send();\n        }\n    }\n}\n\nmodule.exports = VoiceConnection;\n","/home/travis/build/npmtest/node-npmtest-eris/node_modules/eris/lib/voice/VoiceDataStream.js":"\"use strict\";\n\nvar EventEmitter;\ntry {\n    EventEmitter = require(\"eventemitter3\");\n} catch(err) {\n    EventEmitter = require(\"events\").EventEmitter;\n}\n\n/**\n* Represents a voice data stream\n* @extends EventEmitter\n* @prop {String} type The targeted voice data type for the stream, either \"opus\" or \"pcm\"\n*/\nclass VoiceDataStream extends EventEmitter {\n    constructor(type) {\n        super();\n        this.type = type;\n    }\n}\n\nmodule.exports = VoiceDataStream;\n"}